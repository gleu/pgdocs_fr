<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="indexam">
 <title>Définition de l'interface des méthodes d'accès aux index</title>

 <para>
  Ce chapitre définit l'interface entre le cœur du système de
  <productname>PostgreSQL</productname> et les <firstterm>méthodes d'accès
   aux index</firstterm>, qui gérent chaque type d'index. Le système principal
  ne sait rien des index en dehors de ce qui est spécifié ici. Il est donc
  possible de développer des types d'index entièrement nouveaux en écrivant du code
  supplémentaire.
 </para>

 <para>
  Tous les index de <productname>PostgreSQL</productname> sont
  techniquement des <firstterm>index secondaires</firstterm>&nbsp;; c'est-à-dire
  que l'index est séparé physiquement du fichier de la table qu'il décrit. Chaque index
  est stocké dans sa propre <firstterm>relation</firstterm> physique et est donc décrit
  par une entrée dans le catalogue <structname>pg_class</structname>. Le contenu d'un
  index est entièrement contrôlé par la méthode d'accès à l'index. En
  pratique, toutes les méthodes d'accès aux index les divisent en pages de
  taille standard de façon à utiliser le gestionnaire de stockage
  et le gestionnaire de tampon pour accéder au contenu de l'index. (De plus,
  toutes les méthodes existantes d'accès aux index utilisent la disposition
  de page standard décrite dans <xref linkend="storage-page-layout"/> et la plupart
  ont le même format pour les en-têtes de ligne de
  l'index&nbsp;; mais ce ne sont pas des obligations pour toutes les méthodes d'accès.)
 </para>

 <para>
  Dans les faits, un index est une correspondance entre certaines valeurs de données clés
  et les identifiants des lignes (<firstterm>tuple identifiers</firstterm>, ou <acronym>TIDs</acronym>),
  dans leurs différentes versions, dans la table parente de l'index. Un TID consiste en un
  numéro de bloc et un numéro d'élément dans ce bloc (voir <xref
  linkend="storage-page-layout"/>). L'information est suffisante pour
  récupérer une version d'une ligne particulière à partir de la table. Les index
  n'ont pas directement connaissance de l'existence éventuelle, à cause du MVCC,
  de plusieurs versions de la même ligne logique&nbsp;; pour un index, chaque ligne
  est un objet indépendant qui a besoin de sa propre entrée. En conséquence,
  la mise à jour d'une ligne crée toujours de nouvelles entrées
  dans l'index pour cette ligne, même si les valeurs de la clé ne changent pas.
  (Les lignes HOT sont une exception&nbsp;; mais les index ne s'en occupent pas).
  Les entrées d'index pour les lignes mortes sont nettoyées (par
  le VACUUM) lorsque les lignes mortes elles-même sont nettoyées.
 </para>

 <sect1 id="index-api">
  <title>Structure basique de l'API pour les index</title>

  <para>
   Chaque méthode d'accès à un index est décrite par une ligne dans le
   catalogue système <link
   linkend="catalog-pg-am"><structname>pg_am</structname></link>. Elle
   indique un nom et une <firstterm>fonction gestionnaire</firstterm>
   pour la méthode d'accès. Ces entrées peuvent être
   créées et supprimées en utilisant les commandes SQL <xref
   linkend="sql-create-access-method"/> et <xref
   linkend="sql-drop-access-method"/> respectivement.
  </para>

  <para>
   Une fonction gestionnaire de méthode d'accès aux index doit être déclarée
   avec un seul argument de type <type>internal</type> et en retour
   le pseudo-type <type>index_am_handler</type>. L'argument est une
   valeur sans utilité sinon pour empêcher les fonctions
   gestionnaires d'être appelées directement à partir d'une commande SQL. Le
   résultat de la fonction doit être une structure, allouée avec palloc, de
   type <structname>IndexAmRoutine</structname>, et contenant tout ce que le code
   interne a besoin de savoir pour utiliser la méthode d'accès à l'index. La
   structure <structname>IndexAmRoutine</structname>, aussi appelée
   <firstterm>API struct</firstterm> de la méthode, inclut les champs spécifiant
   les propriétés fixes de la méthode d'accès, comme le support
   des index multi-colonnes. Plus important, elle contient les pointeurs vers
   les fonctions de la méthode d'accès, qui se chargent de tout le travail
   d'accès aux index. Ces fonctions de support sont de simples fonctions
   en C et ne sont ni visibles ni appelables au niveau SQL. Elles sont
   décrites dans <xref linkend="index-functions"/>.
  </para>

  <para>
   La structure <structname>IndexAmRoutine</structname> est définie ainsi&nbsp;:
<programlisting>
typedef struct IndexAmRoutine
{
    NodeTag     type;

    /*
     * Nombre total de stratégies (opérateurs) par lequels nous pouvons
     * traverser la méthode d'accès ou chercher dedans. Zéro si la méthode
     * n'a pas de jeu de stratégies fixé.
     */
    uint16      amstrategies;
    /* nombre total de fonctions support utilisées par cette méthode d'accès */
    uint16      amsupport;
    /* la méthode supporte-t-elle un ORDER BY sur la colonne indexée ? */
    bool        amcanorder;
    /* la méthode supporte-t-elle un ORDER BY sur le résultat d'un opérateur appliqué à une colonne indexée ? */
    bool        amcanorderbyop;
    /* la méthode supporte-t-elle le parcours à rebours ? */
    bool        amcanbackward;
    /* la méthode supporte-t-elle les index UNIQUE ? */
    bool        amcanunique;
    /* la méthode supporte-t-elle les index multi-colonnes ? */
    bool        amcanmulticol;
    /* la méthode exige-t-elle un parcours pour une contrainte sur la première colonne de l'index ? */
    bool        amoptionalkey;
    /* la méthode gère-t-elle les qualificatifs ScalarArrayOpExpr ? */
    bool        amsearcharray;
    /* la méthode gère-elle les qualificatifs IS NULL/IS NOT NULL ? */
    bool        amsearchnulls;
    /* le type de la valeur dans l'index peut-elle différer du type de la colonne ? */
    bool        amstorage;
    /* un index de ce type peut-il être la cible de la commande CLUSTER ? */
    bool        amclusterable;
    /* la méthode gère-t-elle les verrous sur prédicat ? */
    bool        ampredlocks;
    /* la méthode gère-t-elle les parcours parallélisés ? */
    bool        amcanparallel;
    /* la méthode gère-t-elle les colonnes incluses avec la clause INCLUDE ? */
    bool        amcaninclude;
    /* type de données stocké dans l'index, ou InvalidOid si variable */
    Oid         amkeytype;

    /* fonctions d'interfaçage */
    ambuild_function ambuild;
    ambuildempty_function ambuildempty;
    aminsert_function aminsert;
    ambulkdelete_function ambulkdelete;
    amvacuumcleanup_function amvacuumcleanup;
    amcanreturn_function amcanreturn;   /* peut être NULL */
    amcostestimate_function amcostestimate;
    amoptions_function amoptions;
    amproperty_function amproperty;     /* peut être NULL */
    amvalidate_function amvalidate;
    ambeginscan_function ambeginscan;
    amrescan_function amrescan;
    amgettuple_function amgettuple;     /* peut être NULL */
    amgetbitmap_function amgetbitmap;   /* peut être NULL */
    amendscan_function amendscan;
    ammarkpos_function ammarkpos;       /* peut être NULL */
    amrestrpos_function amrestrpos;     /* peut être NULL */

    /* interface functions to support parallel index scans */
    amestimateparallelscan_function amestimateparallelscan;    /* can be NULL */
    aminitparallelscan_function aminitparallelscan;    /* can be NULL */
    amparallelrescan_function amparallelrescan;    /* can be NULL */
} IndexAmRoutine;
</programlisting>
  </para>

  <para>
   Pour être utile, une méthode d'accès à l'index doit aussi avoir une ou
   plusieurs <firstterm>familles d'opérateurs</firstterm> et <firstterm>classes
    d'opérateurs</firstterm> définies dans
   <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>,
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link> et
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   Ces entrées permettent au planificateur de déterminer les types
   de requêtes qui peuvent être utilisés avec les index de cette méthode d'accès.
   Les familles et classes d'opérateurs sont décrites dans <xref
   linkend="xindex"/>, qui est un élément requis pour comprendre ce chapitre.
  </para>

  <para>
   Un index individuel est défini par une entrée dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   en tant que relation physique, et une entrée dans
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   affichant son contenu logique &mdash; c'est-à-dire ses colonnes
   et leur sémantique, telles que
   récupérées par les classes d'opérateurs associées. Les colonnes de
   l'index (valeurs clés) peuvent être de simples colonnes de la table
   sous-jacente ou des expressions des lignes. Habituellement,
   la méthode d'accès ne s'intéresse pas à la provenance
   des valeurs clés (elles lui arrivent toujours
   pré-calculées), mais plutôt aux informations de la classe
   d'opérateurs dans <structname>pg_index</structname>.
   On peut accéder aux entrées de ces deux
   catalogues via la structure de données
   <structname>Relation</structname> passée à toute opération sur l'index.
  </para>

  <para>
   Certains champs de <structname>IndexAmRoutine</structname> ont des
   implications peu évidentes. Les besoins de <structfield>amcanunique</structfield>
   sont discutés dans <xref linkend="index-unique-checks"/>.
   L'option <structfield>amcanmulticol</structfield> indique que la méthode
   d'accès supporte les index multi-colonnes alors que
   <structfield>amoptionalkey</structfield> autorise des parcours
   lorsqu'aucune restriction indexable n'est fournie pour la première colonne
   de l'index. Quand <structfield>amcanmulticol</structfield> est faux,
   <structfield>amoptionalkey</structfield> indique essentiellement que la méthode
   d'accès autorise les parcours complets de l'index sans clause de restriction.
   Les méthodes d'accès supportant les colonnes multiples
   <emphasis>doivent</emphasis> supporter les parcours sans
   restriction sur une ou toutes les colonnes après la première&nbsp;;
   néanmoins, elles peuvent imposer une restriction sur la
   première colonne de l'index, ce qui est signalé par
   <structfield>amoptionalkey</structfield> à false .
   Une raison pour une méthode d'accès d'index d'initialiser
   <structfield>amoptionalkey</structfield> à false est de ne pas indexer
   les valeurs NULL. Comme la plupart des opérateurs indexables
   sont stricts et ne peuvent donc pas renvoyer true pour des entrées NULL,
   à première vue on ne voudra pas stocker d'entrées pour les
   valeurs NULL&nbsp;: un parcours d'index ne peut de toute façon pas les
   retourner. Néanmoins, cette raison ne vaut pas pour un parcours d'index
   sans restriction pour une colonne d'index donnée. En pratique,
   cela signifie que les index avec <structfield>amoptionalkey</structfield> à
   true doivent indexer les valeurs NULL, car le planificateur peut décider
   de les utiliser sans aucune clé de parcours. Une limite
   liée&nbsp;: une méthode d'accès qui supporte des colonnes
   multiples <emphasis>doit</emphasis> supporter l'indexation des NULL dans
   les colonnes après la première, car le planificateur supposera l'index
   utilisable avec les requêtes ne restreignant pas ces colonnes. Par exemple,
   considérons un index sur (a,b) et une requête avec <literal>WHERE a =
    4</literal>. Le système supposera que l'index est utilisable pour
   les lignes où <literal>a = 4</literal>, ce qui est
   faux si l'index omet les lignes où <literal>b</literal> est NULL.
   Néanmoins, on peut omettre les lignes où la
   première colonne indexée est NULL. Du coup, une méthode d'accès d'index
   ne s'occupant pas des valeurs NULL peut aussi affecter
   <structfield>amsearchnulls</structfield> à true, indiquant ainsi qu'elle
   supporte les clauses <literal>IS NULL</literal> et
   <literal>IS NOT NULL</literal> dans les conditions de recherche.
  </para>

 </sect1>

 <sect1 id="index-functions">
  <title>Fonctions des méthode d'accès aux index</title>

  <para>
   Les fonctions de construction et de maintenance que doit fournir
   une méthode d'accès aux index dans <structname>IndexAmRoutine</structname>
   sont&nbsp;:
  </para>

  <para>
   <programlisting>IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
   </programlisting>
   Construit un nouvel index. La relation de l'index a été créée physiquement
   mais elle est vide. Elle doit être remplie avec toute donnée figée nécessaire
   à la méthode d'accès, ainsi que les entrées pour toutes les lignes existant
   déjà dans la table. Habituellement, la fonction <function>ambuild</function>
   appelle <function>IndexBuildHeapScan()</function> pour parcourir la table
   à la recherche des lignes existantes et calculer les clés à insérer
   dans l'index. La fonction doit renvoyer une structure allouée par palloc
   contenant les statistiques du nouvel index.
  </para>

  <para>
   <programlisting>bool
void
ambuildempty (Relation indexRelation);
   </programlisting>
   Construit un index vide et l'écrit dans le fichier d'initialisation
   (<symbol>INIT_FORKNUM</symbol>) de la relation. Cette méthode n'est appelée
   que pour les index non journalisés&nbsp;; l'index vide écrit dans ce fichier
   écrasera le fichier de la relation à chaque redémarrage du serveur.
  </para>

  <para>
   <programlisting>bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique,
          IndexInfo *indexInfo);
   </programlisting>
   Insère une nouvelle ligne dans un index existant. Les tableaux
   <literal>values</literal> et <literal>isnull</literal> donnent les valeurs
   de clés à indexer et <literal>heap_tid</literal> est le TID à indexer.
   Si la méthode d'accès supporte les
   index uniques (son drapeau <structfield>amcanunique</structfield>
   vaut true), alors <literal>checkUnique</literal> indique le type de
   vérification d'unicité nécessaire. Elle varie si la contrainte unique est
   déferrable ou non&nbsp;; voir <xref linkend="index-unique-checks"/> pour
   les détails. Normalement, la méthode d'accès a seulement besoin du
   paramètre <literal>heapRelation</literal> lors de la vérification
   d'unicité (car elle doit vérifier la visibilité de la ligne dans la table).
  </para>

  <para>
   La valeur booléenne résultante n'a de sens
   que si <literal>checkUnique</literal> vaut
   <literal>UNIQUE_CHECK_PARTIAL</literal>. Dans ce cas, un résultat true
   signifie que la nouvelle entrée est reconnue comme unique alors que false
   indique qu'elle pourrait ne pas être unique (et une vérification d'unicité
   déferrée doit être planifiée). Dans les autres cas, renvoyer une constante
   false est recommandé.
  </para>

  <para>
   Certains index peuvent ne pas indexer toutes les lignes. Si la ligne
   ne doit pas être indexée, <function>aminsert</function> devrait s'achever
   sans rien faire.
  </para>

  <para>
   Si l'AM de l'index souhaite mettre en cache des données entre plusieurs
   insertions successives dans l'index au sein d'un même ordre SQL, il peut
   allouer de l'espace dans <literal>indexInfo-&gt;ii_Context</literal> et
   stocker un pointeur vers les données dans
   <literal>indexInfo-&gt;ii_AmCache</literal> (qui sera initialement NULL).
  </para>

  <para>
   <programlisting>IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
   </programlisting>
   Supprime un ou des tuple(s) de l'index. Il s'agit d'une opération de
   <quote>suppression en masse</quote> à implémenter par un parcours complet de
   l'index et la vérification de chaque entrée pour voir si elle
   doit être supprimée. La fonction <literal>callback</literal> en argument
   doit être appelée, sous la forme
   <literal>callback(<replaceable>TID</replaceable>, callback_state)
   returns bool</literal>, pour déterminer si une entrée d'index particulière,
   identifiée par son TID, doit être supprimée. Elle doit retourner NULL
   ou une structure issue d'un palloc contenant des statistiques sur les
   effets de la suppression.
   La fonction peut renvoyer NULL si aucune information n'a besoin d'être
   envoyée à <function>amvacuumcleanup</function>.
  </para>

  <para>
   À cause d'un <varname>maintenance_work_mem</varname> limité, la
   suppression de nombreux tuples peut nécessiter d'appeler
   <function>ambulkdelete</function> à plusieurs reprises.
   L'argument <literal>stats</literal> est le résultat du dernier appel pour
   cet index (il est NULL au premier appel dans une opération
   <command>VACUUM</command>). Ceci permet à la méthode d'accumuler des
   statistiques sur toute l'opération. Typiquement,
   <function>ambulkdelete</function>  modifie et renvoie la même structure
   si le <literal>stats</literal> fourni n'est pas NULL.
  </para>

  <para>
   <programlisting>IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
   </programlisting>
   Nettoyer après une opération <command>VACUUM</command> (zéro à plusieurs
   appels à <function>ambulkdelete</function>). La fonction n'a pas d'autre but
   que de retourner des statistiques sur les index, mais elle peut réaliser
   un nettoyage en masse (réclamer les pages d'index vides, par exemple).
   <literal>stats</literal> est le retour de l'appel à
   <function>ambulkdelete</function>,  ou NULL si
   <function>ambulkdelete</function> n'a pas été appelée car aucune ligne
   n'avait besoin d'être supprimée. Si le résultat n'est pas NULL, il s'agit
   d'une structure allouée par palloc. Les statistiques qu'elle contient
   seront utilisées pour mettre à jour <structname>pg_class</structname>,
   et sont rapportées par <command>VACUUM</command> si
   <literal>VERBOSE</literal> est indiqué. La fonction peut retourner NULL
   si l'index n'a pas été modifié lors de l'opération
   de <command>VACUUM</command> mais, dans le cas contraire, il faut retourner
   des statistiques correctes.
  </para>

  <para>
   À partir de <productname>PostgreSQL</productname> 8.4,
   <function>amvacuumcleanup</function> sera aussi appelé à la fin d'une
   opération <command>ANALYZE</command>. Dans ce cas,
   <literal>stats</literal> vaut toujours NULL et toute valeur de retour sera
   ignorée. Ce cas peut être repéré en vérifiant
   <literal>info-&gt;analyze_only</literal>. Il est recommandé que la méthode
   d'accès ne fasse rien en dehors du nettoyage après insertion pour ce type
   d'appel, et cela seulement au sein d'un processus autovacuum.
  </para>

  <para>
   <programlisting>
bool
amcanreturn (Relation indexRelation, int attno);
   </programlisting>
   Vérifie si l'index supporte les <link
   linkend="indexes-index-only-scans"><firstterm>parcours d'index
   seul</firstterm></link> sur la colonne indiquée, en renvoyant les valeurs
   des colonnes pour un enregistrement d'index sous forme d'un
   <structname>IndexTuple</structname>. Les numéros des attributs commencent
   à 1 (c'est-à-dire&nbsp;:: pour la première colonne, attno vaut 1).
   Renvoie true si c'est supporté, sinon false. Si la méthode d'accès ne
   supporte pas du tout les parcours d'index seul, le champ
   <structfield>amcanreturn</structfield> de la structure
   <structname>IndexAmRoutine</structname> peut être mis à NULL.
  </para>

  <para>
   <programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
   </programlisting>
   Estime les coûts d'un parcours d'index. Cette fonction est décrite
   complètement dans <xref linkend="index-cost-estimation"/> ci-dessous.
  </para>

  <para>
   <programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
   </programlisting>
   Analyse et valide le tableau reloptions d'un index. Cette fonction
   n'est appelée que lorsqu'il existe un tableau reloptions non NULL pour l'index.
   <parameter>reloptions</parameter> est un tableau
   avec des entrées de type <type>text</type> et de la forme
   <replaceable>nom</replaceable><literal>=</literal><replaceable>valeur</replaceable>.
   La fonction doit construire une valeur de type <type>bytea</type> à
   copier dans le <structfield>rd_options</structfield> de l'entrée relcache
   de l'index. Les données contenues dans le <type>bytea</type> sont
   définies par la méthode d'accès. La plupart des méthodes d'accès standard utilisent
   la structure <structname>StdRdOptions</structname>.
   Lorsque <parameter>validate</parameter> est true, la fonction doit remonter
   un message d'erreur clair si une des options n'est pas reconnue ou a des
   valeurs invalides&nbsp;; quand <parameter>validate</parameter> est false, les
   entrées invalides sont ignorées silencieusement.
   (<parameter>validate</parameter> est faux lors du chargement d'options déjà
   stockées dans <structname>pg_catalog</structname>&nbsp;; une entrée invalide
   ne peut se trouver que si la méthode d'accès a modifié ses règles pour
   les options et, dans ce cas, il faut ignorer les entrées obsolètes.)
   Pour obtenir le comportement par défaut, il suffit de retourner NULL.
  </para>

  <para>
<programlisting>
bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);
</programlisting>
   Permet aux méthodes d'accès de surcharger le comportement par défaut de
   <function>pg_index_column_has_property</function> et des fonctions
   liées. Si la méthode d'accès n'a pas de comportement spécial lors des
   demandes de propriétés d'index, le champ
   <structfield>amproperty</structfield> dans sa structure
   <structname>IndexAmRoutine</structname> peut être NULL. Dans le
   cas contraire, la méthode <function>amproperty</function> sera appelée avec
   <parameter>index_oid</parameter> et <parameter>attno</parameter> tous les
   deux à zéro pour les appels à <function>pg_indexam_has_property</function>,
   ou avec un <parameter>index_oid</parameter> valide et
   <parameter>attno</parameter> à zéro pour les appels à
   <function>pg_index_has_property</function>, ou avec un
   <parameter>index_oid</parameter> valide et un <parameter>attno</parameter>
   supérieur à zéro pour les appels à
   <function>pg_index_column_has_property</function>.
   <parameter>prop</parameter> est une valeur enum identifiant la propriété
   testée, alors que <parameter>propname</parameter> est le nom de la
   propriété originale. Si le code principal ne reconnaît pas le nom de la
   propriété, alors <parameter>prop</parameter> vaut
   <literal>AMPROP_UNKNOWN</literal>. Les méthodes d'accès peuvent définir les
   noms de propriétés personnalisées en cherchant une correspondance avec
   <parameter>propname</parameter> (utilisez
   <function>pg_strcasecmp</function> pour être cohérent
   avec le code principal)&nbsp;; pour les noms connus du code principal,
   il est préférable d'inspecter <parameter>prop</parameter>. Si
   la méthode <structfield>amproperty</structfield> renvoit
   <literal>true</literal>, alors elle a passé le test de
   propriété&nbsp;: elle doit renvoyer le booléen <literal>*res</literal>
   ou mettre <literal>*isnull</literal> à
   <literal>true</literal> pour renvoyer un NULL. (Les deux variables
   référencées sont initialisées à <literal>false</literal> avant l'appel.) Si
   la méthode <structfield>amproperty</structfield> renvoit
   <literal>false</literal>, alors le code principal continuera avec sa
   logique habituelle pour tester la propriété.
  </para>

  <para>
   Les méthodes d'accès supportant les opérateurs de tri devraient implémenter
   le test de <literal>AMPROP_DISTANCE_ORDERABLE</literal> car le
   code principal ne sait pas le faire et renverra NULL. Il pourrait aussi
   être avantageux d'implémenter un test sur
   <literal>AMPROP_RETURNABLE</literal> si cela peut être fait de façon plus
   simple que d'ouvrir l'index et d'appeler
   <structfield>amcanreturn</structfield>, comme le fait
   le code principal. Le comportement par défaut devrait être
   satisfaisant pour toutes les autres propriétés standard.
  </para>

  <para>
<programlisting>
bool
amvalidate (Oid opclassoid);
</programlisting>
   Valide les entrées du catalogue pour la classe d'opérateur indiquée, à
   condition que la méthode d'accès puisse le faire raisonnablement. Par
   exemple, ceci pourrait inclure le test de la présence de toutes les
   fonctions de support. La fonction
   <function>amvalidate</function> doit renvoyer false si la classe d'opérateur
   est invalide. Les problèmes devraient être rapportés avec les messages
   <function>ereport</function>.
  </para>


  <para>
   Le but d'un index est bien sûr de supporter les parcours de lignes
   qui correspondent à une condition <literal>WHERE</literal> indexable,
   souvent appelée <firstterm>qualificateur</firstterm>
   (<foreignphrase>qualifier</foreignphrase>) ou <firstterm>clé de
    parcours</firstterm> (<foreignphrase>scan key</foreignphrase>). La sémantique
   du parcours d'index est décrite plus complètement dans <xref linkend="index-scanning"/>,
   ci-dessous. Une méthode d'accès à l'index peut supporter les parcours d'accès
   standards (<quote>plain index scan</quote>),
   les parcours d'index <quote>bitmap</quote>
   ou les deux. Les fonctions liées au parcours qu'une méthode d'accès à
   l'index doit ou devrait fournir sont&nbsp;:
  </para>

  <para>
   <programlisting>IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
   </programlisting>
   Prépare un parcours d'index. Les paramètres <literal>nkeys</literal> et
   <literal>norderbys</literal> indiquent le nombre de qualificateurs et
   d'opérateurs de tri qui seront utilisés dans le parcours. Ils peuvent
   servir pour l'allocation d'espace. Notez que les valeurs réelles
   des clés de parcours ne sont pas encore fournies. Le résultat doit être
   une structure palloc. Pour des raisons
   d'implémentation, la méthode d'accès à l'index <emphasis>doit</emphasis>
   créer cette structure en appelant
   <function>RelationGetIndexScan()</function>. Dans la plupart des cas,
   <function>ambeginscan</function> ne fait pas grand-chose d'autre que cet appel et
   parfois l'acquisition de verrous&nbsp;; les parties intéressantes du début
   du parcours sont dans <function>amrescan</function>.
  </para>

  <para>
   <programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
   </programlisting>
   Démarre ou relance un parcours d'index, possiblement avec de nouvelles
   clés d'index. (Pour relancer en utilisant des clés déjà passées,
   passer NULL à <literal>keys</literal> et/ou <literal>orderbys</literal>.) Notez
   que le nombre de clés ou d'opérateurs de tri
   ne doit pas être plus grand que ce qui a été passé à la fonction
   <function>ambeginscan</function>. En pratique, le
   relancement est utilisé quand une nouvelle ligne externe est sélectionnée
   par une jointure de boucle imbriquée, donc avec une nouvelle valeur de
   comparaison, mais la structure de clé de parcours reste
   la même.
  </para>

  <para>
   <programlisting>boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
   </programlisting>
   Récupérer la prochaine ligne d'un parcours donné, dans la direction donnée
   (vers l'avant ou l'arrière de l'index). Renvoie true si une ligne a
   été obtenue, false s'il ne reste aucune ligne. Dans le cas
   true, le TID de la ligne est stocké dans la structure
   <literal>scan</literal>. <quote>success</quote> signifie juste que
   l'index contient une entrée qui correspond aux clés de parcours, pas que
   la ligne existe toujours dans la table ou qu'elle sera visible
   dans l'instantané (<foreignphrase>snapshot</foreignphrase>)
   de l'appelant. En cas de succès, <function>amgettuple</function>
   doit passer <literal>scan-&gt;xs_recheck</literal> à true ou false.
   True signifie que ce n'est pas certain et que les conditions
   représentées par les clés de parcours doivent être de nouveau vérifiées sur
   la ligne dans la table après récupération. Cette différence permet de
   supporter les opérateurs d'index <quote>à perte</quote>. Notez que cela
   ne s'appliquera qu'aux conditions de parcours&nbsp;; un prédicat
   partiel d'index n'est jamais revérifié par les appelants à
   <function>amgettuple</function>.
  </para>

  <para>
   Si l'index supporte les <link linkend="indexes-index-only-scans">parcours
   d'index seul</link> (c'est-à-dire que
   <function>amcanreturn</function> renvoit true), alors, en cas de succès,
   la méthode d'accès doit aussi vérifier
   <literal>scan-&gt;xs_want_itup</literal>, et si ce dernier est true, elle
   doit renvoyer les données indexées originales de cette entrée d'index. Les
   données peuvent être retournées sous la forme d'un pointeur
   d'<structname>IndexTuple</structname> stocké dans
   <literal>scan-&gt;xs_itup</literal>, avec un descripteur de lignes dans
   <literal>scan-&gt;xs_itupdesc</literal>; ou sous la forme d'un pointeur
   <structname>HeapTuple</structname> stocké dans
   <literal>scan-&gt;xs_hitup</literal>,
   avec le descripteur de ligne <literal>scan-&gt;xs_hitupdesc</literal>.  (Le
   second format devrait être utilié lors de la reconstruction des données qui
   pourraient ne pas tenir dans un <structname>IndexTuple</structname>.)  Dans
   tous les cas, la gestion
   de la donnée référencée par le pointeur est de la responsabilité de la
   méthode d'accès. Les données doivent rester bonnes au moins jusqu'au
   prochain appel à <function>amgettuple</function>,
   <function>amrescan</function> ou <function>amendscan</function> pour le
   parcours.
  </para>

  <para>
   La fonction <function>amgettuple</function> a seulement besoin d'exister
   si la méthode d'accès supporte les parcours d'index standards. Si ce n'est
   pas le cas, le champ <structfield>amgettuple</structfield> de la structure
   <structname>IndexAmRoutine</structname> doit être NULL.
  </para>

  <para>
   <programlisting>
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
   </programlisting>
   Récupère toutes les lignes du parcours sélectionné et les ajoute au
   <type>TIDBitmap</type> fourni par l'appelant (c'est-à-dire un OU de l'ensemble des
   identifiants de ligne dans l'ensemble où se trouve déjà le bitmap). Le
   nombre de lignes récupérées est renvoyé (cela peut n'être qu'une estimation
   car certaines méthodes d'accès ne détectent pas les duplicats). Lors de
   l'insertion d'identifiants de ligne dans le bitmap, <function>amgetbitmap</function>
   peut indiquer que la vérification des conditions du parcours est requis pour
   des identifiants précis de transactions. C'est identique au paramètre de sortie
   <literal>xs_recheck</literal> de <function>amgettuple</function>. Note&nbsp;:
   dans l'implémentation actuelle, le support de cette fonctionnalité
   est fusionné avec le support du stockage à perte du bitmap lui-même, et du coup
   les appelants revérifient à la fois les conditions du parcours et le prédicat de l'index
   partiel (si c'en est un) pour les lignes à revérifier. Cela ne
   sera pas forcément toujours vrai. <function>amgetbitmap</function> et
   <function>amgettuple</function> ne peuvent pas être utilisés dans le même
   parcours d'index&nbsp;; il existe d'autres restrictions lors de l'utilisation
   de <function>amgetbitmap</function>, comme expliqué dans <xref
   linkend="index-scanning"/>.
  </para>


  <para>
   En plus de supporter des parcours d'index ordinaires, certains types d'index
   peuvent souhaiter supporter des <firstterm>parcours d'index
   parallèle</firstterm>, qui permettent à de multiples processus clients de
   coopérer afin de réaliser un parcours d'index.  La méthode d'accès à l'index
   devrait s'arranger pour que chaque processus participant au parcours
   retourne un sous-ensemble des lignes qui devraient être traitées par un
   parcours d'index ordinaire, non parallèle, mais de telle façon que l'union
   de tous ces sous ensembles soit identique aux ensemble de lignes qui
   seraient retournés par un parcours d'index ordinaire, non parallèle.  En
   outre, bien qu'il n'y ait pas besoin d'un ordre de tri global des lignes
   retournée par un parcours parallèle, l'ordre du sous ensemble de lignes
   retourné par chaque processus participant au parcours d'index doit
   correspondre à l'ordre demandé.  Les fonctions suivantes peuvent être
   implémentée pour supporter les parcours d'index parallèles :
  </para>

  <para>
<programlisting>
Size
amestimateparallelscan (void);
</programlisting>
   Estime et retourne le nombre d'octets de mémoire partagée dynamique dont la
   méthode d'accès aura besoin pour effectuer le parcours d'index.  (Ce chiffre
   est en plus, et non à la place, de la quantité d'espace nécessaier pour les
   données indépendantes de l'AM dans
   <structname>ParallelIndexScanDescData</structname>.)
  </para>

  <para>
   Il n'est pas nécessaire d'implémenter cette fonction pour les méthodes
   d'accès qui ne supportent pas les parcours d'index parallèles, où pour lesquelles le nombre d'octets de stockage additionnels vaut zéro.
  </para>

  <para>
<programlisting>
void
aminitparallelscan (void *target);
</programlisting>
   Cette fonction sera appelée pour initialiser la mémoire partagée dynamique
   au début du parcours parallèle. <parameter>target</parameter> pointera vers
   au moins le nombre d'octets précédemment retourné par
   <function>amestimateparallelscan</function>, et cette fonction pourra
   utiliser cette quantité d'espace pour stocker n'importe quelle donnée dont
   elle a besoin.
  </para>

  <para>
   Il n'est pas nécessaire d'implémenter cette fonction pour les méthodes
   d'accès qui ne spportent pas les parcours d'index parallèles ou dans le cas
   où l'espace de mémoire partagé requis ne nécessite pas d'initialisation.
  </para>

  <para>
<programlisting>
void
amparallelrescan (IndexScanDesc scan);
</programlisting>
   Si implémentée, cette fonction sera appelée lorsqu'un parcours d'index
   parallèle doit recommencer.  Elle devrait réinitialiser tout état partagé
   mis en place par <function>aminitparallelscan</function> de telle manière à
   ce que le parcours sera recommencé depuis le début.
  </para>

  <para>
   La fonction <function>amgetbitmap</function> ne doit exister que si la
   méthode d'accès supporte les parcours d'index <quote>bitmap</quote>. Dans le
   cas contraire, le champ <structfield>amgetbitmap</structfield> de la structure
   <structname>IndexAmRoutine</structname> doit être NULL.
  </para>

  <para>
   <programlisting>void
amendscan (IndexScanDesc scan);
   </programlisting>
   Terminer un parcours et libérer les ressources. La structure <literal>scan</literal>
   elle-même ne doit pas être libérée, mais tout verrou posé en interne par
   la méthode d'accès doit être libéré, ainsi qu'à tout autre mémoire allouée
   par <function>ambeginscan</function> et les autres fonctions relatives aux
   parcours.
  </para>

  <para>
   <programlisting>void
ammarkpos (IndexScanDesc scan);
   </programlisting>
   Marquer la position courante du parcours. La méthode d'accès n'a besoin de mémoriser
   qu'une seule position par parcours.
  </para>

  <para>
   La fonction <function>ammarkpos</function> n'a besoin d'être fournie que
   si la méthode supporte les parcours ordonnés. Dans le cas contraire, le champ
   <structfield>ammarkpos</structfield> dans sa structure
   <structname>IndexAmRoutine</structname> peut être NULL.
  </para>

  <para>
   <programlisting>void
amrestrpos (IndexScanDesc scan);
   </programlisting>
   Restaurer le parcours à sa plus récente position marquée.
  </para>

 </sect1>

 <sect1 id="index-scanning">
  <title>Parcours d'index</title>

  <para>
   Dans un parcours d'index, la responsabilité de la méthode d'accès
   est de recracher tous les TID de toutes les lignes qu'on lui a dit correspondre
   aux <firstterm>clés de parcours</firstterm>. La méthode d'accès n'est
   impliquée <emphasis>ni</emphasis> dans la récupération de ces lignes dans la
   table parente de l'index, <emphasis>ni</emphasis> dans les tests de
   qualification temporelle ou autre.
  </para>

  <para>
   Une clé de parcours est une représentation interne d'une clause
   <literal>WHERE</literal> de la forme <replaceable>clé_index</replaceable>
   <replaceable>opérateur</replaceable> <replaceable>constante</replaceable>,
   où la clé est une des colonnes de l'index et l'opérateur un des
   membres de la famille d'opérateurs associée à cette colonne. Un
   parcours d'index a entre zéro et plusieurs clés de parcours assemblées
   implicitement avec des AND &mdash; les lignes renvoyées doivent satisfaire
   toutes les conditions indiquées.
  </para>

  <para>
   La méthode d'accès peut indiquer que l'index est <firstterm>à
    perte</firstterm> ou nécessite une vérification pour une requête
   particulière&nbsp;; ceci implique que le parcours d'index renvoie toutes les
   entrées qui correspondent à la clé de parcours, plus éventuellement des
   entrées supplémentaires qui ne correspondent pas. La machinerie du parcours
   d'index du système principal applique alors les conditions de l'index à
   la ligne pour vérifier si elle doit effectivement être retenue. Si l'option
   de vérification n'est pas indiquée, le parcours d'index doit renvoyer
   exactement l'ensemble d'entrées correspondantes.
  </para>

  <para>
   La méthode d'accès doit s'assurer
   qu'elle trouve correctement toutes les entrées correspondantes aux clés de
   parcours données, et seulement celles-ci. De plus, le système principal
   se contente de transférer toutes les clauses <literal>WHERE</literal>
   qui correspondent aux clés d'index
   et aux familles d'opérateurs, sans analyse sémantique permettant de
   déterminer si elles sont redondantes ou contradictoires. Par exemple, avec
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal>, où <literal>x</literal>
   est une colonne
   indexée par B-tree, c'est à la fonction B-tree <function>amrescan</function>
   de déterminer que la première clé de parcours est redondante et peut être
   annulée. Le supplément de pré-traitement nécessaire lors de
   <function>amrescan</function> dépend du niveau de réduction des clés de
   parcours en une forme <quote>normalisée</quote> nécessaire à la
   méthode d'accès à l'index.
  </para>

  <para>
   Certaines méthodes d'accès renvoient des entrées d'index dans un ordre bien
   défini, d'autres non. Il existe en fait deux façons différentes permettant
   à une méthode d'accès de fournir une sortie triée&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      Les méthodes d'accès qui renvoient toujours les entrées dans l'ordre
      naturel des données (comme les B-tree) doivent configurer
      <structfield>amcanorder</structfield> à
      true. Actuellement, ces méthodes d'accès doivent utiliser des nombres
      de stratégie compatibles avec les B-tree pour les opérateurs d'égalité
      et de tri.
     </para>
    </listitem>
    <listitem>
     <para>
      Les méthodes d'accès qui supportent les opérateurs de tri doivent
      configurer <structfield>amcanorderbyop</structfield>
      à true. Ceci indique que l'index est capable de renvoyer les entrées
      dans un ordre satisfaisant <literal>ORDER BY</literal>
      <replaceable>clé_index</replaceable> <replaceable>opérateur</replaceable>
      <replaceable>constante</replaceable>. Les modificateurs de parcours de
      cette forme peuvent être passés à <function>amrescan</function> comme
      décrit précédemment.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   La fonction <function>amgettuple</function> dispose d'un argument
   <literal>direction</literal>,
   qui peut être soit <literal>ForwardScanDirection</literal> (le cas normal), soit
   <literal>BackwardScanDirection</literal>. Si le premier appel après
   <function>amrescan</function> précise <literal>BackwardScanDirection</literal>, alors
   l'ensemble des entrées d'index correspondantes est à parcourir de l'arrière
   vers l'avant plutôt que dans la direction normale (d'avant en arrière).
   <function>amgettuple</function> doit donc renvoyer la dernière ligne correspondante dans
   l'index, plutôt que la première, comme cela se fait normalement. (Cela ne
   survient que pour les méthodes
   d'accès qui initialise <structfield>amcanorder</structfield> à true.) Après
   le premier appel, <function>amgettuple</function>
   doit être préparé pour continuer le parcours dans la direction adaptée à partir de
   l'entrée la plus récemment renvoyée. (Mais si
   <structfield>amcanbackward</structfield> vaut
   false, tous les appels suivants auront la même direction que le premier.)
  </para>

  <para>
   Les méthodes d'accès qui supportent les parcours ordonnés doivent supporter
   le <quote>marquage</quote> d'une position dans un parcours pour retourner
   plus tard à la position marquée. La même position peut être restaurée
   plusieurs fois. Néanmoins, seule une position par parcours a besoin d'être
   conservée en mémoire&nbsp;; un nouvel appel à <function>ammarkpos</function>
   surcharge la position anciennement marquée. Une méthode d'accès qui ne
   supporte pas les parcours ordonnés n'a pas besoin de fournir les fonctions
   <function>ammarkpos</function> et <function>amrestrpos</function> dans sa
   structure <structname>IndexAmRoutine</structname>&nbsp;; configurez ces
   pointeurs à NULL dans ce cas.
  </para>

  <para>
   Les positions du parcours et du marquage doivent être conservées de façon
   cohérente dans le cas d'insertions et de suppressions concurrentes dans
   l'index. Il est acceptable qu'une entrée tout juste insérée ne soit
   pas retournée par un parcours qui l'aurait trouvée
   si l'entrée avait existé au démarrage du
   parcours. De même est-il correct qu'un parcours
   retourne une telle entrée lors d'un re-parcours ou d'un retour arrière,
   alors même qu'il ne l'a pas retournée lors du parcours initial.
   De même, une suppression concurrente peut être, ou non, visible dans
   les résultats d'un parcours. Il est primordial qu'insertions et suppressions
   ne conduisent pas le parcours à oublier ou dupliquer des entrées qui ne sont
   pas insérées ou supprimées.
  </para>

  <para>
   Si l'index stocke les valeurs originales des données indexées (et pas une
   représentation à perte), il est utile de supporter les <link
   linkend="indexes-index-only-scans">parcours d'index seul</link>, pour
   lesquels l'index renvoie la donnée réelle et non pas
   juste le TID de la ligne dans la table. Ceci n'évitera des I/O que
   si la carte de visibilité montre que le TID est sur une page dont toutes
   les lignes sont visibles par toutes les transactions en cours. Sinon, la
   ligne de la table doit être visitée de toute façon pour s'assurer de
   sa visibilité pour la transaction en cours. Mais cela ne concerne pas la
   méthode d'accès.
  </para>

  <para>
   Un parcours d'index peut utiliser <function>amgetbitmap</function> à la place de
   <function>amgettuple</function> pour
   récupérer toutes les lignes en un unique appel. Cette méthode peut s'avérer
   nettement plus efficace que <function>amgettuple</function> parce qu'elle
   permet d'éviter les cycles de verrouillage/déverrouillage à l'intérieur de la
   méthode d'accès. En principe, <function>amgetbitmap</function> a les mêmes
   effets que des appels répétés à <function>amgettuple</function>, mais
   plusieurs restrictions ont été imposées pour simplifier la procédure. En
   premier lieu, <function>amgetbitmap</function> renvoie toutes les lignes
   en une fois et le marquage ou la restauration des positions de parcours n'est
   pas supporté. Ensuite, les lignes sont renvoyées dans un bitmap qui n'a pas
   d'ordre spécifique, ce qui explique pourquoi <function>amgetbitmap</function>
   ne prend pas de <literal>direction</literal> en argument. (Les opérateurs
   de tri ne seront jamais fournis non plus pour un tel parcours.)
   De plus, il n'existe aucune disposition pour les parcours d'index seul avec
   <function>amgetbitmap</function> car il n'y a aucun moyen de renvoyer le
   contenu des lignes d'index.
   Enfin, <function>amgetbitmap</function> ne garantit pas le verrouillage
   des lignes renvoyées, avec les implications précisées dans <xref
   linkend="index-locking"/>.
  </para>

  <para>
   Notez qu'il est permis à une méthode d'accès d'implémenter seulement
   <function>amgetbitmap</function> et pas <function>amgettuple</function>, ou
   vice versa, si son fonctionnement interne ne convient qu'à une seule des API.
  </para>

 </sect1>

 <sect1 id="index-locking">
  <title>Considérations sur le verrouillage d'index</title>

  <para>
   Les méthodes d'accès aux index doivent gérer des mises à jour
   concurrentes de l'index par plusieurs processus.
   Le système principal de <productname>PostgreSQL</productname> obtient
   <literal>AccessShareLock</literal> sur l'index lors d'un parcours d'index et
   <literal>RowExclusiveLock</literal> lors de sa mise à jour (ce qui inclut le
   <command>VACUUM</command> simple). Comme ces types de
   verrous ne sont pas conflictuels, la méthode d'accès est responsable de la
   finesse du verrouillage dont elle a besoin. Un verrou exclusif sur
   l'intégralité de l'index entier n'est posé qu'à la création de l'index, sa destruction
   ou lors d'un <literal>REINDEX</literal>.
  </para>

  <para>
   Construire un type d'index qui supporte les mises à jour concurrentes
   requiert une analyse complète et subtile. Pour les
   types d'index B-tree et hash, on peut lire les implications sur les décisions
   de conception dans
   <filename>src/backend/access/nbtree/README</filename> et
   <filename>src/backend/access/hash/README</filename>.
  </para>

  <para>
   En plus des besoins de cohérence interne de l'index, les mises à jour
   concurrentes créent des problèmes de cohérence entre la table parente
   (<foreignphrase>heap</foreignphrase>)
   et l'index. Comme <productname>PostgreSQL</productname> sépare les accès
   et les mises à
   jour de la table et ceux de l'index, il existe des fenêtres temporelles
   pendant lesquelles l'index et l'en-tête peuvent être incohérents. Ce problème
   est géré avec les règles suivantes&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      une nouvelle entrée dans la table est effectuée avant son entrée
      dans l'index. (Un parcours d'index concurrent peut alors ne pas
      voir l'entrée dans la table. Ce n'est pas gênant dans la mesure où un
      lecteur de l'index ne s'intéresse pas à une ligne non validée. Voir
      <xref linkend="index-unique-checks"/>)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      lorsqu'une entrée de la table va être supprimée (par <command>VACUUM</command>),
      on doit d'abord supprimer toutes les entrées d'index&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      un parcours d'index doit maintenir
      un lien sur la page d'index contenant le dernier élément renvoyé par
      <function>amgettuple</function>, et <function>ambulkdelete</function> ne peut
      supprimer des entrées de pages liées à d'autres processus. La
      raison figure ci-dessous.
     </para>
    </listitem>
   </itemizedlist>

   Sans la troisième règle, il serait possible qu'un lecteur d'index voit
   une entrée dans l'index juste avant qu'elle ne soit supprimée par un
   <command>VACUUM</command> et arrive à l'entrée correspondante de
   la table après sa suppression par le <command>VACUUM</command>.
   Cela ne pose aucun problème sérieux si cet élément
   est toujours inutilisé quand le lecteur l'atteint, car tout emplacement
   vide est ignoré par <function>heap_fetch()</function>. Mais que se passe-t-il si
   un troisième moteur a déjà ré-utilisé l'emplacement de l'élément pour quelque
   chose d'autre&nbsp;? Lors de l'utilisation d'un instantané (<foreignphrase>snapshot</foreignphrase>) compatible MVCC, il n'y
   a pas de problème car le nouvel occupant de l'emplacement est certain d'être
   trop récent pour apparaître dans l'instantané.
   En revanche, avec un
   instantané non-compatible MVCC (tel que <literal>SnapshotAny</literal>), une
   ligne qui ne correspond pas aux clés de parcours peut être acceptée ou
   retournée. Ce scénario peut être évité en imposant que les clés de parcours
   soient re-confrontées à la table dans tous les cas, mais cela est
   trop coûteux. À la place, un lien sur une page d'index est utilisé comme
   <foreignphrase>proxy</foreignphrase> pour indiquer que le
   lecteur peut être <quote>en route</quote> depuis l'entrée
   d'index vers l'entrée de table correspondante. Bloquer <function>ambulkdelete</function>
   sur un tel lien assure que <command>VACUUM</command> ne peut pas supprimer
   l'entrée de la table avant que le lecteur n'en ait terminé avec elle. Cette
   solution est peu coûteuse en temps d'exécution, et n'ajoute de surcharge du
   fait du blocage que dans les rares cas où il y a vraiment un conflit.
  </para>

  <para>
   Cette solution requiert que les parcours d'index soient
   <quote>synchrones</quote>&nbsp;: chaque ligne de la table doit être récupérée
   immédiatement après récupération de l'entrée d'index correspondante.
   Cela est coûteux pour plusieurs raisons. Un parcours <quote>asynchrone</quote>,
   où l'on récupère de nombreux TID depuis l'index et où l'on ne visite la table
   que plus tard, requiert moins de
   surcharge de verrouillage de l'index et autorise un modèle d'accès à
   la table plus efficace. D'après l'analyse ci-dessus,
   l'approche synchrone doit être utilisée pour les instantanés non compatibles avec
   MVCC, mais un parcours asynchrone est possible pour une requête utilisant
   un instantané MVCC.
  </para>

  <para>
   Dans un parcours d'index <function>amgetbitmap</function>, la méthode d'accès
   ne bloque l'index pour aucune des lignes
   renvoyées. C'est pourquoi de tels parcours ne sont fiables
   qu'avec les instantanés compatibles MVCC.
  </para>

  <para>
   Quand le drapeau <structfield>ampredlocks</structfield> n'est pas en place,
   tout parcours par cette méthode d'accès au sein d'une transaction
   sérialisable acquerra un verrou prédicat non bloquant sur l'index
   complet. Ceci génèrera un conflit de lecture/écriture à l'insertion d'une
   ligne dans cet index par une transaction sérialisable concurrente. Si
   certains motifs de tels conflits sont détectés dans un
   ensemble de transactions sérialisables concurrentes, une de ces transactions
   peut être annulée pour protéger l'intégrité des données. Quand le
   drapeau est en place, il indique que la méthode d'accès
   implémente un verrou prédicat plus fin, qui tend à réduire la fréquence
   d'annulation de telles requêtes.
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>Vérification de l'unicité par les index</title>

  <!-- SAS :: L'index n'est pas unique, il garantit l'unicité -->
  <para>
   <productname>PostgreSQL</productname> assure les contraintes d'unicité SQL
   par des <firstterm>index uniques</firstterm>, qui sont des index qui
   refusent des entrées multiples pour un même clé. Une méthode d'accès qui
   supporte cette fonctionnalité initialise
   <structfield>amcanunique</structfield> à true. (À ce jour, seul B-tree le
   supporte). Les colonnes listées dans la clause <literal>INCLUDE</literal>
   ne sont pas considérées lors de la vérification d'unicité.
  </para>

  <para>
   Du fait de MVCC, il est toujours nécessaire de permettre à des entrées dupliquées
   d'exister physiquement dans un index&nbsp;: elles peuvent faire
   référence à des versions successives d'une même ligne logique.
   Nous voulons garantir qu'aucune image MVCC n'inclut deux
   lignes avec les mêmes clés d'index. Cela se résume aux cas suivants,
   à vérifier à l'insertion d'une nouvelle ligne dans un index
   d'unicité&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      si une ligne valide conflictuelle a été supprimée par la transaction
      courante, pas de problème. (En particulier, comme un UPDATE supprime
      toujours l'ancienne version de la ligne avant d'insérer la nouvelle
      version, cela permet un UPDATE sur une ligne sans changer la clé)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      si une ligne conflictuelle a été insérée par une transaction non encore
      validée, l'inséreur potentiel doit attendre de voir si la transaction
      est validée. Si elle est annulée, alors il n'y a pas de conflit.
      Si elle est validée sans avoir supprimé la ligne conflictuelle,
      il y a violation de la contrainte d'unicité. (En pratique,
      on attend que l'autre transaction finisse et le contrôle de visibilité
      est effectué à nouveau dans son intégralité)&nbsp;;
     </para>
    </listitem>
    <listitem>
     <para>
      de façon similaire, si une ligne conflictuelle validée est supprimée par
      une transaction encore non validée, l'inséreur potentiel doit attendre la
      validation ou l'annulation de cette transaction et recommencer le test.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   De plus, immédiatement avant de lever une violation d'unicité
   en fonction des règles ci-dessus, la méthode d'accès doit
   revérifier l'état de la ligne en cours d'insertion. Si elle
   est validée mais est déjà morte, alors aucune erreur ne
   survient. (Ce cas ne peut pas survenir lors du scénario ordinaire
   d'insertion d'une ligne tout juste créée par la
   transaction en cours. Cela peut néanmoins arriver lors d'un
   <command>CREATE UNIQUE INDEX CONCURRENTLY</command>.)
  </para>

  <para>
   La méthode d'accès à l'index doit appliquer elle-même ces tests,
   ce qui signifie qu'elle doit accéder à la table pour vérifier le
   statut de validation de toute ligne présentant une clé dupliquée
   au regard du contenu de l'index. C'est sans doute moche et non
   modulaire, mais cela permet d'éviter un travail redondant&nbsp;: si un test
   séparé était effectué, alors la recherche d'une ligne conflictuelle dans
   l'index serait en grande partie répétée lors de la recherche d'une place pour
   la nouvelle entrée d'index. Qui plus, est, il n'y a pas
   de façon évidente d'éviter des <foreignphrase>race conditions</foreignphrase>,
   sauf si la recherche de conflit
   est partie intégrante de l'insertion d'une nouvelle entrée d'index.
  </para>

  <para>
   Si la contrainte unique est déferrable, il y a une complication
   supplémentaire&nbsp;: nous devons être capable d'insérer une entrée d'index
   pour une nouvelle ligne mais devons déferrer toute erreur de violation de
   l'unicité jusqu'à la fin de l'instruction, voire après. Pour éviter
   des recherches répétées et inutiles dans l'index, la méthode d'accès
   doit faire une vérification préliminaire d'unicité dès
   l'insertion initiale. Si elle ne montre pas de conflit avec une
   ligne visible, nous avons terminé. Sinon, nous devons planifier une
   nouvelle vérification quand il sera temps de forcer la contrainte. Si,
   lors de la nouvelle vérification, la ligne insérée et d'autres lignes de
   la même clé sont vivantes, alors l'erreur doit être rapportée. (Notez que,
   dans ce contexte, <quote>vivant</quote> signifie réellement <quote>toute
   ligne dans la chaîne HOT de l'entrée d'index est vivante</quote>.)
   Pour implanter ceci, la fonction <function>aminsert</function> reçoit un
   paramètre <literal>checkUnique</literal> qui peut avoir une des valeurs
   suivantes&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      <literal>UNIQUE_CHECK_NO</literal> indique qu'aucun test d'unicité
      ne doit être fait (ce n'est pas un index unique).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>UNIQUE_CHECK_YES</literal> indique qu'il s'agit d'un index
      unique non déferrable et la vérification de l'unicité doit se faire
      immédiatement, comme décrit ci-dessus.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>UNIQUE_CHECK_PARTIAL</literal> indique que la contrainte
      unique est déferrable. <productname>PostgreSQL</productname> utilisera
      ce mode pour insérer l'entrée d'index de chaque ligne. La méthode
      d'accès doit autoriser les entrées dupliquées dans l'index et rapporter
      tout dupliquat potentiel en renvoyant FALSE à partir de
      <function>aminsert</function>. Pour chaque ligne pour laquelle FALSE
      est renvoyé, une revérification déferrée sera planifiée.
     </para>

     <para>
      La méthode d'accès doit identifier toute ligne qui pourrait violer la
      contrainte unique, mais rapporter des faux positifs n'est pas une
      erreur. Cela permet de faire la vérification sans attendre la fin des
      autres transactions&nbsp;; les conflits rapportés ici ne sont pas
      traités comme des erreurs, et seront revérifiés plus tard, à un moment
      où ils ne seront peut-être plus en conflit.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>UNIQUE_CHECK_EXISTING</literal> indique qu'une
      revérification déferrée d'une ligne a été rapportée en
      violation potentielle d'unicité. Bien que cela soit implémenté par un
      appel à <function>aminsert</function>, la méthode d'accès ne doit
      <emphasis>pas</emphasis> insérer une nouvelle entrée d'index dans ce
      cas. L'entrée d'index est déjà présente. À la place, la méthode d'accès
      doit vérifier s'il existe une autre entrée d'index vivante. Si c'est le
      cas et que la ligne cible est toujours vivante, elle doit rapporter
      l'erreur.
     </para>

     <para>
      Il est recommendé que, dans un appel à
      <literal>UNIQUE_CHECK_EXISTING</literal>, la méthode d'accès vérifie en
      plus que la ligne cible ait réellement une entrée existante dans l'index
      et de lever une erreur si ce n'est pas le cas. C'est une bonne idée
      car les valeurs de la ligne d'index passées à
      <function>aminsert</function> auront été recalculées. Si la définition
      de l'index implique des fonctions qui ne sont pas vraiment immutables,
      nous pourrions être en train de vérifier une mauvaise partie de l'index. Vérifier que la
      ligne cible est trouvée dans la revérification permet de s'assurer que
      nous recherchons les mêmes valeurs de la ligne comme elles ont été
      utilisées lors de l'insertion originale.
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>Fonctions d'estimation des coûts d'index</title>

  <para>
   La fonction <function>amcostestimate</function> reçoit des
   informations décrivant un parcours d'index possible, incluant des listes
   de clauses WHERE et ORDER BY considérées comme utilisables
   avec l'index. Elle doit renvoyer une
   estimation du coût de l'accès à l'index et de la sélectivité des clauses
   WHERE (c'est-à-dire la fraction des lignes de la table parente qui seront
   récupérées lors du parcours de l'index). Dans les cas simples, pratiquement
   tout le travail de l'estimateur de coût peut être effectué en appelant des
   routines standard dans l'optimiseur&nbsp;; la justification d'une fonction
   <function>amcostestimate</function> est de permettre aux méthodes d'accès de fournir
   des connaissances spécifiques liées au type d'index, au cas où il serait possible
   d'améliorer les estimations standards.
  </para>

  <para>
   Chaque fonction <function>amcostestimate</function> doit avoir la signature&nbsp;:

   <programlisting>void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
   </programlisting>

   Les trois premiers paramètres sont des entrées&nbsp;:

   <variablelist>
    <varlistentry>
     <term><parameter>root</parameter></term>
     <listitem>
      <para>
       Information du planificateur sur la requête en cours de traitement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>
       Le chemin d'accès considéré pour l'index. Tous les champs, en dehors
       du coût et de la sélectivité, sont valides.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</parameter></term>
     <listitem>
      <para>
       Le nombre de répétitions du parcours d'index à
       prendre en compte dans les estimations de coût. Il sera généralement
       supérieur à 1 lors d'un parcours avec paramètres à utiliser à
       l'intérieur d'une jointure de boucle imbriquée. Notez que l'estimation
       de coût doit toujours être pour un seul parcours&nbsp;; une valeur plus
       importante de <parameter>loop_count</parameter> signifie qu'on pourrait
       constater l'effet du cache avec plusieurs parcours.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les cinq derniers paramètres sont les sorties, passées par référence&nbsp;:

   <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</parameter></term>
     <listitem>
      <para>
       Renvoie le coût du lancement du traitement de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</parameter></term>
     <listitem>
      <para>
       Renvoie le coût du traitement total de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</parameter></term>
     <listitem>
      <para>
       Renvoie la sélectivité de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</parameter></term>
     <listitem>
      <para>
       Renvoie le coefficient de corrélation entre l'ordre de parcours de
       l'index et l'ordre sous-jacent de la table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexPages</parameter></term>
     <listitem>
      <para>
       Configuré au nombre de pages feuilles de l'index.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les fonctions d'estimation de coûts doivent être écrites en C, pas
   en SQL ou dans tout autre langage procédural, parce qu'elles doivent accéder
   aux structures de données internes du planificateur/optimiseur.
  </para>

  <para>
   Les coûts d'accès aux index doivent être calculés avec les paramètres
   utilisés par <filename>src/backend/optimizer/path/costsize.c</filename>&nbsp;: la
   récupération d'un bloc disque séquentiel a un coût de <varname>seq_page_cost</varname>,
   une récupération non séquentielle a un coût de <varname>random_page_cost</varname>, et le coût de
   traitement d'une ligne d'index doit habituellement être considéré comme
   <varname>cpu_index_tuple_cost</varname>. De plus, un multiple approprié de
   <varname>cpu_operator_cost</varname> doit être ajouté pour tous les opérateurs
   de comparaison impliqués lors du traitement de l'index (spécialement
   l'évaluation des <literal>indexQuals</literal>).
  </para>

  <para>
   Les coûts d'accès doivent inclure tous les coûts dus aux disques et aux CPU
   associés au parcours d'index proprement dit, mais <emphasis>pas</emphasis> les coûts de
   récupération ou de traitement des lignes de la table parente
   identifiées par l'index.
  </para>

  <para>
   Le <quote>coût de lancement</quote> est la partie du coût total de parcours
   à dépenser avant de commencer à récupérer la première ligne.
   Pour la plupart des index, on peut prendre zéro, mais un type
   d'index avec un grand coût au démarrage peut nécessiter une valeur supérieure à zéro.
  </para>

  <para>
   <parameter>indexSelectivity</parameter> doit être la fraction estimée des lignes
   de la table parente qui sera récupérée lors du parcours d'index. Dans le cas
   d'une requête à perte, ce sera typiquement plus élevé que la
   fraction des lignes qui satisfont les conditions de qualification données.
  </para>

  <para>
   <parameter>indexCorrelation</parameter> doit être initialisé à la corrélation (valeur entre
   -1.0 et 1.0) entre l'ordre de l'index et celui de la table. Cela permet
   d'ajuster l'estimation du coût de récupération des lignes de la table
   parente.
  </para>

  <para>
   <parameter>indexPages</parameter> doit être configuré au nombre de pages
   feuilles. Ceci est utilisé pour estimer le nombre de workers pour les
   parcours d'index parallélisés.
  </para>

  <para>
   Quand <parameter>loop_count</parameter> est supérieur à 1, les nombres
   renvoyés doivent être des moyennes attendues pour tout parcours de l'index.
  </para>

  <procedure>
   <title>Estimation du coût</title>
   <para>
    Un estimateur typique de coût exécute le traitement ainsi&nbsp;:
   </para>

   <step>
    <para>
     Estime et renvoie la fraction des lignes de la table parente
     visitées d'après les conditions de qualification données. En l'absence de toute
     connaissance spécifique sur le type d'index, on utilise la fonction standard
     de l'optimiseur <function>clauselist_selectivity()</function>&nbsp;:

     <programlisting>+*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);
     </programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de lignes d'index visitées lors du parcours. Pour
     de nombreux types d'index, il s'agit de
     <parameter>indexSelectivity</parameter> multiplié par le nombre de
     lignes dans l'index, mais cela peut valoir plus (la taille
     de l'index en pages et lignes est disponible à partir de la structure
     <literal>path-&gt;indexinfo</literal>).
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de pages d'index récupérées pendant le parcours.
     Ceci peut être simplement <parameter>indexSelectivity</parameter>
     multiplié par la taille en pages de l'index.
    </para>
   </step>

   <step>
    <para>
     Calcule le coût d'accès à l'index. Un estimateur générique peut le
     faire ainsi&nbsp;:

     <programlisting>    /*
     * On suppose généralement que les pages d'index sont lues
     * séquentiellement, elles coûtent donc seq_page_cost each, et pas random_page_cost.
     * Nous ajoutons l'évaluation des qualificateurs pour chaque ligne d'index.
     * Tous les coûts sont supposés être payés de manière incrémentale pendant le parcours.
     */
    cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
    *indexStartupCost = index_qual_cost.startup;
    *indexTotalCost = seq_page_cost * numIndexPages +
        (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
     </programlisting>

     Néanmoins, le calcul ci-dessus ne prend pas en compte l'amortissement des
     lectures des index à travers des parcours répétés.
    </para>
   </step>

   <step>
    <para>
     Estime la corrélation de l'index. Pour un index ordonné sur un seul champ,
     cela peut se trouver dans pg_statistic. Si la corrélation est inconnue,
     l'estimation conservatrice est zéro (pas de corrélation).
    </para>
   </step>
  </procedure>

  <para>
   Des exemples de fonctions d'estimation du coût sont disponibles dans
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>
 </sect1>
</chapter>
