<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="indexam">
 <title>Définition de l'interface des méthodes d'accès aux index</title>

  <para>
   Ce chapitre définit l'interface entre le système
   <productname>PostgreSQL</productname> et les <firstterm>méthodes d'accès
   aux index</firstterm>, qui gérent les types d'index individuels. Le système principal
   ne sait rien des index en dehors de ce qui est spécifié ici. Il est donc
   possible de développer de nouveaux types d'index en écrivant du code
   supplémentaire.
  </para>

  <para>
   Tous les index de <productname>PostgreSQL</productname> sont connus
   techniquement en tant qu'<firstterm>index secondaires</firstterm>&nbsp;; c'est-à-dire
   que l'index est séparé physiquement du fichier de table qu'il décrit. Chaque index
   est stocké dans sa propre <firstterm>relation</firstterm> physique et donc décrit
   par une entrée dans le catalogue <structname>pg_class</structname>. Le contenu d'un
   index est entièrement contrôlé par la méthode d'accès à l'index. En
   pratique, toutes les méthodes d'accès aux index les divisent en pages de
   taille standard de façon à utiliser le gestionnaire de stockage
   et le gestionnaire de tampon pour accéder au contenu de l'index. De plus,
   toutes les méthodes existantes d'accès aux index utilisent la disposition
   de page standard décrite dans <xref linkend="storage-page-layout"/> et
   le même format pour les en-têtes de ligne de
   l'index&nbsp;; mais ces décisions ne sont pas contraintes sur une méthode
   d'index.
  </para>

  <para>
   Dans les faits, un index est une correspondance entre les valeurs des clés
   de données et les
   identifiants de lignes (<firstterm>tuple identifiers</firstterm>, ou <acronym>TIDs</acronym>)
   des versions de lignes dans la table parent de l'index. Un TID consiste en un
   numéro de bloc et un numéro d'élément à l'intérieur de ce bloc (voir <xref
   linkend="storage-page-layout"/>). C'est une information suffisante pour
   récupérer une version de ligne particulière à partir de la table. Les index
   n'ont pas directement la connaissance de l'existence éventuelle, sous MVCC,
   de plusieurs versions de la même ligne logique&nbsp;; pour un index, chaque ligne
   est un objet indépendant qui a besoin de sa propre entrée dans l'index. Du
   coup, la mise à jour d'une ligne crée toujours toutes les nouvelles entrées
   d'index pour la ligne, même si les valeurs de la clé ne changent pas.
   (Les lignes HOT sont une exception&nbsp;; mais les index ne sont pas
   concernés.) Les entrées d'index pour les lignes mortes sont réclamées (par
   le VACUUM) lorsque les lignes mortes elles-même sont réclamées.
  </para>

 <sect1 id="index-catalog">
  <title>Entrées du catalogue pour les index</title>

  <para>
   Chaque méthode d'accès à l'index est décrite par une ligne dans le catalogue
   système <structname>pg_am</structname> (voir <xref linkend="catalog-pg-am"/>).
   Le contenu principal d'une ligne de <structname>pg_am</structname> est
   constitué de références à des entrées de
   <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
   qui identifient les fonctions d'accès à l'index fournies par la méthode d'accès.
   Les API de ces fonctions sont définies plus loin dans ce chapitre. De plus,
   la ligne de <structname>pg_am</structname> spécifie quelques propriétés fixes
   de la méthode d'accès, comme le support des index multi-colonnes. Il
   n'existe pas de support spécial pour la création ou la suppression d'entrées
   dans <structname>pg_am</structname>&nbsp;; toute personne capable d'écrire
   une nouvelle méthode d'accès est supposée assez compétente pour insérer la
   ligne appropriée.
  </para>

  <para>
   Pour être utile, une méthode d'accès à l'index doit aussi avoir une ou
   plusieurs <firstterm>familles d'opérateur</firstterm> et <firstterm>classes
   d'opérateur</firstterm> définies dans
   <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>,
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link> et
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   Ces entrées permettent au planificateur de déterminer les types de qualification
   des requêtes qui peuvent être utilisés avec les index de cette méthode d'accès.
   Les familles et classes d'opérateurs sont décrites dans <xref
   linkend="xindex"/>, qui est un élément requis pour comprendre ce chapitre.
  </para>

  <para>
   Un index individuel est défini par une entrée dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   le définissant comme une relation physique, et une entrée dans
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   affichant le contenu logique de l'index &mdash; c'est-à-dire ses colonnes
   d'index et la sémantique de ces colonnes, telles que
   récupérées par les classes d'opérateur associées. Les colonnes de
   l'index (valeurs clés) peuvent être des colonnes simples de la table
   sous-jacente ou des expressions sur les lignes de la table. Habituellement,
   la méthode d'accès à l'index ne s'intérese pas à la provenance
   des valeurs clés de l'index (ce sont toujours des valeurs clés
   pré-traitées), mais trouve beaucoup d'intérêt aux informations de la classe
   d'opérateur dans <structname>pg_index</structname>. Les entrées de ces deux
   catalogues peuvent être accédées comme partie de la structure de données de
   <structname>Relation</structname> passée à toute opération sur l'index.
  </para>

  <para>
   Certaines colonnes d'options de <structname>pg_am</structname> ont des
   implications peu évidentes. Les besoins de <structfield>amcanunique</structfield>
   sont discutés dans  <xref linkend="index-unique-checks"/>.
   L'option <structfield>amcanmulticol</structfield> indique que la méthode
   d'accès supporte les index multi-colonnes alors que 
   <structfield>amoptionalkey</structfield> indique que des parcours sont
   autorisés lorsqu'aucune clause de restriction indexable n'est donnée pour la première colonne
   de l'index. Quand <structfield>amcanmulticol</structfield> est faux,
   <structfield>amoptionalkey</structfield> indique essentiellement si la méthode
   d'accès autorise les parcours complets de l'index sans clause de restriction.
   Les méthodes d'accès qui supportent les colonnes d'index multiples
   <emphasis>doivent</emphasis> supporter les parcours qui omettent des
   restrictions sur une ou toutes les colonnes après la première&nbsp;;
   néanmoins, elles peuvent imposées qu'une restriction apparaisse pour la
   première colonne de l'index, ce qui est signalé par l'initialisation de
   <structfield>amoptionalkey</structfield> à faux.
   Une raison pour laquelle une méthode d'accès d'index initialiserait
   <structfield>amoptionalkey</structfield> à false est qu'elle n'indexe pas
   les valeurs NULL. Comme la plupart des opérateurs indexables
   sont stricts et, du coup, ne peuvent pas renvoyer TRUE pour des entrées NULL,
   il est à première vue attractif de ne pas stocker les entrées d'index pour les
   valeurs NULL&nbsp;: un parcours d'index ne peut, de toute façon, pas les
   retourner. Néanmoins, cet argument tombe lorsqu'un parcours d'index
   n'a pas de clause de restriction pour une colonne d'index donnée. En pratique,
   cela signifie que les index dont <structfield>amoptionalkey</structfield> vaut
   true doivent indexer les valeurs NULL, car le planificateur peut décider
   d'utiliser un tel index sans aucune clé de parcours. Une restriction en
   découle&nbsp;: une méthode d'accès qui supporte des colonnes d'index
   multiples <emphasis>doit</emphasis> supporter l'indexage des valeurs NULL dans les colonnes
   qui suivent la première, car le planificateur suppose que l'index peut être
   utilisé pour les requêtes qui ne restreignent pas ces colonnes. Par exemple,
   si l'on considère un index sur (a,b) et une requête avec <literal>WHERE a =
   4</literal>, le système suppose que l'index peut être utilisé pour
   rechercher les lignes pour lesquelles <literal>a = 4</literal>, ce qui est
   faux si l'index omet les lignes où <literal>b</literal> est null.
   Néanmoins, il est correct d'omettre les lignes où la
   première colonne indexée est NULL. Du coup, une méthode d'accès d'index
   qui ne s'occupe pas des valeurs NULL pourrait aussi configurer
   <structfield>amsearchnulls</structfield>, indiquant ainsi qu'elle supporte
   les clauses <literal>IS NULL</literal> et <literal>IS NOT NULL</literal> dans
   les conditions de recherche.
  </para>

 </sect1>

 <sect1 id="index-functions">
  <title>Fonctions de la méthode d'accès aux index</title>

  <para>
   Les fonctions de construction et de maintenance d'index que doit fournir
   une méthode d'accès aux index sont&nbsp;:
  </para>

  <para>
<programlisting>IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   Construire un nouvel index. La relation de l'index a été créée physiquement
   mais elle est vide. Elle doit être remplie avec toute donnée fixe nécessaire
   à la méthode d'accès, ainsi que les entrées pour toutes les lignes existant
   déjà dans la table. Habituellement, la fonction <function>ambuild</function> appelle
   <function>IndexBuildHeapScan()</function> pour parcourir la table à la
   recherche des lignes qui existent déjà et calculer les clés à insérer dans
   l'index. La fonction doit renvoyer une structure allouée par palloc contenant
   les statistiques du nouvel index.
  </para>

  <para>
<programlisting>bool
void
ambuildempty (Relation indexRelation);
</programlisting>
   Construire un index vide et l'inscrire dans le fichier d'initialisation
   (INIT_FORKNUM) de la relation. Cette méthode est seulement appelée pour les
   tables non tracées. L'index vide inscrit dans le fichier d'initialisation
   sera copié sur le fichier de la relation à chaque redémarrage du serveur.
  </para>

  <para>
<programlisting>bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique);
</programlisting>
   Insérer une nouvelle ligne dans un index existant. Les tableaux
   <literal>values</literal> et <literal>isnull</literal> donnent les valeurs
   de clés à indexer.
   <literal>heap_tid</literal> est le TID à indexer. Si la méthode d'accès supporte les
   index uniques (son drapeau <structname>pg_am</structname>.<structfield>amcanunique</structfield>
   vaut true), alors <literal>checkUnique</literal> indique le type de
   vérification unique à réaliser. Cela varie si la contrainte unique est
   déferrable ou non&nbsp;; voir <xref linkend="index-unique-checks"/> pour
   les détails. Habituellement, la méthode d'accès a seulement besoin du
   paramètre <literal>heapRelation</literal> lors de la vérification de
   l'unicité (car après, elle doit regarder la table pour vérifier la
   visibilité de la ligne).
  </para>

  <para>
   La valeur résultat, de type booléen, de la fonction est significative
   seulement quand <literal>checkUnique</literal> vaut
   <literal>UNIQUE_CHECK_PARTIAL</literal>. Dans ce cas, un résultat TRUE
   signifie que la nouvelle entrée est reconnue comme unique alors que FALSE
   indique qu'elle pourrait ne pas être unique (et une vérification d'unicité
   déferrée doit être planifiée). Dans les autres cas, un résultat FALSE
   constant est recommendé.
  </para>

  <para>
   Certains index pourraient ne pas indexer toutes les lignes. Si la ligne
   ne doit pas être indexée, <function>aminsert</function> devrait terminer
   sans rien faire.
  </para>

  <para>
<programlisting>IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   Supprimer un(des) tuple(s) de l'index. Il s'agit d'une opération de
   <quote>suppression massive</quote> à implanter par le parcours complet de
   l'index et la vérification de chaque entrée pour déterminer si elle
   doit être supprimée. La fonction <literal>callback</literal> en argument doit être
   appelée, sous la forme <literal>callback(<replaceable>TID</replaceable>, callback_state)
   returns bool</literal>, pour déterminer si une entrée d'index particulière,
   identifiée par son TID, est à supprimer. Cette fonction Doit renvoyer NULL
   ou une structure issue d'un palloc qui contient des statistiques sur les
   effets de l'opération de suppression.
   La fonction peut retourner NULL si aucune information ne doit être envoyée à
   <function>amvacuumcleanup</function>.
  </para>

  <para>
   En cas de limitation de <varname>maintenance_work_mem</varname>, la
   suppression de nombreux tuples impose d'appeler
   <function>ambulkdelete</function> à plusieurs reprises.
   L'argument <literal>stats</literal> est le résultat du dernier appel pour cet index
   (il est NULL au premier appel dans une opération
   <command>VACUUM</command>). Ceci permet à l'AM d'accumuler des statistiques
   sur l'opération dans son intégralité. Typiquement, <function>ambulkdelete</function>
   modifie et renvoie la même structure si le <literal>stats</literal> fourni
   n'est pas NULL.
  </para>

  <para>
<programlisting>IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   Nettoyage après une opération <command>VACUUM</command> (zéro à plusieurs
   appels à <function>ambulkdelete</function>). La fonction n'a pas d'autre but
   que de retourner des statistiques concernant les index, mais elle peut réaliser
   un nettoyage en masse (réclamer les pages d'index vides, par exemple).
   <literal>stats</literal> est le retour de l'appel à <function>ambulkdelete</function>,
   ou NULL si
   <function>ambulkdelete</function> n'a pas été appelée car aucune ligne n'avait
   besoin d'être supprimée. Si le résultat n'est pas NULL, il s'agit d'une structure
   allouée par palloc. Les statistiques qu'elle contient sont utilisées pour
   mettre à jour <structname>pg_class</structname>, et sont rapportées par
   <command>VACUUM</command> si <literal>VERBOSE</literal> est indiqué. La
   fonction peut retourner NULL si l'index n'a pas été modifié lors de l'opération
   de <command>VACUUM</command> mais, dans le cas contraire, il faut retourner
   des statistiques correctes.
  </para>

  <para>
   À partir de <productname>PostgreSQL</productname> 8.4,
   <function>amvacuumcleanup</function> sera aussi appelé à la fin d'une
   opération <command>ANALYZE</command> operation. Dans ce cas,
   <literal>stats</literal> vaut toujours NULL et toute valeur de retour sera
   ignorée. Ce cas peut être distingué en vérifiant
   <literal>info-&gt;analyze_only</literal>. Il est recommandé que la méthode
   d'accès ne fasse rien en dehors du nettoyage après insertion pour ce type
   d'appel, et cel aseulement dans un processus de travail autovacuum.
  </para>

  <para>
<programlisting>
bool
amcanreturn (Relation indexRelation);
</programlisting>
   Vérifie si l'index supporte les <firstterm>parcours d'index seul</firstterm>
   en renvoyant les valeurs indexées de la colonne pour une entrée d'index
   sous la forme d'un IndexTuple. Renvoie TRUE si c'est le cas, et FALSE sinon.
   Si la méthode d'accès de l'index ne peut jamais supporter les parcours
   d'index seul (un index est hash, qui stocke seulement les valeurs du
   hachage, et pas la donnée originale), il suffit de configurer le champ
   <structfield>amcanreturn</structfield> à zéro dans
   <structname>pg_am</structname>.
  </para>

  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>
   Estimer les coûts d'un parcours d'index. Cette fonction est décrite complètement
   dans <xref linkend="index-cost-estimation"/>, ci-dessous.
  </para>

  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
   Analyser et valider le tableau reloptions pour un index. Cette fonction
   n'est appelée que lorsqu'il existe un tableau reloptions non NULL pour l'index.
   <parameter>reloptions</parameter> est un tableau de type <type>text</type>
   contenant des entrées de la forme
   <replaceable>nom</replaceable><literal>=</literal><replaceable>valeur</replaceable>.
   La fonction construit une valeur de type <type>bytea</type> à
   copier dans le champ <structfield>rd_options</structfield> de l'entrée relcache
   de l'index. Les données contenues dans la valeur <type>bytea</type> sont
   définies par la méthode d'accès. La plupart des méthodes d'accès standard utilisent
   la structure <structname>StdRdOptions</structname>.
   Lorsque <parameter>validate</parameter> est true, la fonction remonte
   un message d'erreur clair si une option n'est pas reconnue ou a des
   valeurs invalides&nbsp;; quand <parameter>validate</parameter> est false, les
   entrées invalides sont ignorées silencieusement.
   (<parameter>validate</parameter> est faux lors du chargement d'options déjà
   stockées dans <structname>pg_catalog</structname>&nbsp;; une entrée invalide
   ne peut être trouvée que si la méthode d'accès a modifié ses règles pour
   les options et, dans ce cas, ignorer les entrées obsolètes est approprié.)
   Pour obtenir le comportement par défaut, il suffit de retourner NULL.
  </para>

  <para>
   Le but d'un index est de supporter les parcours de lignes
   qui correspondent à une condition <literal>WHERE</literal> indexable, souvent appelée
   <firstterm>qualificateur</firstterm>
   (<foreignphrase>qualifier</foreignphrase>) ou <firstterm>clé de
   parcours</firstterm> (<foreignphrase>scan key</foreignphrase>). La sémantique
   du parcours d'index est décrite plus complètement dans <xref linkend="index-scanning"/>,
   ci-dessous. Une méthode d'accès à l'index peut supporter les parcours d'accès
   standards (<quote>plain</quote>), les parcours d'index <quote>bitmap</quote>
   ou les deux. Les fonctions liées au parcours qu'une méthode d'accès à
   l'index doit ou devrait fournir sont&nbsp;:
  </para>

  <para>
<programlisting>IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
</programlisting>
   Prépare un parcours d'index. Les paramètres <literal>nkeys</literal> et
   <literal>norderbys</literal> indiquent le nombre de qualificateurs et
   d'opérateurs de tri qui seront utilisés dans le parcours. Cela pourrait se
   révéler utile pour l'allocation d'espace. Notez que les valeurs actuelles
   des clés de parcours ne sont pas encore fournies. Le résultat doit être
   une structure allouée avec la fonction palloc. Pour des raisons
   d'implémentation, la méthode d'accès à l'index <emphasis>doit</emphasis>
   créer cette structure en appelant
   <function>RelationGetIndexScan()</function>. Dans la plupart des cas,
   <function>ambeginscan</function> fait peu en dehors de cet appel et,
   peut-être, d'aquérir des verrous&nbsp;; les parties intéressantes de début
   de parcours d'index sont dans <function>amrescan</function>.
  </para>

  <para>
<programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
</programlisting>
   Démarre ou relance un parcours d'index, possiblement avec des nouvelles
   clés d'index. (Pour relancer en utilisant des clés déjà passées, NULL est
   passé pour <literal>keys</literal> et/ou <literal>orderbys</literal>.) Notez
   qu'il n'est pas autorisé que le nombre de clés ou d'opérateurs de tri
   soit plus grande que celui passé à la fonction
   <function>ambeginscan</function>. En pratique, la fonctionnalité de
   relancement est utilisée quand une nouvelle ligne externe est sélectionnée
   par une jointure de boucle imbriquée, et donc une nouvelle valeur de
   comparaison de clé est requise, mais la structure de clé de parcours reste
   la même.
  </para>

  <para>
<programlisting>boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   Récupérer la prochaine ligne d'un parcours donné, dans la direction donnée
   (vers l'avant ou l'arrière de l'index). Renvoie TRUE si une ligne a
   été obtenue, FALSE s'il ne reste aucune ligne. Dans le cas
   TRUE, le TID de la ligne est stocké dans la structure
   <literal>scan</literal>. <quote>success</quote> signifie uniquement que
   l'index contient une entrée qui correspond aux clés de parcours, pas que
   la ligne existe toujours dans la pile ou qu'elle peut réussir le test
   d'instantané de l'appelant. En cas de succès, <function>amgettuple</function>
   doit aussi configuré <literal>scan-&gt;xs_recheck</literal> à TRUE ou FALSE.
   FALSE signifie qu'il est certain que l'entrée de l'index correspond aux clés
   de parcours. TRUE signifie que ce n'est pas certain et que les conditions
   représentées par les clés de parcours doivent être de nouveau vérifiées sur
   la ligne de la table après l'avoir récupéré. Cette différence permet de
   supporter les opérateurs d'index <quote>à perte</quote>. Notez que la nouvelle
   vérification s'étendra seulement aux conditions de parcours&nbsp;; un prédicat
   partiel d'index n'est jamais vérifié par les appelants à
   <function>amgettuple</function>.
  </para>

  <para>
   Si l'index supporte les parcours d'index seul (c'est-à-dire que
   <function>amcanreturn</function> renvoit TRUE), alors, en cas de succès,
   la méthode d'accès doit aussi vérifier
   <literal>scan-&gt;xs_want_itup</literal>, et si ce dernier est TRUE, elle
   doit renvoyer les données indexées originales pour l'entrée d'index, sous
   la forme d'un pointeur d'<structname>IndexTuple</structname> stocké
   dans <literal>scan-&gt;xs_itup</literal>, avec un descripteur de lignes
   dans <literal>scan-&gt;xs_itupdesc</literal>.
   (La gestion de la donnée référencée par le pointeur est de la responsabilité
   de la méthode d'accès. Les données doivent rester bonnes au moins jusqu'au
   prochain appel à <function>amgettuple</function>,
   <function>amrescan</function> ou <function>amendscan</function> pour le
   parcours.)
  </para>

  <para>
   La fonction <function>amgettuple</function> a seulement besoin d'exister
   si la méthode d'accès supporte les parcours d'index standards. Si ce n'est
   pas le cas, le champ <structfield>amgettuple</structfield> de la ligne de
   <structname>pg_am</structname> doit valoir zéro.
  </para>

  <para>
<programlisting>
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
</programlisting>
   Récupère toutes les lignes du parcours sélectionné et les ajoute au
   <type>TIDBitmap</type> fournit par l'appelant (c'est-à-dire un OU de l'ensemble des
   identifiants de ligne dans l'ensemble où se trouve déjà le bitmap). Le
   nombre de lignes récupérées est renvoyé (cela peut n'être qu'une estimation
   car certaines méthodes d'accès ne détectent pas les duplicats). Lors de
   l'insertion d'identifiants de ligne dans le bitmap, <function>amgetbitmap</function>
   peut indiquer que la vérification des conditions du parcours est requis pour
   des identifiants précis de transactions. C'est identique au paramètre de sortie
   <literal>xs_recheck</literal> de <function>amgettuple</function>. Note&nbsp;:
   dans l'implantation actuelle, le support de cette fonctionnalité peut
   beaucoup ressembler au support du stockage à perte du bitmap lui-même, et du coup
   les appelants vérifient les conditions du parcours et le prédicat de l'index
   partiel (si disponible) pour les lignes vérifiables à nouveau. Cela pourrait
   ne pas toujours être vrai. <function>amgetbitmap</function> et
   <function>amgettuple</function> ne peuvent pas être utilisés dans le même
   parcours d'index&nbsp;; il existe d'autres restrictions lors de l'utilisation
   de <function>amgetbitmap</function>, comme expliquées dans <xref
   linkend="index-scanning"/>.
  </para>

  <para>
   La fonction <function>amgetbitmap</function> doit seulement exister si la
   méthode d'accès supporte les parcours d'index <quote>bitmap</quote>. Dans le
   cas contraire, le champ <structfield>amgetbitmap</structfield> de la ligne
   correspondante dans <structname>pg_am</structname> doit être à zéro.
  </para>

  <para>
<programlisting>void
amendscan (IndexScanDesc scan);
</programlisting>
   Terminer un parcours et libérer les ressources. La structure <literal>scan</literal>
   elle-même ne doit pas être libérée, mais tout verrou pris en interne par
   la méthode d'accès doit être libéré.
  </para>

  <para>
<programlisting>void
ammarkpos (IndexScanDesc scan);
</programlisting>
   Marquer la position courante du parcours. La méthode d'accès ne mémorise
   qu'une seule position par parcours.
  </para>

  <para>
<programlisting>void
amrestrpos (IndexScanDesc scan);
</programlisting>
   Restaurer le parcours à sa plus récente position marquée.
  </para>

  <para>
   Par convention, l'entrée <literal>pg_proc</literal> de toute fonction de
   méthode d'accès aux index affiche le bon nombre d'arguments, mais
   les déclare tous du type <type>internal</type> (la plupart des
   arguments ont des types qui ne sont pas connus en SQL, et il n'est pas
   souhaitable que les utilisateurs appelent les fonctions directement). Le type
   de retour est déclaré <type>void</type>, <type>internal</type> ou <type>boolean</type>
   suivant le cas.
   La seule exception est <function>amoptions</function>, qui doit être
   correctement déclarée prenant <type>text[]</type> et <type>bool</type>
   et retournant <type>bytea</type>. Cette protection autorise le code client à
   exécuter <function>amoptions</function> pour tester la validité des paramètres.
  </para>

 </sect1>

 <sect1 id="index-scanning">
  <title>Parcours d'index</title>

<!-- régurgitation est un drôle de terme dans ce contexte. L'auteur a-t-il
voulu mettre en avant une idée négative du fonctionnement du parcours ? -->
  <para>
   Dans un parcours d'index, la méthode d'accès à l'index retourne les TID
   de toutes les lignes annoncées correspondre
   aux <firstterm>clés de parcours</firstterm>. La méthode d'accès n'est
   impliquée <emphasis>ni</emphasis> dans la récupération de ces lignes dans la
   table parent de l'index, ni dans les tests de qualification temporelle ou autre.
  </para>

  <para>
   Une clé de parcours est une représentation interne d'une clause 
   <literal>WHERE</literal> de la forme <replaceable>clé_index</replaceable>
   <replaceable>opérateur</replaceable> <replaceable>constante</replaceable>,
   où la clé d'index est une des colonnes de l'index et l'opérateur est un des
   membres de la famille d'opérateur associée avec cette colonne d'index. Un
   parcours d'index contient entre aucune et plusieurs clés de parcours qui sont assemblées
   implicitement avec des AND &mdash; les lignes renvoyées doivent satisfaire
   toutes les conditions indiquées.
  </para>

<!-- lossy: à pertes ? c'est valable quand on parle de compression, qui
supprime des données, mais dans le cas de l'index ? -->
  <para>
   La méthode d'accès peut indiquer que l'index est <firstterm>à
   perte</firstterm> ou nécessite une vérification pour une requête
   particulière&nbsp;; ceci implique que le parcours d'index renvoie toutes les
   entrées qui correspondent à la clé de parcours, avec éventuellement des
   entrées supplémentaires qui ne correspondent pas. La machinerie du parcours
   d'index du système principal applique alors les conditions de l'index au
   tuple pour vérifier s'il doit bien effectivement être retenu. Si l'option
   de vérification n'est pas indiquée, le parcours d'index doit renvoyer
   exactement l'ensemble d'entrées correspondantes.
  </para>

  <para>
   La méthode d'accès doit s'assurer 
   qu'elle trouve correctement toutes les entrées correspondantes aux clés de
   parcours données, et seulement celles-ci. De plus, le système principal
   transfert toutes les clauses <literal>WHERE</literal> qui correspondent aux clés d'index
   et aux familles d'opérateurs, sans analyse sémantique permettant de
   déterminer si elles sont redondantes ou contradictoires. Par exemple, étant donné
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal> où <literal>x</literal> est une colonne
   indexée B-tree, c'est à la fonction B-tree <function>amrescan</function>
   de déterminer que la première clé de parcours est redondante et peut être
   annulée. Le supplément de pré-traitement nécessaire lors de
   <function>amrescan</function> dépend du niveau de réduction des clés de
   parcours en une forme <quote>normalisée</quote> nécessaire à la
   méthode d'accès à l'index.
  </para>

  <para>
   Certaines méthodes d'accès renvoient des entrées d'index dans un ordre bien
   défini, d'autres non. Il existe en fait deux façons différentes permettant
   à une méthode d'accès de fournir une sortie triée&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       Les méthodes d'accès qui renvoient toujours les entrées dans l'ordre
       naturel (comme les B-tree) doivent configurer
       <structname>pg_am</structname>.<structfield>amcanorder</structfield> à
       true. Actuellement, ces méthodes d'accès doivent utiliser des nombres
       de stratégie compatibles avec les B-tree pour les opérateurs d'égalité
       et de tri.
      </para>
     </listitem>
     <listitem>
      <para>
       Les méthodes d'accès qui supportent les opérateurs de tri doivent
       configurer
       <structname>pg_am</structname>.<structfield>amcanorderbyop</structfield>
       à true. Ceci indique que l'index est capable de renvoyer les entrées
       dans un ordre satisfaisant <literal>ORDER BY</literal>
       <replaceable>clé_index</replaceable> <replaceable>opérateur</replaceable>
       <replaceable>constante</replaceable>. Les modificateurs de parcours de
       cette forme peuvent être passés à <function>amrescan</function> comme
       décrits précédemment
       previously.
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   La fonction <function>amgettuple</function> dispose d'un argument <literal>direction</literal>,
   qui peut être soit <literal>ForwardScanDirection</literal> (le cas normal) soit
   <literal>BackwardScanDirection</literal>. Si le premier appel après
   <function>amrescan</function> précise <literal>BackwardScanDirection</literal>, alors
   l'ensemble des entrées d'index correspondantes est à parcourir de l'arrière
   vers l'avant plutôt que dans la direction normale (d'avant en arrière). 
   <function>amgettuple</function> doit donc renvoyer la dernière ligne correspondante dans
   l'index, plutôt que la première, comme cela se fait normalement. (Cela ne
   survient que pour les méthodes
   d'accès qui initialise <structfield>amcanorder</structfield> à true.) Après
   le premier appel, <function>amgettuple</function>
   doit être préparé pour continuer le parcours dans la direction adaptée à partir de
   l'entrée la plus récemment renvoyée. (Mais si
   <structname>pg_am</structname>.<structfield>amcanbackward</structfield> vaut
   false, tous les appels suivants auront la même direction que le premier.)
  </para>

  <para>
   Les méthodes d'accès qui supportent les parcours ordonnés doivent supporter
   le <quote>marquage</quote> d'une position dans un parcours pour retourner
   plus tard à la position marquée. La même position pourrait être restaurée
   plusieurs fois. Néanmoins, seule une position par parcours a besoin d'être
   conservée en mémoire&nbsp;; un nouvel appel à <function>ammarkpos</function>
   surcharge la position anciennement marquée. Une méthode d'accès qui ne
   supporte pas les parcours ordonnés doit quand même fournir les fonctions de
   marquage et de restauration dans <structname>pg_am</structname>, mais il est
   suffisant de leur faire renvoyer des erreurs si les fonctions sont appelées.
  </para>

  <para>
   Les positions du parcours et du marquage doivent être conservées de façon
   cohérente dans le cas d'insertions et de suppressions concurrentes dans
   l'index. Il est tout à fait correct qu'une entrée tout juste insérée ne soit
   pas retournée par un parcours, qui si l'entrée avait existé au démarrage du
   parcours, aurait été retournée. De même est-il correct qu'un parcours
   retourne une telle entrée lors d'un re-parcours ou d'un retour arrière,
   alors même qu'il ne l'a pas retourné lors du parcours initial.
   À l'identique, une suppression concurrente peut être, ou non, visible dans
   les résultats d'un parcours. Il est primordial qu'insertions et suppressions
   ne conduisent pas le parcours à oublier ou dupliquer des entrées qui ne sont
   pas elles-même insérées ou supprimées.
  </para>

  <para>
   Si l'index stocke les valeurs originales des données indexées (et pas une
   représentation à perte des données), il est utile de supporter les parcours
   d'index seul, pour lesquels l'index renvoie la donnée réelle et non pas
   seulement le TID de la ligne dans la table. Ceci va seulement fonctionner
   si la carte de visibilité montre que le TID est sur une page dont toutes
   les lignes sont visibles par toutes les transactions en cours. Sinon, la
   ligne de la table doit être visitée de toute façon pour s'assurer de
   sa visibilité pour la transaction en cours. Mais cela ne concerne pas la
   méthode d'accès.
  </para>

  <para>
   <function>amgetbitmap</function> peut être utilisé à la place de 
   <function>amgettuple</function> pour un parcours d'index. Cela permet de
   récupérer toutes les lignes en un appel. Cette méthode peut s'avérer 
   notablement plus efficace que <function>amgettuple</function> parce qu'elle
   permet d'éviter les cycles de verrouillage/déverrouillage à l'intérieur de la
   méthode d'accès. En principe, <function>amgetbitmap</function> a les mêmes
   effets que des appels répétés à <function>amgettuple</function>, mais 
   plusieurs restrictions ont été imposées pour simplifier la procédure. En
   premier lieu, <function>amgetbitmap</function> renvoie toutes les lignes
   en une fois et le marquage ou la restauration des positions de parcours n'est
   pas supporté. Ensuite, les lignes sont renvoyées dans un bitmap qui n'a pas
   d'ordre spécifique, ce qui explique pourquoi <function>amgetbitmap</function>
   ne prend pas de <literal>direction</literal> en argument. (Les opérateurs
   de tri ne seront jamais fournis pour un tel parcours.) 
   De plus, il n'existe aucune disposition pour les parcours d'index seul avec
   <function>amgetbitmap</function> car il n'y a aucun moyen de renvoyer le
   contenu des lignes d'index.
   Enfin,
   <function>amgetbitmap</function> ne garantit pas le verrouillage
   des lignes renvoyées, avec les implications précisées dans <xref
   linkend="index-locking"/>.
  </para>

  <para>
   Notez qu'il est permis à une méthode d'accès d'implanter seulement
   <function>amgetbitmap</function> et pas <function>amgettuple</function>, ou
   vice versa, si son implantation interne ne convient qu'à une seule des API.
  </para>
  
 </sect1>

 <sect1 id="index-locking">
  <title>Considérations sur le verrouillage d'index</title>

  <para>
   Les méthodes d'accès aux index doivent gérer des mises à jour
   concurrentes de l'index par plusieurs processus.
   Le système principal <productname>PostgreSQL</productname> obtient
   <literal>AccessShareLock</literal> sur l'index lors d'un parcours d'index et
   <literal>RowExclusiveLock</literal> lors de sa mise à jour (ce qui inclut le
   <command>VACUUM</command> simple). Comme ces types de
   verrous ne sont pas conflictuels, la méthode d'accès est responsable de la
   finesse du verrouillage dont elle a besoin. Un verrou exclusif sur
   l'intégralité de l'index entier n'est pris qu'à la création de l'index, sa destruction
   ou dans une opération <literal>REINDEX</literal>.
  </para>

  <para>
   Construire un type d'index qui supporte les mises à jour concurrentes
   requiert une analyse complète et subtile du comportement requis. Pour les
   types d'index B-tree et hash, on peut lire les implication sur les décisions
   de conception dans
   <filename>src/backend/access/nbtree/README</filename> et
   <filename>src/backend/access/hash/README</filename>.
  </para>

  <para>
   En plus des besoins de cohérence interne de l'index, les mises à jour
   concurrentes créent des problèmes de cohérence entre la table parent
   (l'<firstterm>en-tête</firstterm>, ou <foreignphrase>heap</foreignphrase>)
   et l'index. Comme <productname>PostgreSQL</productname> sépare les accès et les mises à
   jour de l'en-tête de ceux de l'index, il existe des fenêtres temporelles
   pendant lesquelles l'index et l'en-tête peuvent être incohérents. Ce problème
   est géré avec les règles suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       une nouvelle entrée dans l'en-tête est effectuée avant son entrée
       dans l'index. (Un parcours d'index concurrent peut alors ne pas
       voir l'entrée dans l'en-tête. Ce n'est pas gênant dans la mesure où un
       lecteur de l'index ne s'intéresse pas à une ligne non validée. Voir
       <xref linkend="index-unique-checks"/>);
      </para>
     </listitem>
     <listitem>
      <para>
       Lorsqu'entrée de l'en-tête va être supprimée (par <command>VACUUM</command>),
       toutes les entrées de l'index doivent d'abord être supprimées&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       un parcours d'index doit maintenir
       un lien sur la page d'index contenant le dernier élément renvoyé par
       <function>amgettuple</function>, et <function>ambulkdelete</function> ne peut pas
       supprimer des entrées de pages liées à d'autres processus. La
       raison de cette règle est expliquée plus bas.
      </para>
     </listitem>
    </itemizedlist>

   Sans la troisième règle, il est possible qu'un lecteur d'index voit
   une entrée dans l'index juste avant qu'elle ne soit supprimée par un
   <command>VACUUM</command>, et arrive à l'entrée correspondante de
   l'en-tête après sa suppression par le <command>VACUUM</command>.
   Cela ne pose aucun problème sérieux si ce numéro d'élément
   est toujours inutilisé quand le lecteur l'atteint, car tout emplacement d'élément
   vide est ignoré par <function>heap_fetch()</function>. Mais que se passe-t-il si
   un troisième moteur a déjà ré-utilisé l'emplacement de l'élément pour quelque
   chose d'autre&nbsp;? Lors de l'utilisation d'un instantané compatible MVCC, il n'y
   a pas de problème car le nouvel occupant de l'emplacement est certain d'être
   trop récent pour réussir le test de l'insstantané. En revanche, avec un
   instantané non-compatible MVCC (tel que <literal>SnapshotNow</literal>), une
   ligne qui ne correspond pas aux clés de parcours peut être acceptée ou
   retournée. Ce scénario peut être évité en imposant que les clés de parcours
   soient re-confrontées à la ligne d'en-tête dans tous les cas, mais cela est
   trop coûteux. À la place, un lien sur une page d'index est utilisé comme
   <foreignphrase>proxy</foreignphrase> pour indiquer que le
   lecteur peut être <quote>en parcours</quote> entre l'entrée de
   l'index et l'entrée de l'en-tête correspondante. Bloquer <function>ambulkdelete</function>
   sur un tel lien assure que <command>VACUUM</command> ne peut pas supprimer
   l'entrée de l'en-tête avant que le lecteur n'en ait terminé avec elle. Cette
   solution est peu coûteuse en temps d'exécution, et n'ajoute de surcharge du
   fait du blocage que dans de rares cas réellement un conflictuels.
  </para>

  <para>
   Cette solution requiert que les parcours d'index soient
   <quote>synchrones</quote>&nbsp;: chaque ligne d'en-tête doit être récupérée
   immédiatement après le parcours de l'entrée d'index correspondante.
   C'est coûteux pour plusieurs raisons. Un parcours <quote>asynchrone</quote> dans
   lequel de nombreux TID sont récupérés de l'index, et pour lequel
   les en-têtes de lignes ne sont visités que plus tard, requiert moins de
   surcharge de verrouillage d'index et autorise un modèle d'accès à
   l'en-tête plus efficace. D'après l'analyse ci-dessus,
   l'approche synchronisée doit être utilisée pour les instantanés non compatibles avec
   MVCC, mais un parcours asynchrone est possible pour une requête utilisant
   une instantané MVCC.
  </para>

  <para>
   Dans un parcours d'index <function>amgetbitmap</function>, la méthode d'accès
   ne conserve pas de lien à l'index sur quelque ligne
   renvoyée. C'est pourquoi, il est préférable d'utiliser de tels parcours
   avec les instantanés compatibles MVCC.
  </para>

  <para>
   Quand le drapeau <structfield>ampredlocks</structfield> n'est pas configuré,
   tout parcours utilisant cette méthode d'accès de l'index dans une transaction
   sérialisable acquèrera un verrou prédicat non bloquant sur l'index
   complet. Ceci génèrera un conflit en lecture/écriture avec l'insertion d'une
   ligne dans cet index par une transaction sérialisable concurrente. Si
   certains motifs de conflit en lecture/écriture sont détectés parmi un
   ensemble de transactions sérialisables concurrentes, une de ces transactions
   pourrait être annulée pour protéger l'intégrité des données. Quand le
   drapeau est configuré, cela indique que la méthode d'accès de l'index
   implémente un verrou prédicat plus fin, qui tend à réduire la fréquence
   d'annulations de telles requêtes.
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>Vérification de l'unicité de l'index</title>

<!-- SAS :: L'index n'est pas unique, il garantit l'unicité -->
  <para>
   <productname>PostgreSQL</productname> assure les contraintes d'unicité SQL
   en utilisant des <firstterm>index d'unicité</firstterm>, qui sont des index qui refusent
   les entrées multiples à clés identiques. Une méthode d'accès qui
   supporte cette fonctionnalité initialise
   <structname>pg_am</structname>.<structfield>amcanunique</structfield> à
   true. (À ce jour, seul B-tree le supporte).
  </para>

  <para>
   Du fait de MVCC, il est toujours nécessaire de permettre à des entrées dupliquées
   d'exister physiquement dans un index&nbsp;: les entrées peuvent faire
   référence à des versions successives d'une même ligne logique. Le comportement
   qu'il est réellement souhaitable d'assurer est qu'aucune image MVCC n'inclut deux
   lignes avec les mêmes clés d'index. Cela se résume aux cas suivants, qu'il
   est nécessaire de vérifier à l'insertion d'une nouvelle ligne dans un index
   d'unicité&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       si une ligne valide conflictuelle a été supprimée par la transaction
       courante, pas de problème. (En particulier, comme un UPDATE supprime
       toujours l'ancienne version de la ligne avant d'insérer la nouvelle
       version, cela permet un UPDATE sur une ligne sans changer la clé)&nbsp;;
      </para>
     </listitem>
     <listitem>
     <!-- dans toto ? kesako ? in toto (locution latine) : en entier, intégralement cf.
     http://www.merriam-webster.com/dictionary/in+toto -->
      <para>
	si une ligne conflictuelle a été insérée par une transaction non encore
	validée, l'inséreur potentiel doit attendre de voir si la transaction
	est validée. Si la transaction est annulée, alors il n'y a pas de conflit.
	Si la transaction est validée sans que la ligne conflictuelle soit
	supprimée, il y a violation de la contrainte d'unicité. (En pratique,
	on attend que l'autre transaction finisse et le contrôle de visibilité
	est effectué à nouveau dans son intégralité)&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       de façon similaire, si une ligne valide conflictuelle est supprimée par
       une transaction non encore validée, l'inserant potentiel doit attendre la
       validation ou l'annulation de cette transaction et recommencer le test.
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   De plus, immédiatement avant de lever une violation d'unicité
   en fonction des règles ci-dessus, la méthode d'accès doit
   revérifier l'état de la ligne en cours d'insertion. Si elle
   est validée tout en étant morte, alors aucune erreur ne
   survient. (Ce cas ne peut pas survenir lors du scénario ordinaire
   d'insertion d'une ligne tout juste créée par la
   transaction en cours. Cela peut néanmoins arriver lors d'un
   <command>CREATE UNIQUE INDEX CONCURRENTLY</command>.)
  </para>

  <para>
   La méthode d'accès à l'index doit appliquer elle-même ces tests,
   ce qui signifie qu'elle doit accéder à l'en-tête pour vérifier le
   statut de validation de toute ligne présentée avec une clé dupliquée
   au regard du contenu de l'index. C'est sans aucun doute moche et non
   modulaire, mais cela permet d'éviter un travail redondant&nbsp;: si un test
   séparé est effectué, alors la recherche d'une ligne conflictuelle dans
   l'index est en grande partie répétée lors de la recherche d'une place pour
   insérer l'entrée d'index de la nouvelle ligne. Qui plus, est, il n'y a pas
   de façon triviale d'éviter les conflits, sauf si la recherche de conflit
   est partie intégrante de l'insertion de la nouvelle entrée d'index.
  </para>

  <para>
   Si la contrainte unique est déferrable, il y a une complication
   supplémentaire&nbsp;: nous devons être capable d'insérer une entrée d'index
   pour une nouvelle ligne mais de déferrer toute erreur de violation de
   l'unicité jusqu'à la fin de l'instruction, voire même après. Pour éviter
   des recherches répétées et inutiles de l'index, la méthode d'accès de
   l'index doit faire une vérification préliminaire d'unicité lors de
   l'insertion initiale. Si cela montre qu'il n'y a pas de conflit avec une
   ligne visible, nous avons terminé. Sinon, nous devons planifier une
   nouvelle vérification quand il sera temps de forcer la contrainte. Si, au
   moment de la nouvelle vérification, la ligne insérée et d'autres lignes de
   la même clé sont vivantes, alors l'erreur doit être reportée. (Notez que,
   dans ce contexte, <quote>vivant</quote> signifie réellement <quote>toute
   ligne dans la chaine HOT de l'entrée de l'index est vivante</quote>.)
   Pour implanter ceci, la fonction <function>aminsert</function> reçoit un
   paramètre <literal>checkUnique</literal> qui peut avoir une des valeurs
   suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_NO</literal> indicates that no uniqueness checking
       should be done (this is not a unique index).
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_YES</literal> indique qu'il s'agit d'un index
       unique non déferrable et la vérification de l'unicité doit se faire
       immédiatement, comme décrit ci-dessus.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_PARTIAL</literal> indique que la contrainte
       unique est déferrable. <productname>PostgreSQL</productname> utilisera
       ce mode pour insérer l'entrée d'index de chaque ligne. La méthode
       d'accès doit autoriser les entrées dupliquées dans l'index et rapporter
       tout dupliquat potentiel en renvoyant FALSE à partir de
       <function>aminsert</function>. Pour chaque ligne pour laquelle FALSE
       est renvoyé, une revérification déferrée sera planifiée.
      </para>

      <para>
       La méthode d'accès doit identifier toute ligne qui pourrait violer la
       contrainte unique, mais rapporter des faux positifs n'est pas une
       erreur. Cela permet de faire la vérification sans attendre la fin des
       autres transactions&nbsp;; les conflits rapportés ici ne sont pas
       traités comme des erreurs, et seront revérifiés plus tard, à un moment
       où ils ne seront peut-être plus en conflit.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_EXISTING</literal> indique que c'est une
       revérification déferrée d'une ligne qui a été rapportée comme en
       violation potentielle d'unicité. Bien que cela soit implanté par un
       appel à <function>aminsert</function>, la méthode d'accès ne doit
       <emphasis>pas</emphasis> insérer une nouvelle entrée d'index dans ce
       cas. L'entrée d'index est déjà présente. À la place, la méthode d'accès
       doit vérifier s'il existe une autre entrée d'index vivante. Si c'est le
       cas et que la ligne cible est toujours vivante, elle doit rapporter
       une erreur.
      </para>

      <para>
       Il est recommendé que, dans un appel à
       <literal>UNIQUE_CHECK_EXISTING</literal>, la méthode d'accès vérifie en
       plus que la ligne cible ait réellement une entrée existante dans l'index
       et de rapporter une erreur si ce n'est pas le cas. C'est une bonne idée
       car les valeurs de la ligne d'index passées à
       <function>aminsert</function> auront été recalculées. Si la définition
       de l'index implique des fonctions qui ne sont pas vraiment immutables,
       nous pourrions vérifier la mauvaise aire de l'index. Vérifier que la
       ligne cible est trouvée dans la revérification permet de s'assurer que
       nous recherchons les mêmes valeurs de la ligne comme elles ont été
       utilisées lors de l'insertion originale.
      </para>
     </listitem>
    </itemizedlist>
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>Fonctions d'estimation des coûts d'index</title>

  <para>
   La fonction <function>amcostestimate</function> se voit donner des
   informations décrivant un parcours d'index possible, incluant des listes
   de clauses WHERE et ORDER BY qui ont été déterminées pour être utilisables
   avec l'index. Elle doit renvoyer une
   estimation du coût de l'accès à l'index et de la sélectivité des clauses
   WHERE (c'est-à-dire la fraction des lignes de la table parent qui seront
   récupérées lors du parcours de l'index). Pour les cas simples, pratiquement
   tout le travail de l'estimateur de coût peut être effectué en appelant des
   routines standard dans l'optimiseur&nbsp;; la raison d'avoir une fonction
   <function>amcostestimate</function> est d'autoriser les méthodes d'accès aux index à fournir
   une connaissance spécifique au type d'index, au cas où il serait possible
   d'améliorer les estimations standard.
  </para>

  <para>
   Chaque fonction <function>amcostestimate</function> doit avoir la signature&nbsp;:

<programlisting>void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>

   Les trois premiers paramètres sont des entrées&nbsp;:

   <variablelist>
    <varlistentry>
     <term><parameter>root</parameter></term>
     <listitem>
      <para>
       Information du planificateur sur la requête en cours de traitement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>
       Le chemin d'accès considéré pour l'index. Tous les champs, en dehors
       du coût et de la sélectivité, sont valides.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</parameter></term>
     <listitem>
      <para>
       Le nombre de répétitions du parcours d'index qui devrait être
       pris en compte dans les estimations de coût. Cela sera généralement
       supérieur à 1 lors d'un parcours avec paramètres à utiliser à
       l'intérieur d'une jointure de boucle imbriquée. Notez que l'estimation
       de coût doit toujours être pour un seul parcours&nbsp;; une valeur plus
       importante de <parameter>loop_count</parameter> signifie qu'il pourrait
       être approprié de permettre des effets de cache avec plusieurs parcours.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les quatre derniers paramètres sont les sorties passées par référence&nbsp;:

   <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</parameter></term>
     <listitem>
      <para>
       Initialisé au coût du lancement du traitement de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</parameter></term>
     <listitem>
      <para>
       Initialisé au coût du traitement total de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</parameter></term>
     <listitem>
      <para>
       Initialisé à la sélectivité de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</parameter></term>
     <listitem>
      <para>
       Initialisé au coefficient de corrélation entre l'ordre du parcours de
       l'index et l'ordre sous-jacent de la table.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les fonctions d'estimation de coûts doivent être écrites en C, pas
   en SQL ou dans tout autre langage de procédure, parce qu'elles doivent accéder
   aux structures de données internes du planificateur/optimiseur.
  </para>

  <para>
   Les coûts d'accès aux index doivent être calculés en utilisant les paramètres
   utilisés par <filename>src/backend/optimizer/path/costsize.c</filename>&nbsp;: la
   récupération d'un bloc disque séquentiel a un coût de <varname>seq_page_cost</varname>,
   une récupération non séquentielle a un coût de <varname>random_page_cost</varname>, et le coût de
   traitement d'une ligne d'index doit habituellement être considéré comme
   <varname>cpu_index_tuple_cost</varname>. De plus, un multiple approprié de
   <varname>cpu_operator_cost</varname> doit être chargé pour tous les opérateurs
   de comparaison impliqués lors du traitement de l'index (spécialement
   l'évaluation des <literal>indexQuals</literal>).
  </para>

  <para>
   Les coûts d'accès doivent inclure tous les coûts dûs aux disques et aux CPU
   associés au parcours d'index lui-même, mais <emphasis>pas</emphasis> les coûts de
   récupération ou de traitement des lignes de la table parent qui sont
   identifiées par l'index.
  </para>

  <para>
   Le <quote>coût de lancement</quote> est la partie du coût total de parcours
   à dépenser avant de commencer à récupérer la première ligne.
   Pour la plupart des index, cela s'évalue à zéro, mais un type
   d'index avec un grand coût de lancement peut vouloir le configurer à
   une autre valeur que zéro.
  </para>

  <para>
   <parameter>indexSelectivity</parameter> doit être initialisé à la fraction estimée des lignes
   de la table parent qui sera récupérée lors du parcours d'index. Dans le cas
   d'une requête à perte, c'est typiquement plus élevé que la
   fraction des lignes qui satisfont les conditions de qualification données.
  </para>

  <para>
   <parameter>indexCorrelation</parameter> doit être initialisé à la corrélation (valeur entre
   -1.0 et 1.0) entre l'ordre de l'index et celui de la table. Cela permet
   d'ajuster l'estimation du coût de récupération des lignes de la table
   parent.
  </para>

  <para>
   Quand <parameter>loop_count</parameter> est supérieur à 1, les nombres
   renvoyés doivent être des moyennes attendues pour tout parcours de l'index.
  </para>

  <procedure>
   <title>Estimation du coût</title>
   <para>
    Un estimateur typique de coût exécute le traitement ainsi&nbsp;:
   </para>

   <step>
    <para>
     Estime et renvoie la fraction des lignes de la table parent 
     visitées d'après les conditions de qualification données. En l'absence de toute
     connaissance spécifique sur le type de l'index, on utilise la fonction
     de l'optimiseur standard <function>clauselist_selectivity()</function>:

<programlisting>+*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
+                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de lignes d'index visitées lors du parcours. Pour
     de nombreux types d'index, il s'agit de
     <parameter>indexSelectivity</parameter> multiplié par le nombre de
     lignes dans l'index, mais cela peut valoir plus (la taille
     de l'index en pages et lignes est disponible à partir de la structure
     <literal>path-&gt;indexinfo</literal>).
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de pages d'index récupérées pendant le parcours.
     Ceci peutt être simplement <parameter>indexSelectivity</parameter>
     multiplié par la taille de l'index en pages.
    </para>
   </step>

   <step>
    <para>
     Calcule le coût d'accès à l'index. Un estimateur générique peut le
     faire ainsi&nbsp;:

<programlisting>    /*
     * Our generic assumption is that the index pages will be read
     * sequentially, so they have cost seq_page_cost each, not random_page_cost.
     * Also, we charge for evaluation of the indexquals at each index row.
     * All the costs are assumed to be paid incrementally during the scan.
     */
    cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
    *indexStartupCost = index_qual_cost.startup;
    *indexTotalCost = seq_page_cost * numIndexPages +
        (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

     Néanmoins, le calcul ci-dessus ne prend pas en compte l'amortissement des
     lectures des index à travers les parcours répétés d'index.
    </para>
   </step>

   <step>
    <para>
     Estime la corrélation de l'index. Pour un index ordonné sur un seul champ,
     cela peut s'extraire de pg_statistic. Si la corrélation est inconnue,
     l'estimation conservative est zéro (pas de corrélation).
    </para>
   </step>
  </procedure>

  <para>
   Des exemples de fonctions d'estimation du coût sont disponibles dans
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>
 </sect1>
</chapter>
