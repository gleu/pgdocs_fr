<?xml version="1.0" encoding="UTF-8"?>

<chapter id="libpq">
 <title><application>libpq</application> &mdash; Bibliothèque C</title>

 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>

 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>

 <para>
  <application>libpq</application> est l'interface de programmation pour les
  applications <acronym>C</acronym> avec <productname>PostgreSQL</productname>.
  <application>libpq</application> est un ensemble de fonctions permettant aux
  programmes clients d'envoyer des requêtes au serveur
  <productname>PostgreSQL</productname> et de recevoir les résultats de ces
  requêtes.
 </para>

 <para>
  <application>libpq</application> est aussi le
  moteur sous-jacent de plusieurs autres interfaces de programmation de
  <productname>PostgreSQL</productname>, comme ceux écrits pour C++, Perl,
  Python, Tcl et <application>ECPG</application>. Donc, certains aspects du comportement
  de <application>libpq</application> seront importants pour vous si vous utilisez un de
  ces paquetages. En particulier, la <xref linkend="libpq-envars"/>, la
  <xref linkend="libpq-pgpass"/> et la <xref linkend="libpq-ssl"/> décrivent le
  comportement que verra l'utilisateur de toute application utilisant
  <application>libpq</application>.
 </para>

 <para>
  Quelques petits programmes sont inclus à la fin de ce chapitre (<xref
  linkend="libpq-example"/>) pour montrer comment écrire des programmes
  utilisant <application>libpq</application>. Il existe aussi quelques exemples
  complets d'applications <application>libpq</application> dans le répertoire
  <filename>src/test/examples</filename> venant avec la distribution des
  sources.
 </para>

 <para>
  Les programmes clients utilisant <application>libpq</application> doivent
  inclure le fichier d'en-tête
  <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</primary></indexterm> et
  doivent être lié avec la bibliothèque <application>libpq</application>.
 </para>

 <sect1 id="libpq-connect">
  <title>Fonctions de contrôle de connexion à la base de données</title>

  <para>
   Les fonctions suivantes concernent la réalisation d'une connexion avec un
   serveur <productname>PostgreSQL</productname>. Un programme peut avoir
   plusieurs connexions ouvertes sur des serveurs à un même moment (une raison
   de la faire est d'accéder à plusieurs bases de données). Chaque connexion
   est représentée par un objet
   <structname>PGconn</structname><indexterm><primary>PGconn</primary></indexterm>,
   obtenu avec la fonction <xref linkend="libpq-PQconnectdb"/>, <xref
   linkend="libpq-PQconnectdbParams"/> ou <xref
   linkend="libpq-PQsetdbLogin"/>. Notez que ces fonctions renverront toujours
   un pointeur d'objet non nul, sauf peut-être dans un cas de manque de
   mémoire pour l'allocation de l'objet <structname>PGconn</structname>. La
   fonction <xref linkend="libpq-PQstatus"/> doit être appelée pour vérifier
   le code retour pour une connexion réussie avant de lancer des requêtes via
   l'objet de connexion.

   <warning>
    <para>
     Si des utilisateurs non dignes de confiance ont accès à une base de
     données qui n'a pas adopté une <link
     linkend="ddl-schemas-patterns">méthode sécurisée d'utilisation des
     schémas</link>, commencez chaque session en supprimant du
     <varname>search_path</varname> les schémas accessibles par tout le monde.
     Il est possible de configurer le paramètre <literal>options</literal> à
     la valeur <literal>-csearch_path=</literal>. Sinon, il est possible
     d'exécuter <literal>PQexec(<replaceable>conn</replaceable>, "SELECT
     pg_catalog.set_config('search_path', '', false)")</literal> tout de suite
     après la connexion. Cette considération n'est pas spécifique à la
     <application>libpq</application>&nbsp;; elle s'applique à chaque
     interface permettant d'exécuter des commandes SQL arbitraires.
    </para>
   </warning>

   <warning>
    <para>
     Sur Unix, la création d'un processus via l'appel système fork() avec des
     connexions libpq ouvertes peut amener à des résultats imprévisibles car
     les processus parent et enfants partagent les même sockets et les mêmes
     ressources du système d'exploitation. Pour cette raison, un tel usage n'est
     pas recommandé, alors qu'exécuter un <function>exec</function> à partir
     du processus enfant pour charger un nouvel exécutable est sûr.
    </para>
   </warning>

   <note>
    <para>
     Sur Windows, il existe un moyen pour améliorer les performances si une
     connexion seule à la base de données est ouverte puis fermée de façon
     répétée. En interne, libpq appelle <function>WSAStartup()</function> et
     <function>WSACleanup()</function> respectivement pour le début et la fin
     de la transaction. <function>WSAStartup()</function> incrémente un
     compteur de référence interne à la bibliothèque Windows.
     Ce compteur est décrémenté par <function>WSACleanup()</function>. Quand le compteur arrive à
     un, appeler <function>WSACleanup()</function> libère toutes les ressources et toutes les DLL
     associées. C'est une opération coûteuse. Pour éviter cela, une application
     peut appeler manuellement <function>WSAStartup()</function> afin que les ressources ne soient
     pas libérées quand la dernière connexion est fermée.
    </para>
   </note>

   <variablelist>
    <varlistentry id="libpq-PQconnectdbParams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</primary></indexterm></term>
     <listitem>
      <para>
       Établit une nouvelle connexion au serveur de base de données.

       <synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
       </synopsis>
      </para>

      <para>
       Cette fonction ouvre une nouvelle connexion à la base de données en
       utilisant les paramètres à partir des deux tableaux terminés par un
       <symbol>NULL</symbol>. Le premier, <literal>keywords</literal>, est
       défini comme un tableau de chaînes, chacune étant un mot-clé. Le second,
       <literal>values</literal>, donne la valeur pour chaque mot-clé.
       Contrairement à <xref linkend="libpq-PQsetdbLogin"/> ci-dessous, l'ensemble
       des paramètres peut être étendu sans changer la signature de la fonction
       donc son utilisation (ou ses versions non bloquantes, à savoir
       <xref linkend="libpq-PQconnectStartParams"/> et
       <function>PQconnectPoll</function>) est recommendée pour les nouvelles
       applications.
      </para>

      <para>
       Les mots clés actuellement reconnus sont listés dans
       <xref linkend="libpq-paramkeywords"/>.
      </para>

      <para>
       Quand <literal>expand_dbname</literal> est différent de zéro, la valeur
       du mot-clé <parameter>dbname</parameter> peut être reconnue comme une
       chaîne de connexion. Seule la première occurrence de
       <parameter>dbname</parameter> est étendue de cette façon, toute valeur
       <parameter>dbname</parameter> suivante est traitée comme un nom de base
       de données. <xref linkend="libpq-connstring"/> fournit plus de détails
       sur les formats possibles de la chaîne de connexion.
      </para>

      <para>
       Les tableaux fournis peuvent être vides pour utiliser tous les
       paramètres par défaut ou peuvent contenir un ou plusieurs paramètres.
       Ils doivent avoir la même longueur. Le traitement stoppera au premier
       élément <symbol>NULL</symbol> découvert dans le tableau
       <literal>keywords</literal>.
      </para>

      <para>
       Si un paramètre vaut NULL ou une chaîne vide, alors la variable
       d'environnement correspondante est vérifiée (voir la <xref
       linkend="libpq-envars"/>). Si elle n'est pas disponible, alors la valeur
       par défaut indiquée est utilisée.
      </para>

      <para>
       En général, les mots-clés sont traités à partir du début de ces
       tableaux dans l'ordre de l'index. L'effet qui en découle est que,
       quand les mots-clés sont répétés, la valeur correspondant au dernier
       traitement est conservée. Du coup, via un placement attentionné du
       mot-clé <parameter>dbname</parameter>, il est possible de déterminer
       ce qui pourrait être surchargé par une chaîne
       <parameter>conninfo</parameter> et ce qui ne le sera pas.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</primary></indexterm></term>
     <listitem>
      <para>
       Établit une nouvelle connexion à un serveur de bases de données.

       <synopsis>
        PGconn *PQconnectdb(const char *conninfo);
       </synopsis>
      </para>

      <para>
       Cette fonction ouvre une nouvelle connexion à la base de données en
       utilisant les paramètres pris à partir de la chaîne
       <literal>conninfo</literal>.
      </para>

      <para>
       La chaîne passée peut être vide pour utiliser tous les paramètres par
       défaut ou elle peut contenir un ou plusieurs paramètres, séparés par
       des espaces blancs. Elle peut aussi contenir une <acronym>URI</acronym>.
       Voir <xref linkend="libpq-connstring"/> pour les détails.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetdbLogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</primary></indexterm></term>
     <listitem>
      <para>
       Crée une nouvelle connexion sur le serveur de bases de données.
       <synopsis>PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
       </synopsis>
      </para>

      <para>
       C'est le prédécesseur de <xref linkend="libpq-PQconnectdb"/> avec un ensemble
       fixe de paramètres. Cette fonction a les mêmes fonctionnalités sauf que les
       paramètres manquants seront toujours initialisés avec leur valeurs par
       défaut. Écrire <symbol>NULL</symbol> ou une chaîne vide pour un de ces
       paramètres fixes dont vous souhaitez utiliser la valeur par défaut.
      </para>

      <para>
       Si <parameter>dbName</parameter> contient un signe <symbol>=</symbol> ou
       a un préfixe <acronym>URI</acronym> de connexion valide,
       il est pris pour une chaîne <parameter>conninfo</parameter> exactement
       de la même façon que si elle était passée à
       <xref linkend="libpq-PQconnectdb"/>, et le reste des paramètres est
       ensuite appliqué comme spécifié dans <xref linkend="libpq-PQconnectdbParams"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</primary></indexterm></term>
     <listitem>
      <para>
       Crée une nouvelle connexion sur le serveur de bases de données.
       <synopsis>PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
       </synopsis>
      </para>

      <para>
       C'est une macro faisant appel à <xref linkend="libpq-PQsetdbLogin"/> avec des
       pointeurs nuls pour les paramètres <parameter>login</parameter> et <parameter>pwd</parameter>.
       Elle est fournie pour la compatibilité avec les très vieux programmes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectStartParams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</primary></indexterm></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</primary></indexterm></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</primary></indexterm></term>
     <listitem>
      <para>
       <indexterm><primary>connexion non bloquante</primary></indexterm>
       Crée une connexion au serveur de bases de données d'une façon non bloquante.
       <synopsis>PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                              int expand_dbname);

        PGconn *PQconnectStart(const char *conninfo);

        PostgresPollingStatusType PQconnectPoll(PGconn *conn);
       </synopsis>
      </para>
      <para>
       Ces trois fonctions sont utilisées pour ouvrir une connexion au serveur de
       bases de données d'une façon telle que le thread de votre application n'est
       pas bloqué sur les entrées/sorties distantes en demandant la connexion. Le
       but de cette approche est que l'attente de la fin des entrées/sorties peut se
       faire dans la boucle principale de l'application plutôt qu'à l'intérieur de
       <xref linkend="libpq-PQconnectdbParams"/> ou <xref linkend="libpq-PQconnectdb"/>,
       et donc l'application peut gérer des opérations en
       parallèle à d'autres activités.
      </para>
      <para>
       Avec <xref linkend="libpq-PQconnectStartParams"/>, la connexion à la base
       de données est faite en utilisant les paramètres à partir des tableaux
       <literal>keywords</literal> et <literal>values</literal>, et contrôlée
       par <literal>expand_dbname</literal>, comme décrit dans
       <xref linkend="libpq-PQconnectdbParams"/>.
      </para>

      <para>
       Avec <function>PQconnectStart</function>, la connexion à la base de
       données est faite en utilisant les paramètres provenant de la chaîne
       <literal>conninfo</literal> comme décrit ci-dessus pour
       <xref linkend="libpq-PQconnectdb"/>.
      </para>

       <para>
        Ni <xref linkend="libpq-PQconnectStartParams"/> ni
        <function>PQconnectStart</function> ni <function>PQconnectPoll</function>
        ne bloqueront, aussi longtemps qu'un certain nombre de restrictions est
        respecté&nbsp;:
        <itemizedlist>
         <listitem>
          <para>
           Le paramètre <literal>hostaddr</literal> doit être utilisé de façon
           appropriée pour empêcher l'exécution de requêtes DNS. Voir la
           documentation de ce paramètre sur <xref
           linkend="libpq-paramkeywords"/> pour plus de détails.
          </para>
         </listitem>

         <listitem>
          <para>
           Si vous appelez <xref linkend="libpq-PQtrace"/>, assurez-vous que l'objet de
           flux dans lequel vous enregistrez les traces ne bloquera pas.
          </para>
         </listitem>

         <listitem>
          <para>
           Assurez-vous que le socket soit dans l'état approprié avant d'appeler
           <function>PQconnectPoll</function>, comme décrit ci-dessous.
          </para>
         </listitem>
        </itemizedlist>
       </para>

       <para>
        Pour commencer une demande de connexion non bloquante, appelez
        <function>PQconnectStart</function> ou
        <xref linkend="libpq-PQconnectStartParams"/>. Si le résultat est nul,
        alors <application>libpq</application> a été incapable d'allouer une
        nouvelle structure <structname>PGconn</structname>. Sinon, un pointeur
        valide vers une structure <structname>PGconn</structname> est renvoyé
        (bien qu'il ne représente pas encore une connexion valide vers la base
        de données). Au retour de <function>PQconnectStart</function>, appelez
        <function>PQstatus(conn)</function>. Si le résultat vaut
        <symbol>CONNECTION_BAD</symbol>, la tentative de connexion a déjà
        échoué, généralement à cause de paramètres de connexion invalides.
       </para>

       <para>
        Si <function>PQconnectStart</function> ou
        <xref linkend="libpq-PQconnectStartParams"/> réussit, la prochaine étape
        est d'appeler souvent <application>libpq</application> de façon à ce
        qu'il continue la séquence de connexion. Utilisez
        <function>PQsocket(conn)</function> pour obtenir le descripteur de
        socket sous la connexion à la base de données. (Attention, ne supposez
        pas que la socket reste identique pour les différents appels à
        <function>PQconnectPoll</function>.) Du coup, une boucle&nbsp;: si le
        dernier retour de <function>PQconnectPoll(conn)</function> est
        <symbol>PGRES_POLLING_READING</symbol>, attendez que la socket soit
        prête pour lire (comme indiqué par <function>select()</function>,
        <function>poll()</function> ou une fonction système similaire). Puis,
        appelez de nouveau <function>PQconnectPoll(conn)</function>. En
        revanche, si le dernier retour de
        <function>PQconnectPoll(conn)</function> est
        <symbol>PGRES_POLLING_WRITING</symbol>, attendez que la socket soit
        prête pour écrire, puis appelez de nouveau
        <function>PQconnectPoll(conn)</function>. À la première itération, si
        vous avez encore à appeler <function>PQconnectPoll</function>,
        continuez comme s'il avait renvoyé
        <symbol>PGRES_POLLING_WRITING</symbol>. Continuez cette boucle jusqu'à
        ce que <function>PQconnectPoll(conn)</function> renvoie
        <symbol>PGRES_POLLING_FAILED</symbol>, indiquant que la procédure de
        connexion a échoué ou <symbol>PGRES_POLLING_OK</symbol>, indiquant le
        succès de la procédure de connexion.
       </para>

       <para>
        À tout moment pendant la connexion, le statut de cette connexion peut
        être vérifié en appelant <xref linkend="libpq-PQstatus"/>. Si le résultat est
        <symbol>CONNECTION_BAD</symbol>, alors la procédure de connexion a échoué&nbsp;;
        si, au contraire, elle renvoie <function>CONNECTION_OK</function>, alors la
        connexion est prête. Ces deux états sont détectables à partir de la valeur
        de retour de <function>PQconnectPoll</function>, décrite ci-dessus. D'autres états
        pourraient survenir lors (et seulement lors) d'une procédure de
        connexion asynchrone. Ils indiquent l'état actuel de la procédure de
        connexion et pourraient être utiles pour fournir un retour à l'utilisateur.
        Ces statuts sont&nbsp;:
       </para>

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
           Attente de la connexion à réaliser.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
           Connexion OK&nbsp;; attente d'un envoi.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
           Attente d'une réponse du serveur.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
           Authentification reçue&nbsp;; attente de la fin du lancement du moteur.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
           Négociation du cryptage SSL.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
           Négociation des paramètres de l'environnement.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-check-writable">
         <term><symbol>CONNECTION_CHECK_WRITABLE</symbol></term>
         <listitem>
          <para>
           Vérification que la connexion est capable de gérer des transactions
           en écriture.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-consume">
         <term><symbol>CONNECTION_CONSUME</symbol></term>
         <listitem>
          <para>
           En train de traiter les messages de réponse restants sur la connexion.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

       <para>
        Notez que, bien que ces constantes resteront (pour maintenir une
        compatibilité), une application ne devrait jamais se baser sur
        l'apparition de ces états dans un ordre particulier, ou leur survenance
        tout court, ou sur le fait que le statut fait partie de ces valeurs
        documentées.
        Une application pourrait faire quelque chose comme
        ça&nbsp;:
        <programlisting>switch(PQstatus(conn))
{
    case CONNECTION_STARTED:
        feedback = "Connexion en cours...";
        break;

    case CONNECTION_MADE:
        feedback = "Connecté au serveur...";
        break;
.
.
.
    default:
        feedback = "Connexion...";
}
        </programlisting>
       </para>

       <para>
        Le paramètre de connexion <literal>connect_timeout</literal> est ignoré lors
        de l'utilisation <function>PQconnectPoll</function>&nbsp;; c'est de la
        responsabilité de l'application de décider quand une période de temps
        excessive s'est écoulée. Sinon, <function>PQconnectStart</function> suivi par
        une boucle <function>PQconnectPoll</function> est équivalent à
        <xref linkend="libpq-PQconnectdb"/>.
       </para>

       <para>
        Notez que quand <function>PQconnectStart</function> ou
        <xref linkend="libpq-PQconnectStartParams"/> renvoient un pointeur non
        NULL, vous devez appeler <xref linkend="libpq-PQfinish"/> quand vous en
        avez fini pour libérer la structure et tout bloc mémoire qui y est
        associé. Ceci doit être fait même si la tentative de connexion échoue
        ou est abandonnée.
       </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie les options de connexion par défaut.
       <synopsis>PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* Mot clé de l'option */
    char   *envvar;    /* Nom de la variable d'environnement équivalente */
    char   *compiled;  /* Valeur par défaut interne */
    char   *val;       /* Valeur actuelle de l'option ou NULL */
    char   *label;     /* Label du champ pour le dialogue de connexion */
    char   *dispchar;  /* Indique comment afficher ce champ
                          dans un dialogue de connexion. Les valeurs sont :
                          ""        Affiche la valeur entrée sans modification
                          "*"       Champ de mot de passe - cache la valeur
                          "D"       Option de débogage - non affiché par défaut
                       */
    int     dispsize;  /* Taille du champ en caractère pour le dialogue */
} PQconninfoOption;
       </synopsis>
      </para>

      <para>
       Renvoie un tableau d'options de connexion. Ceci pourrait être utilisé pour
       déterminer toutes les options possibles de <xref linkend="libpq-PQconnectdb"/>
       et leur valeurs par défaut. La valeur de retour pointe vers un tableau de
       structures <structname>PQconninfoOption</structname> qui se termine avec une
       entrée utilisant un pointeur nul pour <structfield>keyword</structfield>. Le pointeur
       null est renvoyé si la mémoire n'a pas pu être allouée. Notez que les
       valeurs par défaut actuelles (champs <structfield>val</structfield>)
       dépendront des variables d'environnement et d'autres contextes.  Un
       fichier de service manquant ou non valide sera ignoré de manière
       silencieuse. Les demandeurs doivent traiter les données des options de
       connexion en lecture seule.
      </para>

      <para>
       Après le traitement du tableau d'options, libérez-le en le passant à la
       fonction <xref linkend="libpq-PQconninfoFree"/>. Si cela n'est pas fait, un
       petit groupe de mémoire est perdu à chaque appel de
       <xref linkend="libpq-PQconndefaults"/>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie les options de connexion utilisées par une connexion en cours.
       <synopsis>
       PQconninfoOption *PQconninfo(PGconn *conn);
       </synopsis>
      </para>

      <para>
       Renvoie un tableau des options de connexion. Cette fonction peut être
       utilisée pour déterminer les valeurs de toutes les options de
       <xref linkend="libpq-PQconnectdb"/> qui ont été utilisées pour se
       connecter au serveur. La valeur renvoyée pointe vers un tableau de
       structures <structname>PQconninfoOption</structname> qui se termine avec
       une entrée possédant un pointeur <structfield>keyword</structfield> nul.
       Toutes les notes ci-dessus pour <xref linkend="libpq-PQconndefaults"/>
       s'appliquent aussi au résultat de <xref linkend="libpq-PQconninfo"/>.
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-PQconninfoParse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</primary></indexterm></term>
     <listitem>
      <para>
       Renvoit les options de connexions analysées d'après la chaîne de
       connexion fournie.

       <synopsis>
       PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
       </synopsis>
      </para>

      <para>
       Analyse une chaîne de connexion et renvoie les options résultantes
       dans un tableau&nbsp;; renvoit <symbol>NULL</symbol> si un problème a été détecté avec
       la chaîne de connexion. Ceci peut être utilisé pour déterminer les
       options de <xref linkend="libpq-PQconnectdb"/> dans la chaîne de connexion
       fournie. La valeur de retour pointe vers un tableau de structures
       <structname>PQconninfoOption</structname> et termine avec une entrée
       ayant un pointeur <structfield>keyword</structfield> nul.
      </para>

      <para>
       Toutes les options légales seront présentes dans le tableau en résultat
       mais le <literal>PQconninfoOption</literal> pour toute option absente
       de la chaîne de connexion aura sa valeur (<literal>val</literal>)
       configurée à <literal>NULL</literal>&nbsp;; les valeurs par défaut ne
       sont pas utilisées.
      </para>

      <para>
       Si <literal>errmsg</literal> n'est pas <symbol>NULL</symbol>, alors
       <literal>*errmsg</literal> est configuré à <symbol>NULL</symbol> en cas de succès et sinon
       à un message d'erreur (alloué via un appel à <function>malloc</function>) expliquant le
       problèm. (Il est aussi possible pour <literal>*errmsg</literal> d'être
       configuré à <symbol>NULL</symbol> et la fonction de renvoyer <symbol>NULL</symbol>&nbsp;; cela indique un
       cas de mémoire épuisée.)
      </para>

      <para>
       Après avoir traité le tableau des options, libérez-le en le passant à
       <xref linkend="libpq-PQconninfoFree"/>. Si ce n'est pas fait, de la mémoire
       sera perdu à chaque appel à <xref linkend="libpq-PQconninfoParse"/>.
       Réciproquement, si une erreur survient et que <literal>errmsg</literal>
       n'est pas <symbol>NULL</symbol>, assurez-vous de libérer la chaîne d'erreur en utilisant
       <xref linkend="libpq-PQfreemem"/>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</primary></indexterm></term>
     <listitem>
      <para>
       Ferme la connexion au serveur. Libère aussi la mémoire utilisée par l'objet
       <structname>PGconn</structname>.
       <synopsis>void PQfinish(PGconn *conn);
       </synopsis>
      </para>

      <para>
       Notez que même si la connexion au serveur a échoué (d'après l'indication
       de <xref linkend="libpq-PQstatus"/>), l'application devrait appeler
       <xref linkend="libpq-PQfinish"/> pour libérer la mémoire utilisée par l'objet
       <structname>PGconn</structname>. Le pointeur <structname>PGconn</structname> ne doit
       pas être encore utilisé après l'appel à <xref linkend="libpq-PQfinish"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</primary></indexterm></term>
     <listitem>
      <para>
       Réinitialise le canal de communication avec le serveur.
       <synopsis>void PQreset(PGconn *conn);
       </synopsis>
      </para>

      <para>
       Cette fonction fermera la connexion au serveur et tentera le rétablissement
       d'une nouvelle connexion au même serveur en utilisant tous les paramètres
       utilisés précédemment. Ceci pourrait être utile en cas de récupération après
       une perte de connexion.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresetStart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</primary></indexterm></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</primary></indexterm></term>
     <listitem>
      <para>
       Réinitialise le canal de communication avec le serveur d'une façon non
       bloquante.

       <synopsis>
       int PQresetStart(PGconn *conn);

       PostgresPollingStatusType PQresetPoll(PGconn *conn);
       </synopsis>
      </para>

      <para>
       Ces fonctions fermeront la connexion au serveur et tenteront de rétablir
       une nouvelle connexion sur le même serveur, en utilisant tous les paramètres
       précédemment utilisés. Ceci peut être utile pour revenir à un état normal
       après une erreur si une connexion est perdue. Ces fonctions diffèrent de
       <xref linkend="libpq-PQreset"/> (ci-dessus) dans le fait qu'elles agissent
       d'une façon non bloquante. Ces fonctions souffrent des mêmes restrictions
       que <xref linkend="libpq-PQconnectStartParams"/>, <function>PQconnectStart</function>
       et <function>PQconnectPoll</function>.
      </para>

      <para>
       Pour lancer une réinitialisation de la connexion, exécutez
       <xref linkend="libpq-PQresetStart"/>. Si cette fonction 0, la réinitialisation
       a échoué. Si elle renvoie 1, récupérez le résultat de la réinitialisation
       en utilisant <function>PQresetPoll</function> exactement de la même
       façon que vous auriez créé la connexion en utilisant
       <function>PQconnectPoll</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpingParams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQpingParams"/> renvoie le statut du serveur. Elle
       accepte les mêmes paramètres de connexion que ceux de la fonction
       <xref linkend="libpq-PQconnectdbParams"/>, décrite ci-dessus. Néanmoins,
       il n'est pas nécessaire de fournir les bons nom d'utilisateur, mot de
       passe, ou nom de base de données pour obtenir le statut du serveur.
       Néanmoins, si des valeurs incorrectes sont fournies, le serveur
       tracerz une tentative échouée de connexion.

       <synopsis>
       PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
       </synopsis>

       La fonction renvoie une des valeurs suivantes&nbsp;:

       <variablelist>
        <varlistentry id="libpq-PQpingParams-PQPING_OK">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
           Le serveur est en cours d'exécution et semble accepter les
           connexions.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_REJECT">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
           Le serveur est en cours d'exécution mais est dans un état qui
           interdit les connexions (démarrage, arrêt, restauration après
           crash).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_NO_RESPONSE">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
           Le serveur n'a pas pu être contacté. Cela pourrait indiquer que
           le serveur n'est pas en cours d'exécution ou qu'il y a un problème
           avec les paramètres de connexion donnés (par exemple un mauvais
           numéro de port). Cela peut aussi indiquer un problème de connexion
           réseau (par exemple un pare-feu qui bloque la demande de connexion).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_NO_ATTEMPT">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
           Aucune tentative n'a été faite pour contacter le serveur à cause des
           paramètres fournis erronnés ou à cause d'un problème au niveau client
           (par exemple un manque mémoire).
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQping">
     <term><function>PQping</function><indexterm><primary>PQping</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQping"/> renvoie l'état du serveur.  Elle
       accepte les mêmes paramètres de connexion que ceux de la fonction
       <xref linkend="libpq-PQconnectdb"/>, décrite ci-dessus. Néanmoins,
       il n'est pas nécessaire de fournir les bons nom d'utilisateur, mot de
       passe, ou nom de base de données pour obtenir le statut du serveur;
       toutefois, si des valeurs incorrectes sont fournies, le serveur tracera
       une tentative de connexion en échec.

       <synopsis>
       PGPing PQping(const char *conninfo);
       </synopsis>
      </para>

      <para>
       Les valeurs de retour sont les mêmes que pour <xref linkend="libpq-PQpingParams"/>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetsslkeypasshook-openssl">
     <term><function>PQsetSSLKeyPassHook_OpenSSL</function><indexterm><primary>PQsetSSLKeyPassHook_OpenSSL</primary></indexterm></term>
     <listitem>
      <para>
       <function>PQsetSSLKeyPassHook_OpenSSL</function> permet à une
       application de passer outre la <link
       linkend="libpq-ssl-clientcert">gestion par défaut des fichiers clés de
       certificats client</link> de la <application>libpq</application> en
       utilisant <xref linkend="libpq-connect-sslpassword"/> ou une invite
       interactive.

<synopsis>
void PQsetSSLKeyPassHook_OpenSSL(PQsslKeyPassHook_OpenSSL_type hook);
</synopsis>

       L'application passe un pointeur a une fonction callback avec la signature&nbsp;:
<programlisting>
int callback_fn(char *buf, int size, PGconn *conn);
</programlisting>

       que <literal>libpq</literal> appelera <emphasis>à la place
       du</emphasis> gestionnaire de la fonction par défaut
       <function>PQdefaultSSLKeyPassHook_OpenSSL</function>. Le callback devra
       déterminer le mot de passe pour la clé et la copier dans le résultat
       tampon <literal>buf</literal> de taille <literal>size</literal>. La
       chaîne dans <parameter>buf</parameter> doit être terminée par null. Le
       callback doit retourner la longueur du mot de passe stockée dans
       <parameter>buf</parameter> en excluant le caractère terminateur nul. En
       cas d'échec, le callback devra affecter <literal>buf[0] =
       '\0'</literal> et retourner 0. Voir
       <function>PQdefaultSSLKeyPassHook_OpenSSL</function> dans le code
       source de <literal>libpq</literal> pour un exemple.
      </para>

      <para>
       Si l'utilisateur spécifie un emplacement explicite de la clef, son
       chemin sera dans <literal>conn->sslkey</literal> quand le callback
       est appelé. Il sera vide si le chemin de clé par défaut est utilisé.
       Pour les clés qui sont spécifiques au moteur, celui-ci est responsable
       de leurs implémentations qu'elles utilisent le callback mot de passe
       OpenSSL ou qu'elles définissent leur propre gestionnaire.
      </para>

      <para>
       Le callback de l'application peut choisir de déléguer les cas non gérés
       à <function>PQdefaultSSLKeyPassHook_OpenSSL</function>, ou l'appeler en
       premier et essayer autre chose si elle retourne 0, ou complétement la
       passer outre.
      </para>

      <para>
       Le callback <emphasis>ne doit pas</emphasis> éviter le contrôle de flux
       normal avec quelques exceptions, <function>longjmp(...)</function>,
       etc. Il doit retourner normallement.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetsslkeypasshook-openssl">
     <term><function>PQgetSSLKeyPassHook_OpenSSL</function><indexterm><primary>PQgetSSLKeyPassHook_OpenSSL</primary></indexterm></term>
     <listitem>
      <para>
       <function>PQgetSSLKeyPassHook_OpenSSL</function> retourne le point
       d'ancrage de la fonction de mot de passe de clé de certificat client
       courant, ou <literal>NULL</literal> si aucun n'a été affecté.

<synopsis>
PQsslKeyPassHook_OpenSSL_type PQgetSSLKeyPassHook_OpenSSL(void);
</synopsis>
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <sect2 id="libpq-connstring">
   <title>Chaînes de connexion</title>

   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>

   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>

   <para>
    Plusieurs fonctions de la bibliothèque <application>libpq</application>
    analysent une chaîne donnée par l'utilisateur pour obtenir les paramètres
    de connexion. Deux formats sont acceptés pour ces chaînes&nbsp;:
    le format régulier <literal>keyword = value</literal> et le format des
    URI. Les URIs respectent généralement la
    <ulink url="https://tools.ietf.org/html/rfc3986">RFC
    3986</ulink>, sauf que les chaînes de connexions multi hôtes sont
    autorisées, comme décrit ci-dessous.
   </para>

   <sect3>
    <title>Chaînes de connexion clé/valeur</title>

    <para>
     Dans le premier format, chaque configuration de paramètre se présente sous
     la forme <literal>clé = valeur</literal>. Les espaces autour du signe égal
     sont optionnels. Pour écrire une valeur vide ou une valeur contenant des
     espaces, il est nécessaires de l'entourer de guillemets simples, par
     exemple <literal>clé = 'une valeur'</literal>. Les guillemets simples et
     les antislashs compris dans une valeur doivent être échappés par un
     antislash, comme ceci <literal>\'</literal> et ceci <literal>\\</literal>.
    </para>

    <para>
     Example:
     <programlisting>
      host=localhost port=5432 dbname=mabase connect_timeout=10
     </programlisting>
    </para>

    <para>
     Les mots clés reconnus pour les paramètres sont listés dans <xref
     linkend="libpq-paramkeywords"/>.
    </para>
   </sect3>

   <sect3>
    <title>URI de connexion</title>

    <para>
     La forme générale pour une <acronym>URI</acronym> de connexion est&nbsp;:
     <synopsis>
      postgresql://[utilisateur[:mot_de_passe]@][alias_ou_ip][:port][,...][/nom_base][?param1=valeur1&amp;...]
     </synopsis>
    </para>

    <para>
     Le désignateur d'<acronym>URI</acronym> peut être soit
     <literal>postgresql://</literal> soit <literal>postgres://</literal>.
     Chacune des parties de l'<acronym>URI</acronym> est optionnelle. Les
     exemples suivants montrent des syntaxes valides pour
     l'<acronym>URI</acronym>&nbsp;:
     <programlisting>
 postgresql://
 postgresql://localhost
 postgresql://localhost:5433
 postgresql://localhost/ma_base
 postgresql://utilisateur@localhost
 postgresql://utilisateur:secret@localhost
 postgresql://autre@localhost/autre_base?connect_timeout=10&amp;application_name=mon_appli
 postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
     </programlisting>
     Les composants de la partie hiérarchique de l'<acronym>URI</acronym> peuvent
     aussi être donnés comme paramètres. Par exemple&nbsp;:
     <programlisting>
 postgresql:///ma_base?host=localhost&amp;port=5433
     </programlisting>
    </para>

    <para>
     L'<acronym>URI</acronym> de connexion doit être encodée avec <ulink
     url="https://tools.ietf.org/html/rfc3986#section-2.1">percent-encoding</ulink>
     si elle inclut des symboles avec des significations spéciales dans toutes
     les parties. Voici un exemple où un signe égal (<literal>=</literal>) est
     remplacé avec <literal>%3D</literal> et un caractère espace avec
     <literal>%20</literal>&nbsp;:
<programlisting>
postgresql://user@localhost:5433/mydb?options=-c%20synchronous_commit%3Doff
</programlisting>
    </para>

    <para>
     Tout paramètre de connexion ne correspondant pas aux mots clés listés dans
     <xref linkend="libpq-paramkeywords"/> est ignoré et un message d'avertissement
     les concernant est envoyé sur la sortie des erreurs (<filename>stderr</filename>).
    </para>

    <para>
     Pour améliorer la compatibilité avec les <acronym>URI</acronym> des
     connexions, les instances du paramètre <literal>ssl=true</literal> sont
     traduites en <literal>sslmode=require</literal>.
    </para>

    <para>
     La partie host peut être soit un nom d'hôte soit une adresse IP. Pour
     indiquer une adresse IPv6, il est nécessaire de l'englober dans des
     crochets&nbsp;:
     <synopsis>
      postgresql://[2001:db8::1234]/database
     </synopsis>
    </para>

    <para>
     Le composant host est interprété de la façon décrite pour le paramètre
     <xref linkend="libpq-connect-host"/>. En particulier, une connexion par
     socket de domaine Unix est choisi si la partie host est vide ou ressemble à un
     nom de chemin absolu. Dans tous les autres cas, une connexion TCP/IP est
     démarrée. Cependant, notez que le slash est un caractère réservé dans la
     partie hiérarchique de l'URI. Donc, pour indiquer un répertoire non standard
     pour la socket de domaine Unix, il faut soit omettre d'indiquer le paramètre
     host dans l'URI, soit l'indiquer en tant que paramètre, soit encoder le
     chemin dans le composant host de l'URI&nbsp;:
     <programlisting>
 postgresql:///dbname?host=/var/lib/postgresql
 postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
     </programlisting>
    </para>

   <para>
    Il est possible de spécifier plusieurs composants hôte, chacun avec un port
    optionnel, dans une seule URI. Une URI de la forme
    <literal>postgresql://host1:port1,host2:port2,host3:port3/</literal> est
    équivalent à une chaîne de connexion de la forme
    <literal>host=host1,host2,host3 port=port1,port2,port3</literal>.  Chaque
    hôte sera testé à son tour jusqu'à ce qu'une connexion soit établie avec
    succès.
   </para>
   </sect3>

   <sect3 id="libpq-multiple-hosts">
    <title>Spécifier plusieurs hôtes</title>

    <para>
     Il est possible de spécifier plusieurs hôtes où se connecter. Ils sont
     essayés dans l'ordre donné. Dans un format clé/valeur, les options
     <literal>host</literal>, <literal>hostaddr</literal>, and
     <literal>port</literal> acceptent une liste de valeurs séparées par une
     virgule. Le même nombre d'éléments doit être donné dans chaque option qui
     est spécifiée
     pour que le premier élément dans <literal>hostaddr</literal> au premier
     nom d'hôte, le second <literal>hostaddr</literal> correspond au second
     nom d'hôte, et ainsi de suite. Seule exception pour l'option
     <literal>port</literal>, si un seul port est spécifié, il est utilisé
     pour tous les hôtes.
    </para>

    <para>
     Dans le format de connexion URI, vous pouvez lister plusieurs paires
     <literal>hote:port</literal> séparées par des virgules dans le composant
     <literal>host</literal> de l'URI.
    </para>

    <para>
     Quelque soit le format, un simple nom
     d'hôte peut aussi se traduire en plusieurs adresses réseau. Un exemple
     habituel est un hôte qui a à la fois une adresse IPv4 et une adresse
     IPv6.
    </para>

    <para>
     Quand plusieurs hôtes sont indiqués ou quand un nom d'hôte est converti
     en plusieurs adresses, tous les hôtes et adresses seront essayés dans
     l'ordre jusqu'à ce qu'une connexion réussisse. Si aucun des hôtes ne peut
     être atteint, la connexion échoue. Si la connexion réussit mais que
     l'authentification échoue, les autres hôtes de la liste ne seront pas
     testés.
    </para>

    <para>
     Si un fichier de mots de passe est utilisé, vous pouvez avoir plusieurs
     mots de passe pour des hôtes différents. Toutes les autres options de
     connexion sont identiques pour chaque hôte de la liste. Par exemple, il n'est pas
     possible d'indiquer un nom d'utilisateur différent pour les différents
     hôtes.
    </para>
   </sect3>
  </sect2>

  <sect2 id="libpq-paramkeywords">
   <title>Mots clés de la chaîne de connexion</title>

   <para>
    Les mots clés actuellement reconnus sont&nbsp;:

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
       <para>
        Nom de l'hôte où se connecter.<indexterm><primary>host
        name</primary></indexterm> Si un nom d'hôte ressemble à un nom de chemin absolu, il
        spécifie une communication par domaine Unix plutôt qu'une communication
        TCP/IP&nbsp;; la valeur est le nom du répertoire où le fichier socket
        est stocké. (Sur Unix, un chemin absolu commence par un slash. Sur windows, les
        chemins débutant par la lettre du lecteur sont aussi reconnus.)  Par défaut, quand
        <literal>host</literal> n'est pas spécifié ou est vide, il s'agit d'une
        communication par socket de domaine Unix<indexterm><primary>socket de
        domaine Unix</primary></indexterm> dans <filename>/tmp</filename> (ou
        tout autre répertoire de socket spécifié lors de la construction de
        <productname>PostgreSQL</productname>). Sur Windows et sur les
        machines sans socket de domaine Unix, la valeur par défaut est de se
        connecter à <literal>localhost</literal>.
       </para>
       <para>
        Une liste de noms d'hôtes séparés par des virgules est aussi acceptée,
        auquel cas chaque nom d'hôte est testé dans l'ordre&nbsp;;
        un élément vide dans la liste implique le comportement par
        défaut comme décrit plus haut. Voir
        <xref linkend="libpq-multiple-hosts"/> pour les détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <para>
        Adresse IP numérique de l'hôte de connexion. Elle devrait être au format
        d'adresse standard IPv4, par exemple <literal>172.28.40.9</literal>. Si votre
        machine supporte IPv6, vous pouvez aussi utiliser ces adresses. La
        communication TCP/IP est toujours utilisée lorsqu'une chaîne non vide est
        spécifiée pour ce paramètre.
        Si ce paramètre n'est pas spécifié, la valeur pour <literal>host</literal>
        sera résolue pour trouver l'adresse IP correspondante &mdash;
        ou, si <literal>host</literal> spécifie une adresse IP, cette valeur sera
        utilisée directement.
       </para>
       <para>
        Utiliser <literal>hostaddr</literal>
        permet à l'application d'éviter une résolution de nom, ce qui
        pourrait être important dans les applications avec des
        contraintes de temps. Cependant, un nom d'hôte est requis pour les méthodes
        d'authentification GSSAPI ou SSPI, ainsi que pour la
        vérification de certificat SSL en <literal>verify-full</literal>.
        Les règles suivantes sont observées&nbsp;:
        <itemizedlist>
         <listitem>
          <para>
           Si <literal>host</literal> est indiqué sans
           <literal>hostaddr</literal>, une résolution du nom de l'hôte est
           lancée. (Si vous utilisez <function>PQconnectPoll</function>, la
           recherche survient quand <function>PQconnectPoll</function>
           considère le nom d'hôte pour la première fois, et cela pourrait
           être la cause d'un blocage de <function>PQconnectPoll</function>
           pendant une bonne durée de temps.)
          </para>
         </listitem>
         <listitem>
          <para>
           Si <literal>hostaddr</literal> est indiqué sans
           <literal>host</literal>, la valeur de
           <literal>hostaddr</literal> fournit l'adresse réseau de
           l'hôte. La tentative de connexion échouera si la méthode
           d'authentification nécessite un nom d'hôte.
          </para>
         </listitem>
         <listitem>
          <para>
           Si <literal>host</literal> et <literal>hostaddr</literal>
           sont spécifiés, la valeur de <literal>hostaddr</literal>
           donne l'adresse réseau de l'hôte. La valeur de
           <literal>host</literal> est ignorée sauf si la méthode
           d'authentification la réclame, auquel cas elle sera
           utilisée comme nom d'hôte.
          </para>
         </listitem>
        </itemizedlist>
        Notez que l'authentification a de grandes chances d'échouer si
        <literal>host</literal> n'est pas le nom du serveur
        à l'adresse réseau <literal>hostaddr</literal>. Et quand
        <literal>host</literal> et <literal>hostaddr</literal> sont tous deux
        spécifiés, seul <literal>host</literal> est utilisé pour identifier
        la connexion dans un fichier de mots de passe (voir la <xref
        linkend="libpq-pgpass"/>).
       </para>
       <para>
        Une liste d'adresses <literal>hostaddr</literal> séparées par des
        virgules est aussi acceptée, auquel cas chaque hôte est essayé dans cet
        ordre. Un élément vide dans la liste mène à l'utilisation du nom d'hôte
        correspondant, ou, s'il est vide aussi, de la valeur par défaut.
        Voir <xref linkend="libpq-multiple-hosts"/> pour plus de détails.
       </para>
       <para>
        Sans un nom ou une adresse d'hôte, <application>libpq</application> se
        connectera en utilisant un socket local de domaine Unix. Sur Windows et
        sur des machines
        sans sockets de domaine Unix, il tentera une connexion sur
        <literal>localhost</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-port" xreflabel="port">
      <term><literal>port</literal></term>
      <listitem>
       <para>
        Numéro de port pour la connexion au serveur ou extension du nom de
        fichier pour des connexions de domaine Unix.
        <indexterm><primary>port</primary></indexterm>
        Si plusieurs hôtes sont indiquées dans les paramètres
        <literal>host</literal> ou <literal>hostaddr</literal>,
        ce paramètre spécifie une liste de ports séparés par des virgules
        et de même taille que la liste
        des hôtes, ou bien il peut préciser un seul port à tester pour tous les hôtes.
        Une chaîne vide, ou un élément vide de la liste, indique le numéro de
        port par défaut établi à la compilation de
        <productname>PostgreSQL</productname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
       <para>
        Nom de la base de données. Par défaut, la même que le nom utilisateur.
        Dans certains contextes, la valeur est vérifiée pour les formats
        étendus&nbsp;; voir <xref linkend="libpq-connstring"/> pour plus
        d'informations.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
       <para>
        Nom de l'utilisateur <productname>PostgreSQL</productname> qui se
        connecte.
        Par défaut, il s'agit du même nom que l'utilisateur système lançant
        l'application.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
       <para>
        Mot de passe à utiliser si le serveur demande une authentification par
        mot de passe.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-passfile" xreflabel="passfile">
      <term><literal>passfile</literal></term>
      <listitem>
      <para>
       Spécifie le nom du fichier utilisé pour stocker les mots de passe
       (voir <xref linkend="libpq-pgpass"/>).
       La valeur par défaut est <filename>~/.pgpass</filename>, ou
       <filename>%APPDATA%\postgresql\pgpass.conf</filename> sur Microsoft
       Windows. (Aucune erreur n'est levée si le fichier n'existe pas.)
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-channel-binding" xreflabel="channel_binding">
      <term><literal>channel_binding</literal></term>
      <listitem>
      <para>
        Cette option contrôle l'utilisation cliente de la liaison de canal.
        Une valeur <literal>require</literal> signifie que la connexion doit
        toujours employer la liaison de canal, <literal>prefer</literal> signifie
        que le client doit choisir la liaison de canal si disponible, et
        <literal>disable</literal> empêche l'utilisation de liaison de canal.
        Le défaut est <literal>prefer</literal> si <productname>PostgreSQL</productname>
        est compilé avec le support SSL.

      </para>
      <para>
        La liaison de canal est une méthode permettant au serveur de s'authentifier
        vers un client. Elle est seulement supportée sur des connexions SSL avec
        <productname>PostgreSQL</productname> 11 ou des versions ultérieures utilisant
        la méthode d'authentification <literal>SCRAM</literal>.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
       <para>
        Temps d'attente maximum lors d'une connexion, en secondes (écrit sous la
        forme d'un entier décimal, par exemple <literal>10</literal>). La
        valeur zéro, une valeur négative ou sans valeur indique une attente
        infinie. Le délai minimal autorisé est 2 secondes, de ce fait la
        valeur <literal>1</literal> est interprétée comme <literal>2</literal>.
        Ce délai s'applique séparément pour chaque nom d'hôte ou adresse IP.
        Par exemple, si vous indiquez deux hôtes et que le paramètre
        <literal>connect_timeout</literal> vaut 5, chaque hôte sera en timeout
        si aucune connexion n'est réalisée en 5 secondes, donc le temps total
        passé à attendre une connexion peut monter jusqu'à 10 secondes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
       <para>
        Ceci configure le paramètre <varname>client_encoding</varname>
        pour cette connexion. En plus des valeurs acceptées par
        l'option correspondante du serveur, vous pouvez utiliser
        <literal>auto</literal> pour déterminer le bon encodage à
        partir de la locale courante du client (variable
        d'environnement <envar>LC_CTYPE</envar> sur les systèmes Unix).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <para>
        Spécifie les options en ligne de commande à envoyer au serveur à
        l'exécution. Par exemple, en le configurant à <literal>-c
         geqo=off</literal>, cela configure la valeur de la session
        pour le paramètre <varname>geqo</varname> à
        <literal>off</literal>. Les espaces à l'intérieur de cette
        chaîne sont considérés comme séparateurs d'arguments,
        sauf si ils sont échappés avec le caractère d'échappement
        <literal>\</literal>&nbsp;; écrivez <literal>\\</literal> pour obtenir
        le caractère d'échappement lui-même.
        Pour une discussion détaillée des options
        disponibles, voir <xref linkend="runtime-config"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <para>
        Précise une valeur pour le paramètre de configuration <xref
        linkend="guc-application-name"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <para>
        Indique une valeur de secours pour le paramètre de configuration
        <xref linkend="guc-application-name"/>. Cette valeur sera utilisée
        si aucune valeur n'est donnée à <literal>application_name</literal>
        via un paramètre de connexion ou la variable d'environnement
        <literal>PGAPPNAME</literal>.
        L'indication d'un nom de secours est utile pour les programmes
        outils génériques qui souhaitent configurer un nom d'application
        par défaut mais permettent sa surcharge par l'utilisateur.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <para>
        Contrôle si les paramètres TCP keepalives côté client sont utilisés.
        La valeur par défaut est de 1, signifiant ainsi qu'ils sont
        utilisés. Vous pouvez le configurer à 0, ce qui aura pour effet de
        les désactiver si vous n'en voulez pas. Ce paramètre est ignoré
        pour les connexions réalisées via un socket de domaine Unix.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <para>
        Contrôle le nombre de secondes d'inactivité après lequel TCP doit
        envoyer un message keepalive au server. Une valeur de zéro utilise
        la valeur par défaut du système. Ce paramètre est ignoré pour les
        connexions réalisées via un socket de domaine Unix ou si les
        paramètres keepalives sont désactivés. Ce paramètre est uniquement
        supporté sur les systèmes où les options
        <symbol>TCP_KEEPIDLE</symbol> ou une option socket équivalente
        sont disponibles et sur Windows&nbsp;; pour les autres systèmes,
        ce paramètre n'a pas d'effet.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <para>
        Contrôle le nombre de secondes après lequel un message TCP
        keepalive doit être retransmis si le serveur ne l'a pas acquitté.
        Une valeur de zéro utilise la valeur par défaut du système. Ce
        paramètre est uniquement supporté sur les systèmes où l'option
        <symbol>TCP_KEEPINTVL</symbol> ou une option socket équivalente est
        disponible et sur Windows&nbsp;;
        pour les autres systèmes, ce paramètre n'a pas d'effet.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <para>
        Contrôle le nombre de messages TCP keepalive pouvant être perdus
        avant que la connexion du client au serveur ne soit considérée
        comme perdue. Une valeur de zéro utilise la valeur par défaut du
        système. Ce paramètre est uniquement supporté sur les systèmes où
        l'option <symbol>TCP_KEEPCNT</symbol> ou une option socket équivalente
        est disponible et sur
        Windows&nbsp;; pour les autres systèmes, ce paramètre n'a pas
        d'effet.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-tcp-user-timeout" xreflabel="tcp_user_timeout">
      <term><literal>tcp_user_timeout</literal></term>
      <listitem>
       <para>
        Contrôle le nombre de millisecondes durant lesquelles les
        données transmises peuvent rester non acquittées avant que la
        connexion soit fermée de force.
        Une valeur à zéro indique d'utiliser la valeur par défaut du
        système. Ce paramètre est ignoré pour les connexions initiées
        via socket de domaine Unix.
        Il est seulement pris en charge sur les systèmes où
        <symbol>TCP_USER_TIMEOUT</symbol> est disponible&nbsp;; sur les autres systèmes,
        il n'a pas d'effet.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
       <para>
        Ignoré (autrefois, ceci indiquait où envoyer les traces de débogage du
        serveur).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-replication" xreflabel="replication">
      <term><literal>replication</literal></term>
      <listitem>
      <para>
       Cette option détermine si la connexion doit utiliser le protocole de
       réplication au lieu du protocole normal.
       C'est ce qu'utilisent les connexions de réplication de PostgreSQL, ainsi
       que des outils comme <application>pg_basebackup</application>, mais il
       peut aussi être utilisé par des applications tierces. Pour une description
       du protocole de réplication, consulter
       <xref linkend="protocol-replication"/>
      </para>

      <para>
       Les valeurs suivantes, non sensibles à la casse, sont supportées&nbsp;:
       <variablelist>
        <varlistentry>
         <term>
          <literal>true</literal>, <literal>on</literal>,
          <literal>yes</literal>, <literal>1</literal>
         </term>
         <listitem>
          <para>
           La connexion passe en mode réplication physique.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>database</literal></term>
         <listitem>
          <para>
           La connexion passe en mode réplication logique, se connectant à la
           base spécifiée par le paramètre <literal>dbname</literal>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>false</literal>, <literal>off</literal>,
          <literal>no</literal>, <literal>0</literal>
         </term>
         <listitem>
          <para>
           On utilise la connexion habituelle, ce qui est le comportement par
           défaut.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <para>
       En mode réplication physique ou logique, seul le protocole simple
       peut être utilisé.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gssencmode" xreflabel="gssencmode">
      <term><literal>gssencmode</literal></term>
      <listitem>
       <para>
        Cette option détermine si une connexion TCP/IP sécurisée avec
        <acronym>GSS</acronym> sera négociée avec le serveur, et si oui avec
        quelle priorité. Il y a trois modes&nbsp;:

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            essaie uniquement une connexion non chiffrée avec <acronym>GSSAPI</acronym>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (par défaut)</term>
          <listitem>
           <para>
            si des informations d'authentification <acronym>GSSAPI</acronym> sont présentes
            (c'est-à-dire, dans un cache d'authentification), essaie d'abord une connexion
            chiffrée avec <acronym>GSSAPI</acronym>&nbsp;; si elle échoue ou qu'il n'y a
            pas les informations d'authentification, essaie une connexion non chiffrée
            avec <acronym>GSSAPI</acronym>. C'est le comportement par défaut quand
            <productname>PostgreSQL</productname> a été compilé avec le support
            de <acronym>GSSAPI</acronym>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            essaie uniquement une connexion chiffrée avec <acronym>GSSAPI</acronym>.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <para>
        <literal>gssencmode</literal> est ignoré pour les connexions par socket
        du domaine Unix. Si <productname>PostgreSQL</productname> est compilé
        sans le support de GSSAPI, l'utilisation de l'option <literal>require</literal>
        provoquera une erreur, alors que <literal>prefer</literal> sera acceptée
        mais, dans ce cas, <application>libpq</application> n'essaiera pas d'initier
        une connexion chiffrée avec <acronym>GSSAPI</acronym>.
        <indexterm><primary>GSSAPI</primary><secondary sortas="libpq">avec
        libpq</secondary></indexterm>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       <para>
        Cette option détermine si ou avec quelle priorité une connexion
        TCP/IP <acronym>SSL</acronym> sécurisée sera négociée avec le serveur.
        Il existe six modes&nbsp;:
        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            essaie seulement une connexion non <acronym>SSL</acronym>
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
            essaie en premier lieu une connexion non
            <acronym>SSL</acronym>&nbsp;; si cette tentative échoue, essaie
            une connexion <acronym>SSL</acronym>
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (par défaut)</term>
          <listitem>
           <para>
            essaie en premier lieu une connexion
            <acronym>SSL</acronym>&nbsp;; si cette tentative échoue, essaie
            une connexion non <acronym>SSL</acronym>
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            essaie seulement une connexion <acronym>SSL</acronym>.
            Si un certificat racine d'autorité (<acronym>CA</acronym>)
            est présent, vérifie le certificat de la même façon que si
            <literal>verify-ca</literal> était spécifié
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
            essaie seulement une connexion <acronym>SSL</acronym> et
            vérifie que le certificat client est créé par une autorité de
            certification (<acronym>CA</acronym>) de confiance
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
            essaie seulement une connexion <acronym>SSL</acronym>,
            vérifie que le certificat client est créé par un
            <acronym>CA</acronym> de confiance et que le nom du serveur
            correspond bien à celui du certificat
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <para>
        Voir <xref linkend="libpq-ssl"/> pour une description détaillée du
        fonctionnement de ces options.
       </para>

       <para>
        <literal>sslmode</literal> est ignoré pour la communication par
        socket de domaine Unix.
        Si <productname>PostgreSQL</productname> est compilé sans le support
        de SSL, l'utilisation des options <literal>require</literal>,
        <literal>verify-ca</literal> et
        <literal>verify-full</literal> causera
        une erreur, alors que les options <literal>allow</literal> et
        <literal>prefer</literal> seront acceptées, bien qu'en fait
        <application>libpq</application> n'essaiera pas de négocier une
        connexion <acronym>SSL</acronym>.
        <indexterm>
         <primary>SSL</primary>
         <secondary sortas="libpq">avec libpq</secondary>
        </indexterm>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <para>
        Cette option est obsolète et remplacée par l'option <literal>sslmode</literal>.
       </para>

       <para>
        Si initialisée à 1, une connexion <acronym>SSL</acronym> au serveur est
        requise (ce qui est équivalent à un <literal>sslmode</literal>
        <literal>require</literal>). <application>libpq</application> refusera alors de se
        connecter si le serveur n'accepte pas une connexion
        <acronym>SSL</acronym>. Si initialisée à 0 (la valeur par défaut),
        <application>libpq</application> négociera le type de connexion avec le serveur
        (équivalent à un <literal>sslmode</literal> <literal>prefer</literal>). Cette option
        est seulement disponible si <productname>PostgreSQL</productname> est compilé avec
        le support SSL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <para>
        Si ce paramètre vaut 1, les données envoyées sur des connexions SSL
        seront compressées. S'il vaut 0, la compression sera désactivée. Le
        défaut est 0. Ce paramètre est ignoré pour une connexion sans SSL.
       </para>

       <para>
        De nos jours, la compression SSL est considérée non sûre et son
        usage n'est plus recommandé. <productname>OpenSSL</productname> 1.1.0
        désactive la compression par défaut, et de nombreux systèmes
        d'exploitation la désactive aussi dans des versions précédentes,
        donc activer ce paramètre n'aura aucun effet si le serveur n'accepte
        pas la compression.
       </para>

       <para>
        Si la sécurité n'est pas un souci majeur, la compression peut améliorer
        le débit si le réseau est le goulot d'étranglement. Désactiver la
        compression peut améliorer le temps de réponse et le débit si le
        processeur est le facteur limitant.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <para>
        Ce paramètre indique le nom du fichier du certificat SSL client,
        remplaçant le fichier par défaut,
        <filename>~/.postgresql/postgresql.crt</filename>. Ce paramètre
        est ignoré si la connexion n'utilise pas SSL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <para>
        Ce paramètre indique l'emplacement de la clé secrète utilisée pour
        le certificat client. Il peut soit indiquer un nom de fichier qui
        sera utilisé à la place du fichier
        <filename>~/.postgresql/postgresql.key</filename> par défaut, soit
        indiquer une clé obtenue par un <quote>moteur</quote> externe
        (les moteurs sont des modules chargeables
        d'<productname>OpenSSL</productname>). La spécification d'un moteur
        externe devrait consister en un nom de moteur et un identifiant de
        clé spécifique au moteur, les deux séparés par une virgule. Ce paramètre
        est ignoré si la connexion n'utilise pas SSL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslpassword" xreflabel="sslpassword">
      <term><literal>sslpassword</literal></term>
      <listitem>
       <para>
        Ce paramètre définit le mot de passe pour la clé secrète spécifiée
        dans <literal>sslkey</literal>, permettant aux clés de certificat
        privé du client d'être stockées sous format chiffré sur disque même
        quand la saisie interactive de passphrase n'est pas pratique.
       </para>
       <para>
        Spécifier ce paramètre avec toute valeur non vide supprime l'invite de
        saisie <literal>Enter PEM pass phrase:</literal> que OpenSSL émet par
        défaut quand une clé de certificat client chiffrée est fournie à
        <literal>libpq</literal>.
       </para>
       <para>
        Si la clé est non chiffrée, ce paramètre est ignoré. Le paramètre n'a
        pas d'effet sur les clés spécifiée par les moteurs OpenSSL à moins que
        le moteur utilise le mécanisme de callback de mot de passe OpenSSL
        pour les invites de saisie.
       </para>
       <para>
        Il n'y a pas de variable d'environment équivalente pour cette option,
        et aucune possibilité pour la déterminer dans
        <filename>.pgpass</filename>. Elle peut être utilisée dans un fichier
        de service de définition de connexion. Les utilisateurs avec des
        usages plus sophistiqués devraient considérer l'utilisation des
        moteurs OpenSSL et outils comme PKCS#11 ou les périphériques de
        déchargement de crypto USB.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <para>
        Ce paramètre indique le nom d'un fichier contenant le ou les
        certificats de l'autorité de certification SSL
        (<acronym>CA</acronym>). Si le fichier existe, le certificat du
        serveur sera vérifié. La signature devra appartenir à une de ces
        autorités. La valeur par défaut est
        <filename>~/.postgresql/root.crt</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <para>
        Ce paramètre indique le nom du fichier de la liste de révocation
        du certificat SSL. Les certificats listés dans ce fichier, s'il
        existe, seront rejetés lors d'une tentative d'authentification
        avec le certificat du serveur. La valeur par défaut
        est <filename>~/.postgresql/root.crl</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <para>
        Ce paramètre indique le nom d'utilisateur du serveur auprès
        du système d'exploitation, par exemple
        <literal>requirepeer=postgres</literal>. Lors d'une connexion
        par socket de domaine Unix, si ce paramètre est configuré, le
        client vérifie au début de la connexion que le processus
        tourne sous le nom d'utilisateur indiqué&nbsp;;
        dans le cas contraire, la connexion échoue avec une
        erreur. Ce paramètre peut être utilisé pour fournir une
        authentification serveur similaire à celle disponible pour les
        certificats SSL avec les connexions TCP/IP. (Notez que, si
        la socket de domaine Unix est dans <filename>/tmp</filename>
        ou tout espace autorisé en écriture pour tout le monde,
        n'importe quel utilisateur peut y mettre un serveur en écoute.
        Utilisez ce paramètre pour vous assurer que vous êtes connecté à
        un serveur exécuté par un utilisateur de confiance.) Cette
        option est seulement supportée par les plateformes où
        la méthode d'authentification <literal>peer</literal>
        est disponible&nbsp;; voir <xref linkend="auth-peer"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-ssl-min-protocol-version" xreflabel="ssl_min_protocol_version">
      <term><literal>ssl_min_protocol_version</literal></term>
      <listitem>
       <para>
        Ce paramètre spécifie la version minimale de protocole SSL/TLS pour
        permettre la connexion. Les valeurs valides sont
        <literal>TLSv1</literal>, <literal>TLSv1.1</literal>,
        <literal>TLSv1.2</literal> et <literal>TLSv1.3</literal>. Les
        protocoles supportés dépendent de la version utilisée de
        <productname>OpenSSL</productname>, les plus anciennes versions ne
        supportant pas les versions de protocole les plus modernes. S'il n'est
        pas indiqué, la valeur par défaut <literal>TLSv1.2</literal>, ce qui
        satisfait les bonnes pratiques de l'industrie lors de l'écriture de ce
        document.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-ssl-max-protocol-version" xreflabel="ssl_max_protocol_version">
      <term><literal>ssl_max_protocol_version</literal></term>
      <listitem>
       <para>
        Ce paramètre spécifie la version maximale de protocole SSL/TLS pour permettre
        la connexion. Les valeurs valides sont <literal>TLSv1</literal>,
        <literal>TLSv1.1</literal>, <literal>TLSv1.2</literal> et
        <literal>TLSv1.3</literal>. Les protocoles supportés dépendent de la
        version utilisée de <productname>OpenSSL</productname>, les anciennes versions
        ne supportant pas les versions les plus modernes du protocole. S'il n'est pas
        affecté, ce paramètre est ignoré et la connexion utilisera la version
        maximale du protocole définie par le backend, si elle existe. Affecter une
        version maximale du protocole est principalement utile pour tester ou si
        certains composants ont des problèmes à utiliser un protocole plus récent.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <para>
        Nom du service Kerberos à utiliser lors de l'authentification avec
        GSSAPI. Il doit correspondre avec le nom du service spécifié dans
        la configuration du serveur pour que l'authentification Kerberos puisse
        réussir. (Voir aussi la <xref linkend="gssapi-auth"/>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <para>
        Bibliothèque GSS à utiliser pour l'authentification GSSAPI.
        Ce paramètre est actuellement ignoré, sauf sur les versions Windows
        qui incluent la prise en charge de GSSAPI et de SSPI. Dans ce cas,
        configurer ce paramètre à <literal>gssapi</literal> pour amener la
        libpq à utiliser la bibliothèque GSSAPI pour l'authentification au
        lieu de SSPI par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <para>
        Nom du service à utiliser pour des paramètres supplémentaires. Il spécifie
        un nom de service dans <filename>pg_service.conf</filename> contenant
        des paramètres de connexion supplémentaires. Ceci permet aux
        applications de spécifier uniquement un nom de service pour que les
        paramètres de connexion puissent être maintenus de façon centralisée.
        Voir <xref linkend="libpq-pgservice"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-target-session-attrs" xreflabel="target_session_attrs">
      <term><literal>target_session_attrs</literal></term>
      <listitem>
       <para>
        Si ce paramètre est positionné à <literal>read-write</literal>, seule
        une connexion dans laquelle les transactions en lecture/écriture sont
        acceptées par défaut est considéré comme acceptable. La requête
        <literal>SHOW transaction_read_only</literal> sera envoyée à chaque
        connexion réussie; si elle retourne <literal>on</literal>, la connexion
        sera fermée. Si plusieurs hôtes étaient spécifiés dans la chaîne de
        connexion, chaque serveur restant sera testé tout comme si la tentative
        de connexion avait échouée.  La valeur par défaut pour ce paramètre,
        <literal>any</literal>, considère toutes les connexions comme
        acceptables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

   </para>
  </sect2>

 </sect1>

 <sect1 id="libpq-status">
  <title>Fonctions de statut de connexion</title>

  <para>
   Ces fonctions sont utilisées pour interroger le statut d'un objet de
   connexion existant.
  </para>

  <tip>
   <para>
    <indexterm><primary>libpq-fe.h</primary></indexterm>
    <indexterm><primary>libpq-int.h</primary></indexterm>
    Les développeurs d'application <application>libpq</application> devraient être
    attentif à maintenir l'abstraction <structname>PGconn</structname>.
    Utilisez les fonctions d'accès décrites ci-dessous pour obtenir le
    contenu de <structname>PGconn</structname>.
    Référencer les champs internes de <structname>PGconn</structname> en utilisant
    <filename>libpq-int.h</filename> n'est pas recommandé parce qu'ils sont sujets
    à modification dans le futur.
   </para>
  </tip>

  <para>
   Les fonctions suivantes renvoient les valeurs des paramètres utilisés
   pour la connexion. Ces valeurs sont fixes pour la durée de vie de la
   connexion. Si une chaîne de connexion multi-hôtes est utilisée, les valeurs
   de <xref linkend="libpq-PQhost"/>, <xref linkend="libpq-PQport"/> et <xref
   linkend="libpq-PQpass"/> peuvent changer si une nouvelle connexion est
   établie en utilisant le même objet <structname>PGconn</structname>. Les
   autres valeurs sont figées pour la durée de vie de l'objet
   <structname>PGconn</structname>.

   <variablelist>
    <varlistentry id="libpq-PQdb">
     <term><function>PQdb</function><indexterm><primary>PQdb</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le nom de la base de données de la connexion.
       <synopsis>char *PQdb(const PGconn *conn);
       </synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQuser">
     <term><function>PQuser</function><indexterm><primary>PQuser</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le nom d'utilisateur utilisé pour la connexion.
       <synopsis>char *PQuser(const PGconn *conn);
       </synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpass">
     <term><function>PQpass</function><indexterm><primary>PQpass</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le mot de passe utilisé pour la connexion.
       <synopsis>char *PQpass(const PGconn *conn);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQpass"/> retournera soit le mot de passe spécifié dans
       les paramètres de connexion, soit, s'il n'y en avait pas, le mot
       de passe obtenu depuis le <link linkend="libpq-pgpass">fichier de mots de
       passe</link>. Dans ce dernier cas, si plusieurs hôtes étaient spécifiés
       dans les paramètres de connexion, il n'est pas possible de se fier au
       résultat de <xref linkend="libpq-PQpass"/> jusqu'à l'établissement de la
       connexion. Le statut de la connexion peut être vérifié avec la
       fonction <xref linkend="libpq-PQstatus"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQhost">
     <term><function>PQhost</function><indexterm><primary>PQhost</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le nom d'hôte du serveur utilisé pour la connexion. Cela peut
       être un nom d'hôte, une adresse IP ou un chemin de répertoire si la
       connexion est réalisée via un socket Unix. (Le cas du chemin se distingue
       par le fait que ce sera toujours un chemin absolu commençant par
       <literal>/</literal>.)
       <synopsis>char *PQhost(const PGconn *conn);
       </synopsis>
      </para>

      <para>
        Si les paramètres de connexion <literal>host</literal> and
        <literal>hostaddr</literal> sont tous les deux précisés,
        alors <xref linkend="libpq-PQhost"/> retournera
        <literal>host</literal>. Si seul <literal>hostaddr</literal> a été
        spécifié, c'est cela qui est retourné. Si plusieurs hôtes sont spécifiés
        dans les paramètres de connexion, <xref linkend="libpq-PQhost"/> retourne
        l'hôte à qui l'on s'est effectivement connecté.
      </para>

      <para>
        <xref linkend="libpq-PQhost"/> retourne <symbol>NULL</symbol> si l'argument
        <parameter>conn</parameter> est <symbol>NULL</symbol>.
        Sinon, s'il y a une erreur en déterminant l'<literal>host</literal>
        (peut-être que la connexion n'a pas été complètement établie ou qu'il y
        a eu une erreur), il retourne une chaîne vide.
      </para>

      <para>
       Si plusieurs hôtes ont été spécifiés dans les paramètres de connexion,
       il n'est pas possible de se baser sur le résultat de
       <xref linkend="libpq-PQhost"/> avant l'établissement de la connexion.
       Le statut de la connexion peut être vérifié avec la fonction
       <xref linkend="libpq-PQstatus"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQhostaddr">
     <term><function>PQhostaddr</function><indexterm><primary>PQhostaddr</primary></indexterm></term>

     <listitem>
      <para>
       Renvoie l'adresse IP du serveur de la connexion active.
       Ca peut être l'adresse résultant de la résolution d'un nom d'hôte,
       ou une adresse IP fournie par le paramètre <literal>hostaddr</literal>.
       <synopsis>
       char *PQhostaddr(const PGconn *conn);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQhostaddr"/> renvoie <symbol>NULL</symbol> si
       l'argument <parameter>conn</parameter> est <symbol>NULL</symbol>.
       Sinon, si une erreur survient en produisant l'information sur
       l'hôte (peut-être parce que la connexion n'a pas été complètement
       établie ou qu'elle a subi une erreur), renvoie une chaîne vide.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQport">
     <term><function>PQport</function><indexterm><primary>PQport</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le numéro de port utilisé pour la connexion active.
       <synopsis>char *PQport(const PGconn *conn);
       </synopsis>
      </para>

      <para>
       Si de multiples ports étaient spécifiés dans les paramètres de
       connexion, <xref linkend="libpq-PQport"/> renvoie le port auquel on est
       effectivement connecté.
      </para>

      <para>
       <function>PQport</function> retourne <symbol>NULL</symbol> si l'argument
       <parameter>conn</parameter> est <symbol>NULL</symbol>.
       Sinon, s'il y a une erreur en déterminant le <literal>port</literal>
       (peut-être que la connexion n'a pas été complètement établie ou qu'il y
       a eu une erreur), il retourne une chaîne vide.
      </para>

      <para>
       Si plusieurs ports ont été spécifiés dans les paramètres de connexion,
       il n'est pas possible de se baser sur le résultat de
       <xref linkend="libpq-PQport"/> avant l'établissement de la connexion.
       Le statut de la connexion peut être vérifié avec la fonction
       <xref linkend="libpq-PQstatus"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQtty">
     <term><function>PQtty</function><indexterm><primary>PQtty</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le <acronym>TTY</acronym> de débogage pour la connexion
       (ceci est obsolète car le serveur ne fait plus attention au
       paramétrage du <acronym>TTY</acronym> mais la fonction reste pour
       la compatibilité descendante).
       <synopsis>char *PQtty(const PGconn *conn);
       </synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQoptions">
     <term><function>PQoptions</function><indexterm><primary>PQoptions</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie les options en ligne de commande passées lors de la demande de
       connexion.
       <synopsis>char *PQoptions(const PGconn *conn);
       </synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les fonctions suivantes renvoient des données de statut qui peuvent changer
   suite à des opérations sur l'objet <structname>PGconn</structname>.

   <variablelist>
    <varlistentry id="libpq-PQstatus">
     <term><function>PQstatus</function><indexterm><primary>PQstatus</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie l'état de la connexion.
       <synopsis>ConnStatusType PQstatus(const PGconn *conn);
       </synopsis>
      </para>

      <para>
       Le statut peut prendre un certain nombre de valeurs. Néanmoins,
       deux seulement ne concernent pas les procédures de connexion
       asynchrone&nbsp;: <literal>CONNECTION_OK</literal> et
       <literal>CONNECTION_BAD</literal>. Une bonne connexion à la base de
       données a l'état <literal>CONNECTION_OK</literal>. Une tentative de
       connexion ayant échoué est signalée par le statut
       <literal>CONNECTION_BAD</literal>. D'habitude, un état OK le restera
       jusqu'à <xref linkend="libpq-PQfinish"/> mais un échec dans les communications
       peut résulter en un statut changeant prématurément en
       <literal>CONNECTION_BAD</literal>. Dans ce cas, l'application peut
       essayer de rattraper la situation en appelant <xref linkend="libpq-PQreset"/>.
      </para>

      <para>
       Voir l'entrée de <xref linkend="libpq-PQconnectStartParams"/>, <function>PQconnectStart</function> et de
       <function>PQconnectPoll</function> à propos des autres codes de statut qui
       pourraient être renvoyés.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQtransactionStatus">
     <term><function>PQtransactionStatus</function><indexterm><primary>PQtransactionStatus</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie l'état actuel de la transaction du serveur.
       <synopsis>PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
       </synopsis>

       Le statut peut être <literal>PQTRANS_IDLE</literal> (actuellement inactif),
       <literal>PQTRANS_ACTIVE</literal> (une commande est en cours),
       <literal>PQTRANS_INTRANS</literal> (inactif, dans un bloc de transaction
       valide) ou <literal>PQTRANS_INERROR</literal> (inactif, dans un bloc de
       transaction échoué). <literal>PQTRANS_UNKNOWN</literal> est rapporté si la
       connexion est mauvaise. <literal>PQTRANS_ACTIVE</literal> n'est rapporté
       que si une requête a été envoyée au serveur et n'est pas encore terminée.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQparameterStatus">
     <term><function>PQparameterStatus</function><indexterm><primary>PQparameterStatus</primary></indexterm></term>
     <listitem>
      <para>
       Recherche la valeur en cours d'un paramètre du serveur.
       <synopsis>const char *PQparameterStatus(const PGconn *conn, const char *paramName);
       </synopsis>

       Certaines valeurs de paramètres sont rapportées par le serveur automatiquement ou
       lorsque leur valeurs changent. <xref linkend="libpq-PQparameterStatus"/> peut être utilisé
       pour interroger ces paramètres. Il renvoie la valeur en cours d'un
       paramètre s'il est connu et <symbol>NULL</symbol> si le paramètre est inconnu.
      </para>

      <para>
       Les paramètres renvoyées par la version actuelle incluent
       <varname>server_version</varname>,
       <varname>server_encoding</varname>,
       <varname>client_encoding</varname>,
       <varname>application_name</varname>,
       <varname>is_superuser</varname>,
       <varname>session_authorization</varname>,
       <varname>datestyle</varname>,
       <varname>IntervalStyle</varname>,
       <varname>TimeZone</varname>,
       <varname>integer_datetimes</varname> et
       <varname>standard_conforming_strings</varname>.
       (<varname>server_encoding</varname>, <varname>TimeZone</varname> et
       <varname>integer_datetimes</varname> n'étaient pas renvoyés dans les versions
       antérieures à la 8.0&nbsp;;
       <varname>standard_conforming_strings</varname> n'était pas renvoyé
       dans les versions antérieures à la 8.1&nbsp;;
       <varname>IntervalStyle</varname> n'était pas renvoyé dans les versions
       antérieures à la 8.4&nbsp;;
       <varname>application_name</varname>  n'était pas renvoyé dans les versions
       antérieures à la 9.0).
       Notez que
       <varname>server_version</varname>,
       <varname>server_encoding</varname> et
       <varname>integer_datetimes</varname>
       ne peuvent pas changer après le lancement du serveur.
      </para>

      <para>
       Les serveurs utilisant un protocole antérieur à la 3.0 ne rapportent pas la
       configuration des paramètres mais <application>libpq</application> inclut la logique pour
       obtenir des valeurs pour <varname>server_version</varname> et
       <varname>client_encoding</varname>. Les applications sont encouragées à utiliser
       <xref linkend="libpq-PQparameterStatus"/> plutôt qu'un code
       <foreignphrase>ad-hoc</foreignphrase> pour trouver ces valeurs.
       (Notez cependant que pour les connexions pré-3.0, changer
       <varname>client_encoding</varname> via <command>SET</command>
       après le lancement de la connexion ne sera pas reflété par
        <xref linkend="libpq-PQparameterStatus"/>). Pour
       <varname>server_version</varname>, voir aussi
       <xref linkend="libpq-PQserverVersion"/>, qui renvoie
       l'information dans un format numérique plus facile à comparer.
      </para>

      <para>
       Si aucune valeur n'est indiquée pour <varname>standard_conforming_strings</varname>,
       les applications peuvent considérer qu'elle vaut <literal>off</literal>,
       c'est-à-dire que les antislashs sont traités comme des échappements dans les
       chaînes littérales. De plus, la présence de ce paramètre peut être pris
       comme une indication que la syntaxe d'échappement de chaîne
       (<literal>E'...'</literal>) est acceptée.
      </para>

      <para>
       Bien que le pointeur renvoyé est déclaré <literal>const</literal>, il pointe en fait
       vers un stockage mutable associé à la structure <literal>PGconn</literal>. Il est
       déconseillé de supposer que le pointeur restera valide pour toutes les
       requêtes.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQprotocolVersion">
     <term><function>PQprotocolVersion</function><indexterm><primary>PQprotocolVersion</primary></indexterm></term>
     <listitem>
      <para>
       Interroge le protocole interface/moteur lors de son utilisation.
       <synopsis>int PQprotocolVersion(const PGconn *conn);
       </synopsis>
       Les applications peuvent utiliser ceci pour déterminer si certaines
       fonctionnalités sont supportées. Actuellement, les seules valeurs possible sont
       2 (protocole 2.0), 3 (protocole 3.0) ou zéro (mauvaise connexion). La version du
       protocole ne
       changera pas après la fin du lancement de la connexion mais il pourrait
       théoriquement changer lors d'une réinitialisation de la connexion. Le protocole
       3.0 sera normalement utilisé lors de la communication avec les serveurs
       <productname>PostgreSQL</productname> 7.4 ou ultérieures&nbsp;; les serveurs
       antérieurs à la 7.4 supportent uniquement le protocole 2.0 (le protocole 1.0
       est obsolète et non supporté par <application>libpq</application>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQserverVersion">
     <term><function>PQserverVersion</function><indexterm><primary>PQserverVersion</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie un entier représentant la version du moteur.
       <synopsis>int PQserverVersion(const PGconn *conn);</synopsis>
      </para>

      <para>
       Les applications peuvent utiliser cette fonction pour déterminer la
       version du serveur de bases de données où ils sont connectés Le
       résultat est obtenu en multipliant le numéro de version majeure de la
       bibliothèque par 10000 et en ajoutant le numéro de version mineure. Par
       exemple, la version 10.1 renverra 100001, et la version 11.0 renverra
       110000. Zéro est renvoyé si la connexion est mauvaise.
      </para>

      <para>
       Avant la version majeure 10, <productname>PostgreSQL</productname>
       utilisait des numéros de version en trois parties, pour lesquelles les
       deux premières parties représentaient la version majeure. Pour ces
       versions, <function>PQlibVersion</function> utilise deux chiffres pour
       chaque partie. Par exemple, la version 9.1.5 renverra 90105, et la
       version 9.2.0 renverra 90200.
      </para>

      <para>
       De ce fait, pour déterminer la compatibilité de certaines
       fonctionnalités, les applications devrait diviser le résultat de
       <xref linkend="libpq-PQserverVersion"/> par 100, et non pas par 10000,
       pour déterminer le numéro de version majeure logique. Dans toutes les
       versions, seuls les deux derniers chiffres diffèrent entre des versions
       mineures (versions correctives).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQerrorMessage">
     <term><function>PQerrorMessage</function><indexterm><primary>PQerrorMessage</primary></indexterm></term>
     <listitem>
      <para>
       <indexterm><primary>error message</primary></indexterm>
       Renvoie le dernier message d'erreur généré par une opération sur la
       connexion.
       <synopsis>char *PQerrorMessage(const PGconn* conn);
       </synopsis>
      </para>

      <para>
       Pratiquement toutes les fonctions <application>libpq</application> initialiseront
       un message pour <xref linkend="libpq-PQerrorMessage"/> en cas d'échec.
       Notez que, par convention dans <application>libpq</application>, un résultat
       non vide de <xref linkend="libpq-PQerrorMessage"/> peut courir sur plusieurs lignes
       et finira par un retour chariot.
       L'appelant ne devrait pas libérer directement le
       résultat. Il sera libéré quand le pointeur <structname>PGconn</structname> associé
       sera passé à <xref linkend="libpq-PQfinish"/>. La chaîne résultante n'est pas
       supposée rester la même pendant les opérations
       sur la structure <literal>PGconn</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</primary></indexterm></term>
     <listitem>
      <para>
       Obtient le descripteur de fichier du socket de la connexion au serveur.
       Un descripteur valide sera plus grand ou égal à 0&nbsp;; un résultat de
       -1 indique qu'aucune connexion au serveur n'est actuellement ouverte
       (ceci ne changera pas lors du fonctionnement habituel, mais pourrait changer
       lors de la mise en place de la connexion ou lors d'une réinitialisation).
       <synopsis>int PQsocket(const PGconn *conn);
       </synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbackendPID">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie l'identifiant du processus
       (<acronym>PID</acronym>)<indexterm><primary>PID</primary><secondary>déterminer
         le PID du processus du serveur</secondary><tertiary>dans libpq</tertiary></indexterm> du serveur
       gérant cette connexion.
       <synopsis>int PQbackendPID(const PGconn *conn);
       </synopsis>
      </para>

      <para>
       Le <acronym>PID</acronym> du processus backend est utile pour des raisons de
       débogage et pour la comparaison avec les messages
       <command>NOTIFY</command> (qui incluent le <acronym>PID</acronym> du
       processus serveur lançant la notification). Notez que le
       <acronym>PID</acronym> appartient à un processus exécuté sur l'hôte du
       serveur de bases de données et non pas sur l'hôte local&nbsp;!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectionNeedsPassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie true (1) si la méthode d'authentification de la connexion
       nécessite un mot de passe, mais qu'aucun n'est disponible.
       Renvoie false (0) sinon.

       <synopsis>
        int PQconnectionNeedsPassword(const PGconn *conn);
       </synopsis>

      </para>

      <para>
       Cette fonction peut être utilisée après un échec de
       connexion pour décider s'il faut demander un mot de passe à l'utilisateur.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectionUsedPassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie true (1) si la méthode d'authentification de la connexion a
       utilisé un mot de passe. Renvoie false (0) sinon.

       <synopsis>
        int PQconnectionUsedPassword(const PGconn *conn);
       </synopsis>

      </para>

      <para>
       Cette fonction peut être utilisée après une connexion, réussie ou en
       échec, pour détecter si le serveur demande un mot de passe.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
    Les fonctions ci-dessous renvoient des informations relatives à
    SSL. Cette information ne change généralement pas après qu'une
    connexion soit établie.
    <variablelist>
    <varlistentry id="libpq-PQsslInUse">
     <term><function>PQsslInUse</function><indexterm><primary>PQsslInUse</primary></indexterm></term>
     <listitem>
      <para>
        Renvoie true (1) si la connexion utilise SSL, false (0) dans le cas contraire.

<synopsis>
int PQsslInUse(const PGconn *conn);
</synopsis>
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsslAttribute">
     <term><function>PQsslAttribute</function><indexterm><primary>PQsslAttribute</primary></indexterm></term>
     <listitem>
      <para>
        Renvoie des informations relatives à SSL à propos de la connexion.

<synopsis>
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</synopsis>
      </para>

      <para>
       La liste des attributs disponibles varie en fonction de la
       bibliothèque SSL utilisée, et du type de la connexion. Si un attribut
       n'est pas disponible, renvoie NULL.
      </para>

      <para>
       Les attributs suivants sont communément disponibles&nbsp;:
       <variablelist>
        <varlistentry>
         <term><literal>library</literal></term>
          <listitem>
           <para>
            Nom de l'implémentation SSL utilisée. (À ce jour seul
            <literal>"OpenSSL"</literal> est implémenté)
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>protocol</literal></term>
          <listitem>
           <para>
             Version de SSL/TLS utilisée. Les valeurs courantes sont
             <literal>"TLSv1"</literal>, <literal>"TLSv1.1"</literal>
             and <literal>"TLSv1.2"</literal>, mais une implémentation
             peut renvoyer d'autres chaînes si d'autres protocoles
             sont utilisés.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>key_bits</literal></term>
          <listitem>
           <para>
            Nombre de bits de la clef utilisée par l'algorithme de chiffrement.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>cipher</literal></term>
          <listitem>
           <para>
            Le nom raccourci de la suite cryptographique utilisée,
            par exemple <literal>"DHE-RSA-DES-CBC3-SHA"</literal>. Les noms
            sont spécifiques à chaque implémentation.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>compression</literal></term>
          <listitem>
           <para>
            Si la compression SSL est utilisée, renvoie le nom de
            l'algorithme de compression, ou "on" si la compression est
            utilisée mais que l'algorithme est inconnu. Si la compression
            n'est pas utilisée, renvoie "off".
           </para>
          </listitem>
         </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsslAttributeNames">
     <term><function>PQsslAttributeNames</function><indexterm><primary>PQsslAttributeNames</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie un tableau des attributs SSL disponibles. Le tableau est
       terminé par un pointeur NULL.
<synopsis>
const char * const * PQsslAttributeNames(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsslStruct">
     <term><function>PQsslStruct</function><indexterm><primary>PQsslStruct</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie un pointeur sur un objet SSL qui est dépendant de
       l'implémentation et qui décrit la connexion.
<synopsis>
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</synopsis>
      </para>
      <para>
       La ou les structures disponibles dépendent de l'implémentation
       SSL utilisée. Pour OpenSSL, il y a une structure, disponible
       sous le nom "OpenSSL", qui renvoie un pointeur sur la structure
       OpenSSL <literal>SSL</literal>. Un exemple de code utilisant
       cette fonction pourrait être&nbsp;:
       <programlisting><![CDATA[
 #include <libpq-fe.h>
 #include <openssl/ssl.h>

 ...

     SSL *ssl;

     dbconn = PQconnectdb(...);
     ...

     ssl = PQsslStruct(dbconn, "OpenSSL");
     if (ssl)
     {
         /* utilisez les fonctions OpenSSL pour accéder à ssl */
     }
 ]]></programlisting>
      </para>
      <para>
       Cette structure peut être utilisée pour vérifier les niveaux
       de chiffrement, les certificats du serveur, etc. Référez-vous à
       la documentation d'<productname>OpenSSL</productname> pour des
       informations sur cette structure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</primary></indexterm></term>
     <listitem>
      <para>
       <indexterm><primary>SSL</primary><secondary sortas="libpq">dans libpq</secondary></indexterm>
       Renvoie la structure SSL utilisée dans la connexion, ou NULL si
       SSL n'est pas utilisé.

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>

      <para>
       Cette fonction est équivalente à <literal>PQsslStruct(conn,
       "OpenSSL")</literal>. Elle ne devrait pas être utilisée dans les
       nouvelles applications, car la structure renvoyée est spécifique
       à OpenSSL et ne sera pas disponible si une autre implémentation
       SSL est utilisée. Pour vérifier si une connexion utilise SSL,
       appelez plutôt <xref linkend="libpq-PQsslInUse"/>,
       et, pour plus de détails à propos de la connexion, utilisez
       <xref linkend="libpq-PQsslAttribute"/>.
      </para>
    </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-exec">
  <title>Fonctions d'exécution de commandes</title>

  <para>
   Une fois la connexion au serveur de la base de données établie avec
   succès, les fonctions décrites ici sont utilisées pour exécuter les requêtes
   SQL et les commandes.
  </para>

  <sect2 id="libpq-exec-main">
   <title>Fonctions principales</title>

   <para>
    <variablelist>
     <varlistentry id="libpq-PQexec">
      <term><function>PQexec</function><indexterm><primary>PQexec</primary></indexterm></term>
      <listitem>
       <para>
        Soumet une commande au serveur et attend le résultat.
        <synopsis>PGresult *PQexec(PGconn *conn, const char *command);
       </synopsis>
      </para>

      <para>
       Renvoie un pointeur <structname>PGresult</structname> ou peut-être un
       pointeur NULL.
       Un pointeur non NULL sera généralement renvoyé sauf dans des
       conditions particulières comme un manque de mémoire ou lors d'erreurs
       sérieuses telles que l'incapacité à envoyer la commande au serveur.
       La fonction <xref linkend="libpq-PQresultStatus"/> devrait être appelée pour
       vérifier le code retour  pour toute erreur (incluant la valeur d'un
       pointeur NULL, auquel cas il renverra <symbol>PGRES_FATAL_ERROR</symbol>).
       Utilisez <xref linkend="libpq-PQerrorMessage"/> pour obtenir plus
       d'informations sur l'erreur.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   La chaîne de la commande peut inclure plusieurs commandes SQL (séparées par des points
   virgules). Les requêtes multiples envoyées
   dans un unique appel à <xref linkend="libpq-PQexec"/> sont exécutées dans une seule
   transaction, sauf si des commandes <command>BEGIN</command>/<command>COMMIT
   </command>  explicites sont incluses dans la chaîne
   de requête pour la diviser en de multiples transactions. (Voir <xref
   linkend="protocol-flow-multi-statement"/> pour plus de détails sur comment le
   serveur traite les chaînes multi-requêtes.) Notez néanmoins
   que la structure <structname>PGresult</structname> renvoyée décrit seulement
   le résultat de la dernière commande exécutée à partir de la chaîne. Si une des
   commandes échoue, l'exécution de la chaîne s'arrête et le
   <structname>PGresult</structname> renvoyé décrit la condition d'erreur.
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-PQexecParams">
     <term><function>PQexecParams</function><indexterm><primary>PQexecParams</primary></indexterm></term>
     <listitem>
      <para>
       Soumet une commande au serveur et attend le résultat, avec la
       possibilité de passer des paramètres séparément du texte de la
       commande SQL.
       <synopsis>PGresult *PQexecParams(PGconn *conn,
                            const char *command,
                            int nParams,
                            const Oid *paramTypes,
                            const char * const *paramValues,
                            const int *paramLengths,
                            const int *paramFormats,
                            int resultFormat);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQexecParams"/> est identique à <xref linkend="libpq-PQexec"/>
       mais offre des
       fonctionnalités supplémentaires&nbsp;: des valeurs de paramètres peuvent être
       spécifiées séparément de la chaîne de commande et les résultats de la requête
       peuvent être demandés soit au format texte soit au format binaire.
       <xref linkend="libpq-PQexecParams"/> est supporté seulement dans les connexions avec le
       protocole 3.0 et ses versions ultérieures&nbsp;; elle échouera lors de
       l'utilisation du protocole 2.0.
      </para>

      <para>
       Voici les arguments de la fonction&nbsp;:

       <variablelist>
        <varlistentry>
         <term><parameter>conn</parameter></term>
         <listitem>
          <para>
           L'objet connexion où envoyer la commande.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>command</parameter></term>
         <listitem>
          <para>
           La chaîne SQL à exécuter. Si les paramètres sont utilisés, ils sont
           référencés dans la chaîne avec <literal>$1</literal>,
           <literal>$2</literal>, etc.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>nParams</parameter></term>
         <listitem>
          <para>
           Le nombre de paramètres fournis&nbsp;; il s'agit de la longueur des
           tableaux <parameter>paramTypes[]</parameter>,
           <parameter>paramValues[]</parameter>,
           <parameter>paramLengths[]</parameter> et
           <parameter>paramFormats[]</parameter>. (Les pointeurs de tableau peuvent
           être <symbol>NULL</symbol> quand <parameter>nParams</parameter> vaut
           zéro.)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>paramTypes[]</parameter></term>
         <listitem>
          <para>
           Spécifie, par OID, les types de données à affecter aux symboles de
           paramètres. Si <parameter>paramTypes</parameter> est <symbol>NULL</symbol>
           ou si tout élément spécifique du tableau est zéro, le serveur infère un
           type de donnée pour le symbole de paramètre de la même façon qu'il le
           ferait pour une chaîne littérale sans type.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>paramValues[]</parameter></term>
         <listitem>
          <para>
           Spécifie les vraies valeurs des paramètres. Un pointeur NULL dans ce
           tableau signifie que le paramètre correspondant est NULL&nbsp;; sinon,
           le pointeur pointe vers une chaîne texte terminée par un octet nul
           (pour le format texte) ou vers des données binaires dans le format
           attendu par le serveur (pour le format binaire).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>paramLengths[]</parameter></term>
         <listitem>
          <para>
           Spécifie les longueurs des données réelles des paramètres du format
           binaire. Il est ignoré pour les paramètres NULL et les paramètres de
           format texte. Le pointeur du tableau peut être NULL quand il n'y a pas
           de paramètres binaires.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>paramFormats[]</parameter></term>
         <listitem>
          <para>
           Spécifie si les paramètres sont du texte (place un 0 dans la ligne du
           tableau pour le paramètre correspondant) ou binaire (place un 1 dans la
           ligne du tableau pour le paramètre correspondant). Si le pointeur du
           tableau est nul, alors tous les paramètres sont présumés être des chaînes
           de texte.
          </para>
          <para>
           Les valeurs passées dans le format binaire nécessitent de connaître la
           représentation interne attendue par le processus backend. Par exemple, les entiers
           doivent être passés dans l'ordre réseau pour les octets. Passer des
           valeurs <type>numeric</type> requiert de connaître le format de stockage
           du serveur, comme implémenté dans
           <filename>src/backend/utils/adt/numeric.c::numeric_send()</filename> et
           <filename>src/backend/utils/adt/numeric.c::numeric_recv()</filename>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><parameter>resultFormat</parameter></term>
         <listitem>
          <para>
           Indiquez zéro pour obtenir les résultats dans un format texte et un pour
           les obtenir dans un format binaire. (Il n'est actuellement pas possible
           d'obtenir des formats différents pour des colonnes de résultats
           différentes bien que le protocole le permette.)
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Le principal avantage de <xref linkend="libpq-PQexecParams"/> sur
   <xref linkend="libpq-PQexec"/> est que les valeurs de paramètres peuvent être
   séparées à partir de la chaîne de commande, évitant ainsi le besoin
   de guillemets et d'échappements, toujours pénibles et sources d'erreurs.
  </para>

  <para>
   Contrairement à <xref linkend="libpq-PQexec"/>, <xref linkend="libpq-PQexecParams"/> autorise au plus
   une commande SQL dans une chaîne donnée (il peut y avoir des points-virgules
   mais pas plus d'une commande non vide). C'est une limitation du protocole
   sous-jacent mais cela a quelque utilité comme défense supplémentaire contre les
   attaques par injection de SQL.
  </para>

  <tip>
   <para>
    Spécifier les types de paramètres via des OID est difficile,
    surtout si vous préférez ne pas coder en dur des valeurs OID
    particulières dans vos programmes. Néanmoins vous pouvez éviter de le faire,
    même dans des cas où le serveur lui-même ne peut pas déterminer le type du
    paramètre ou choisit un type différent de celui que vous voulez. Dans le
    texte de la commande SQL, ajoutez une conversion explicite au symbole de
    paramètre pour indiquer le type de données que vous enverrez. Par exemple&nbsp;:
    <programlisting>SELECT * FROM ma_table WHERE x = $1::bigint;
    </programlisting>
    Ceci impose le traitement du paramètre <literal>$1</literal> en tant que <type>bigint</type>
    alors que, par défaut, il se serait vu affecté le même type que <literal>x</literal>.
    Forcer la décision du type de paramètre, soit de cette façon soit en spécifiant
    l'OID du type numérique, est fortement recommandé lors de l'envoi des valeurs
    des paramètres au format binaire car le format binaire a moins de redondance que
    le format texte et, du coup, il y a moins de chance que le serveur détecte une
    erreur de correspondance de type pour vous.
   </para>
  </tip>

  <para>
   <variablelist>
    <varlistentry id="libpq-PQprepare">
     <term><function>PQprepare</function>
      <indexterm><primary>PQprepare</primary></indexterm></term>
     <listitem>
      <para>
       Soumet une requête pour créer une instruction préparée avec les
       paramètres donnés et attends la fin de son exécution.
       <synopsis>PGresult *PQprepare(PGconn *conn,
         const char *stmtName,
         const char *query,
         int nParams,
         const Oid *paramTypes);</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQprepare"/> crée une instruction préparée pour une
        exécution ultérieure avec <xref linkend="libpq-PQexecPrepared"/>. Cette
        fonction autorise les commandes à être exécutées de façon répétée sans
        être analysées et planifiées à chaque fois&nbsp;; voir <xref
        linkend="sql-prepare"/> pour les détails.
        <xref linkend="libpq-PQprepare"/> est supporté uniquement par les
        connexions utilisant le protocole 3.0 et ses versions
        ultérieures&nbsp;; elle échouera avec le protocole 2.0.
       </para>

       <para>
        La fonction crée une instruction préparée nommée <parameter>stmtName</parameter>
        à partir de la chaîne <parameter>query</parameter>,
        qui ne doit contenir qu'une seule commande SQL.
        <parameter>stmtName</parameter> peut être  <literal>""</literal> pour
        créer une instruction non nommée, auquel cas toute instruction non nommée
        déjà existante est automatiquement remplacée par cette dernière&nbsp;
        sinon une erreur sera levée si le nom de l'instruction est déjà définie
        dans la session en cours. Si des paramètres sont utilisés, ils sont
        référencés dans la requête avec <literal>$1</literal>, <literal>$2</literal>, etc.
        <parameter>nParams</parameter> est le nombre de paramètres pour lesquels des types
        sont prédéfinis dans le tableau <parameter>paramTypes[]</parameter> (le pointeur
        du tableau pourrait être <symbol>NULL</symbol> quand
        <parameter>nParams</parameter> vaut zéro). <parameter>paramTypes[]</parameter> spécifie
        les types de données à affecter aux symboles de paramètres par leur OID.
        Si <parameter>paramTypes</parameter> est <symbol>NULL</symbol> ou si un élément
        particulier du tableau vaut zéro, le serveur affecte un type de données
        au symbole du paramètre de la même façon qu'il le ferait pour une chaîne
        littérale non typée. De plus, la requête peut utiliser des symboles
        de paramètre avec des nombres plus importants que
        <parameter>nParams</parameter>&nbsp;; les types de données seront aussi inférés
        pour ces symboles. (Voir <xref linkend="libpq-PQdescribePrepared"/> pour un
        moyen de trouver les types de données inférés.)
       </para>

       <para>
        Comme avec <xref linkend="libpq-PQexec"/>, le résultat est normalement un objet
        <structname>PGresult</structname> dont le contenu indique le succès ou
        l'échec côté serveur. Un résultat NULL indique un manque de mémoire ou
        une incapacité à envoyer la commande. Utilisez
        <xref linkend="libpq-PQerrorMessage"/> pour obtenir plus d'informations sur
        de telles erreurs.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Les instructions préparées avec <xref linkend="libpq-PQexecPrepared"/> peuvent aussi être
    créées en exécutant les instructions SQL <xref linkend="sql-prepare"/>. De plus,
    bien qu'il n'y ait aucune fonction <application>libpq</application> pour supprimer une
    instruction préparée, l'instruction SQL <xref linkend="sql-deallocate"/> peut
    être utilisée dans ce but.
   </para>

   <para>
    <variablelist>
     <varlistentry id="libpq-PQexecPrepared">
      <term><function>PQexecPrepared</function><indexterm><primary>PQexecPrepared</primary></indexterm></term>
      <listitem>
       <para>
        Envoie une requête pour exécuter une instruction séparée avec les
        paramètres donnés, et attend le résultat.
        <synopsis>PGresult *PQexecPrepared(PGconn *conn,
                                const char *stmtName,
                                int nParams,
                                const char * const *paramValues,
                                const int *paramLengths,
                                const int *paramFormats,
                                int resultFormat);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQexecPrepared"/> est identique à <xref
       linkend="libpq-PQexecParams"/> mais la
       commande à exécuter est spécifiée en nommant l'instruction préparée précédemment
       au lieu de donner une chaîne de requête. Cette fonctionnalité permet aux
       commandes utilisées de façon répétée d'être analysées et planifiées seulement
       une fois plutôt que chaque fois qu'ils sont exécutés.
       L'instruction doit avoir été préparée précédemment dans la session en cours.
       <xref linkend="libpq-PQexecPrepared"/> est supporté seulement pour des connexions
       en protocole 3.0 et versions ultérieures&nbsp;; il échouera lors de
       l'utilisation du protocole 2.0.
      </para>

      <para>
       Les paramètres sont identiques à <xref linkend="libpq-PQexecParams"/>, sauf que le nom
       d'une instruction préparée est donné au lieu d'une chaîne de requête et
       que le paramètre <parameter>paramTypes[]</parameter> n'est pas présent (il n'est pas
       nécessaire car les types des paramètres de l'instruction préparée ont été
       déterminés à la création).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQdescribePrepared">
     <term><function>PQdescribePrepared</function><indexterm><primary>PQdescribePrepared</primary></indexterm></term>
     <listitem>
      <para>
       Soumet une requête pour obtenir des informations sur l'instruction
       préparée indiquée et attend le retour de la requête.
       <synopsis>
         PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQdescribePrepared"/> permet à une application d'obtenir des
       informations sur une instruction préparée précédente.
       <xref linkend="libpq-PQdescribePrepared"/> est seulement supporté avec des
       connexions utilisant le protocole 3.0 et ultérieures&nbsp;; il échouera lors
       de l'utilisation du protocole 2.0.
      </para>

      <para>
       <parameter>stmtName</parameter> peut être <literal>""</literal> ou  <symbol>NULL</symbol> pour
       référencer l'instruction non nommée. Sinon, ce doit être le nom d'une instruction
       préparée existante. En cas de succès, un <structname>PGresult</structname> est
       renvoyé avec le code retour <literal>PGRES_COMMAND_OK</literal>. Les fonctions
       <xref linkend="libpq-PQnparams"/> et <xref linkend="libpq-PQparamtype"/> peuvent
       utiliser ce <structname>PGresult</structname> pour obtenir des
       informations sur les paramètres de l'instruction préparée, et les fonctions
       <xref linkend="libpq-PQnfields"/>, <xref linkend="libpq-PQfname"/>,
       <xref linkend="libpq-PQftype"/>, etc. fournissent des informations sur les colonnes
       résultantes (s'il y en a) de l'instruction.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQdescribePortal">
     <term><function>PQdescribePortal</function><indexterm><primary>PQdescribePortal</primary></indexterm></term>
     <listitem>
      <para>
       Soumet une requête pour obtenir des informations sur le portail
       indiqué et attend le retour de la requête.
       <synopsis>
         PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQdescribePortal"/> permet à une application d'obtenir des
       informations sur un portail précédemment créé. (<application>libpq</application>
       ne fournit pas d'accès direct aux portails mais vous pouvez utiliser cette
       fonction pour inspecter les propriétés d'un curseur créé avec la commande
       SQL <command>DECLARE CURSOR</command>.)
       <xref linkend="libpq-PQdescribePortal"/> est seulement supporté dans les connexions
       en protocole 3.0 et ultérieurs&nbsp;; il échouera lors de l'utilisation du
       protocole 2.0.
      </para>

      <para>
       <parameter>portalName</parameter> peut être <literal>""</literal> ou <symbol>NULL</symbol> pour
       référencer un portail sans nom. Sinon, il doit correspondre au nom d'un portail
       existant. En cas de succès, un <structname>PGresult</structname> est renvoyé
       avec le code de retour <literal>PGRES_COMMAND_OK</literal>. Les fonctions
       <xref linkend="libpq-PQnfields"/>, <xref linkend="libpq-PQfname"/>,
       <xref linkend="libpq-PQftype"/>, etc. peuvent utiliser ce
       <structname>PGresult</structname> pour obtenir des informations sur les colonnes
       résultantes (s'il y en a) du portail.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   La structure
   <structname>PGresult</structname><indexterm><primary>PGresult</primary></indexterm>
   encapsule le résultat renvoyé par le serveur. Les développeurs d'applications
   <application>libpq</application> devraient faire attention au maintien de
   l'abstraction de <structname>PGresult</structname>. Utilisez les fonctions
   d'accès ci-dessous pour obtenir le contenu de <structname>PGresult</structname>.
   Évitez de référencer directement les champs de la structure <structname>PGresult</structname>
   car ils sont sujets à changements dans le futur.

   <variablelist>
    <varlistentry id="libpq-PQresultStatus">
     <term><function>PQresultStatus</function><indexterm><primary>PQresultStatus</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie l'état du résultat d'une commande.
       <synopsis>ExecStatusType PQresultStatus(const PGresult *res);
       </synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQresultStatus"/> peut renvoyer une des valeurs
       suivantes&nbsp;:

       <variablelist>
        <varlistentry id="libpq-pgres-empty-query">
         <term><literal>PGRES_EMPTY_QUERY</literal></term>
         <listitem>
          <para>La chaîne envoyée au serveur était vide.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-command-ok">
         <term><literal>PGRES_COMMAND_OK</literal></term>
         <listitem>
          <para>Fin avec succès d'une commande ne renvoyant aucune donnée.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-tuples-ok">
         <term><literal>PGRES_TUPLES_OK</literal></term>
         <listitem>
          <para>Fin avec succès d'une commande renvoyant des données (telle que
           <command>SELECT</command> ou <command>SHOW</command>).</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-copy-out">
         <term><literal>PGRES_COPY_OUT</literal></term>
         <listitem>
          <para>Début de l'envoi (à partir du serveur) d'un flux de données.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-copy-in">
         <term><literal>PGRES_COPY_IN</literal></term>
         <listitem>
          <para>Début de la réception (sur le serveur) d'un flux de
           données.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-bad-response">
         <term><literal>PGRES_BAD_RESPONSE</literal></term>
         <listitem>
          <para>La réponse du serveur n'a pas été comprise.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-nonfatal-error">
         <term><literal>PGRES_NONFATAL_ERROR</literal></term>
         <listitem>
          <para>Une erreur non fatale (une note ou un avertissement) est
           survenue.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-fatal-error">
         <term><literal>PGRES_FATAL_ERROR</literal></term>
         <listitem>
          <para>Une erreur fatale est survenue.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-copy-both">
         <term><literal>PGRES_COPY_BOTH</literal></term>
         <listitem>
          <para>
           Lancement du transfert de données Copy In/Out (vers et à
           partir du serveur). Cette fonctionnalité est seulement
           utilisée par la réplication en flux,
           ce statut ne devrait donc pas apparaître dans les applications
           ordinaires.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pgres-single-tuple">
         <term><literal>PGRES_SINGLE_TUPLE</literal></term>
         <listitem>
          <para>
           La structure <structname>PGresult</structname> contient une seule
           ligne de résultat provenant de la commande courante. Ce statut
           n'intervient que lorsque le mode ligne-à-ligne a été sélectionné
           pour cette requête (voir <xref linkend="libpq-single-row-mode"/>).
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

       Si le statut du résultat est <literal>PGRES_TUPLES_OK</literal> ou <literal>PGRES_SINGLE_TUPLE</literal>, alors les
       fonctions décrites ci-dessous peuvent être utilisées pour récupérer les lignes
       renvoyées par la requête. Notez qu'une commande <command>SELECT</command> qui
       récupère zéro ligne affichera toujours
       <literal>PGRES_TUPLES_OK</literal>. <literal>PGRES_COMMAND_OK</literal> est
       pour les commandes qui ne peuvent jamais renvoyer de lignes
       (<command>INSERT</command> ou <command>UPDATE</command> sans une clause <literal>RETURNING</literal>, etc.). Une réponse
       <literal>PGRES_EMPTY_QUERY</literal> pourrait indiquer un bogue dans le
       logiciel client.
      </para>

      <para>
       Un résultat de statut <symbol>PGRES_NONFATAL_ERROR</symbol> ne sera jamais
       renvoyé directement par <function>PQexec</function> ou d'autres fonctions
       d'exécution de requêtes&nbsp;; les résultats de ce type sont passés à
       l'exécuteur de notifications (voir la <xref linkend="libpq-notice-processing"/>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresStatus">
     <term><function>PQresStatus</function><indexterm><primary>PQresStatus</primary></indexterm></term>
     <listitem>
      <para>
       Convertit le type énuméré renvoyé par <xref linkend="libpq-PQresultStatus"/> en
       une constante de type chaîne décrivant le code d'état. L'appelant ne
       devrait pas libérer le résultat.
       <synopsis>char *PQresStatus(ExecStatusType status);
       </synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresultErrorMessage">
     <term><function>PQresultErrorMessage</function><indexterm><primary>PQresultErrorMessage</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie le message d'erreur associé avec la commande ou une chaîne vide s'il
       n'y a pas eu d'erreurs.
       <synopsis>char *PQresultErrorMessage(const PGresult *res);
       </synopsis>
       S'il y a eu une erreur, la chaîne renvoyée incluera un retour chariot en fin.
       L'appelant ne devrait pas libérer directement le résultat. Il sera libéré quand
       le pointeur <structname>PGresult</structname> associé sera passé à
       <xref linkend="libpq-PQclear"/>.
      </para>

      <para>
       Immédiatement après un appel à <xref linkend="libpq-PQexec"/> ou
       <xref linkend="libpq-PQgetResult"/>,
       <xref linkend="libpq-PQerrorMessage"/> (sur la
       connexion) renverra la même chaîne que <xref linkend="libpq-PQresultErrorMessage"/>
       (sur le résultat). Néanmoins, un <structname>PGresult</structname> conservera
       son message d'erreur jusqu'à destruction, alors que le message d'erreur de la
       connexion changera avec les opérations suivantes. Utilisez
       <xref linkend="libpq-PQresultErrorMessage"/> quand vous voulez connaître le statut
       associé avec un <structname>PGresult</structname> particulier&nbsp;; utilisez
       <xref linkend="libpq-PQerrorMessage"/> lorsque vous souhaitez connaître le statut
       à partir de la dernière opération sur la connexion.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresultVerboseErrorMessage">
     <term><function>PQresultVerboseErrorMessage</function><indexterm><primary>PQresultVerboseErrorMessage</primary></indexterm></term>

      <listitem>
       <para>
        Renvoie une version reformatée du message d'erreur associé avec un objet
        <structname>PGresult</structname>.
<synopsis>
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</synopsis>
        Dans certaines situations, un client pourrait vouloir une
        version plus détaillée d'une erreur déjà rapportée.
        <xref linkend="libpq-PQresultVerboseErrorMessage"/> couvre ce besoin en
        traitant le message tel qu'il aurait été produit par
        <xref linkend="libpq-PQresultErrorMessage"/> si la configuration souhaitée
        de la verbosité était activée pour la connexion au moment où l'objet
        <structname>PGresult</structname> indiqué a été généré. Si le
        <structname>PGresult</structname> ne correspond pas une erreur,
        <quote>PGresult is not an error result</quote> est renvoyé à la place.
        La chaîne renvoyée inclut un retour à la ligne en fin de chaîne.
       </para>

       <para>
        Contrairement à la plupart des autres fonctions d'extraction de données
        à partir d'un objet <structname>PGresult</structname>, le résultat de
        cette fonction est une chaîne tout juste allouée. L'appelant doit la
        libérer en utilisant <function>PQfreemem()</function> quand la chaîne
        n'est plus nécessaire.
       </para>

       <para>
        Un NULL en retour est possible s'il n'y a pas suffisamment de mémoire.
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="libpq-PQresultErrorField">
     <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</primary></indexterm></term>
     <listitem>
      <para>
       Renvoie un champ individuel d'un rapport d'erreur.
       <synopsis>char *PQresultErrorField(const PGresult *res, int fieldcode);
       </synopsis>
       <parameter>fieldcode</parameter> est un identifiant de champ d'erreur&nbsp;; voir les
       symboles listés ci-dessous. <symbol>NULL</symbol> est renvoyé si
       <structname>PGresult</structname> n'est pas un résultat d'erreur ou
       d'avertissement, ou n'inclut pas le champ spécifié. Les valeurs de champ
       n'incluront normalement pas un retour chariot en fin. L'appelant ne devrait pas
       libérer directement le résultat. Il sera libéré quand le pointeur
       <structname>PGresult</structname> associé sera passé à
       <xref linkend="libpq-PQclear"/>.
      </para>

      <para>
       Les codes de champs suivants sont disponibles&nbsp;:
       <variablelist>

        <varlistentry id="libpq-pg-diag-severity">
         <term><symbol>PG_DIAG_SEVERITY</symbol></term>
         <listitem>
          <para>
           La sévérité&nbsp;; le contenu du champ peut être <literal>ERROR</literal>,
           <literal>FATAL</literal> ou <literal>PANIC</literal> dans un message d'erreur, ou
           <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
           <literal>INFO</literal> ou <literal>LOG</literal> dans un message de notification, ou une
           traduction localisée d'un de ceux-ci. Toujours présent.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PG-diag-severity-nonlocalized">
         <term><symbol>PG_DIAG_SEVERITY_NONLOCALIZED</symbol></term>
         <listitem>
          <para>
           La sévérité&nbsp;; le contenu du champ peut être
           <literal>ERROR</literal>, <literal>FATAL</literal> ou
           <literal>PANIC</literal> (dans un message d'erreur), ou
           <literal>WARNING</literal>, <literal>NOTICE</literal>,
           <literal>DEBUG</literal>, <literal>INFO</literal> ou
           <literal>LOG</literal> (dans un message de notification). C'est
           identique au champ <symbol>PG_DIAG_SEVERITY</symbol> sauf que le
           contenu n'est jamais traduit. Il est présent uniquement dans les
           rapports générés par les versions 9.6 et ultérieurs de
           <productname>PostgreSQL</productname>.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-sqlstate">
         <term><symbol>PG_DIAG_SQLSTATE</symbol><indexterm><primary>error codes</primary><secondary>libpq</secondary></indexterm></term>
         <listitem>
          <para>
           Le code SQLSTATE de l'erreur. Ce code identifie le type d'erreur qui est
           survenu&nbsp;; il peut être utilisé par des interfaces utilisateur pour
           des opérations spécifiques (telles que la gestion des erreurs) en réponse à une
           erreur particulière de la base de données. Pour une liste des codes SQLSTATE
           possibles, voir l'<xref linkend="errcodes-appendix"/>. Ce champ n'est pas
           localisable et est toujours présent.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-message-primary">
         <term><symbol>PG_DIAG_MESSAGE_PRIMARY</symbol></term>
         <listitem>
          <para>
           Le message d'erreur principal, compréhensible par un humain (typiquement sur
           une ligne). Toujours présent.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-message-detail">
         <term><symbol>PG_DIAG_MESSAGE_DETAIL</symbol></term>
         <listitem>
          <para>
           Détail&nbsp;: un message d'erreur secondaire et optionnel proposant plus
           d'informations sur le problème. Pourrait courir sur plusieurs lignes.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-message-hint">
         <term><symbol>PG_DIAG_MESSAGE_HINT</symbol></term>
         <listitem>
          <para>
           Astuce&nbsp;: une suggestion supplémentaire sur ce qu'il faut faire suite à
           ce problème. Elle a pour but de différer du détail car elle
           offre un conseil (potentiellement inapproprié) plutôt que des faits établis.
           Pourrait courir sur plusieurs lignes.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-statement-position">
         <term><symbol>PG_DIAG_STATEMENT_POSITION</symbol></term>
         <listitem>
          <para>
           Une chaîne contenant un entier décimal indiquant une position du curseur d'erreur
           comme index dans la chaîne d'instruction originale. Le premier caractère
           a l'index 1 et les positions sont mesurées en caractères, et non en
           octets.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-internal-position">
         <term><symbol>PG_DIAG_INTERNAL_POSITION</symbol></term>
         <listitem>
          <para>
           Ceci est défini de la même façon que le champ <symbol>PG_DIAG_STATEMENT_POSITION</symbol>
           mais est utilisé quand la position du curseur fait référence à une commande
           générée en interne plutôt qu'une soumise par le client. Le champ
           <symbol>PG_DIAG_INTERNAL_QUERY</symbol> apparaîtra toujours quand ce champ apparaît.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-internal-query">
         <term><symbol>PG_DIAG_INTERNAL_QUERY</symbol></term>
         <listitem>
          <para>
           Le texte d'une commande générée en interne et échouée. Ce pourrait être, par
           exemple, une requête SQL lancée par une fonction PL/pgSQL.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-context">
         <term><symbol>PG_DIAG_CONTEXT</symbol></term>
         <listitem>
          <para>
           Une indication du contexte dans lequel l'erreur est apparue. Actuellement, cela
           inclut une trace de la pile d'appels des fonctions du langage
           procédural actif et de requêtes générées en interne. La trace a une
           entrée par ligne, la plus récente au début.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-schema-name">
         <term><symbol>PG_DIAG_SCHEMA_NAME</symbol></term>
         <listitem>
          <para>
           Si l'erreur était associée à un objet spécifique de la base de
           données, nom du schéma contenant cet objet.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-table-name">
         <term><symbol>PG_DIAG_TABLE_NAME</symbol></term>
         <listitem>
          <para>
           Si l'erreur était associée à une table spécifique, nom de cette
           table. (Fait référence au champ du nom du schéma pour le nom du
           schéma de la table.)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-column-name">
         <term><symbol>PG_DIAG_COLUMN_NAME</symbol></term>
         <listitem>
          <para>
           Si l'erreur était associée à une colonne spécifique d'une table,
           nom de cette colonne. (Fait référence aux champs de noms du schéma
           et de la table pour identifier la table.)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-datatype-name">
         <term><symbol>PG_DIAG_DATATYPE_NAME</symbol></term>
         <listitem>
          <para>
           Si l'erreur était associée à un type de données spécifique, nom de
           ce type de données. (Fait référence au champ du nom du schéma pour
           le schéma du type de données.)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-constraint-name">
         <term><symbol>PG_DIAG_CONSTRAINT_NAME</symbol></term>
         <listitem>
          <para>
           Si l'erreur était associée à une contrainte spécifique, nom de cette
           contrainte. Cela fait référence aux champs listés ci-dessus pour la
           table ou le domaine associé. (Dans ce cadre, les index
           sont traités comme des contraintes, même s'ils n'ont pas été
           créés avec la syntaxe des contraintes.)
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-source-file">
         <term><symbol>PG_DIAG_SOURCE_FILE</symbol></term>
         <listitem>
          <para>
           Le nom du fichier contenant le code source où l'erreur a été rapportée.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-source-line">
         <term><symbol>PG_DIAG_SOURCE_LINE</symbol></term>
         <listitem>
          <para>
           Le numéro de ligne dans le code source où l'erreur a été rapportée.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pg-diag-source-function">
         <term><symbol>PG_DIAG_SOURCE_FUNCTION</symbol></term>
         <listitem>
          <para>
           Le nom de la fonction dans le code source où l'erreur a été rapportée.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>

      <note>
       <para>
        Les champs pour les noms du schéma, de la table, de la colonne, du
        type de données et de la contrainte sont fournis seulement pour un
        nombre limité de types d'erreurs&nbsp;; voir <xref
        linkend="errcodes-appendix"/>. Ne supposez pas que la présence d'un
        de ces champs garantisse la présence d'un autre champ. Les sources
        d'erreurs du moteur observent les relations notées ci-dessus mais les
        fonctions utilisateurs peuvent utiliser ces champs d'une autre
        façon. Dans la même idée, ne supposez pas que ces champs indiquent
        des objets encore existants dans la base de données courante.
       </para>
      </note>

      <para>
       Le client est responsable du formatage des informations affichées suivant
       ses besoins&nbsp;; en particulier, il doit supprimer les longues
       lignes si nécessaires. Les caractères de retour chariot apparaissant dans les
       champs de message d'erreur devraient être traités comme des changements de
       paragraphes, pas comme des changements de lignes.
      </para>

      <para>
       Les erreurs générées en interne par <application>libpq</application> auront une
       sévérité et un message principal mais aucun autre champ. Les erreurs renvoyées
       par un serveur utilisant un protocole antérieure à la 3.0 inclueront la
       sévérité, le message principal et parfois un message détaillé, mais
       aucun autre champ.
      </para>

      <para>
       Notez que les champs d'erreurs sont seulement disponibles pour les objets
       <structname>PGresult</structname>, et non pas pour les objets
       <structname>PGconn</structname>&nbsp;; il n'existe pas de fonction
       <function>PQerrorField</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQclear">
     <term><function>PQclear</function><indexterm><primary>PQclear</primary></indexterm></term>
     <listitem>
      <para>
       Libère le stockage associé avec un <structname>PGresult</structname>.
       Chaque résultat de commande devrait être libéré via
       <xref linkend="libpq-PQclear"/> lorsqu'il n'est plus nécessaire.
       <synopsis>void PQclear(PGresult *res);
       </synopsis>
      </para>

      <para>
       Vous pouvez conserver un objet <structname>PGresult</structname>
       aussi longtemps que vous en avez besoin&nbsp;; il ne part pas lorsque
       vous lancez une nouvelle commande, même pas si vous fermez la
       connexion. Pour vous en débarrasser, vous devez appeler
       <xref linkend="libpq-PQclear"/>. En cas d'oubli, le résultat sera une
       fuite de mémoire dans votre application.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
 </sect2>

 <sect2 id="libpq-exec-select-info">
  <title>Récupérer l'information dans le résultat des requêtes</title>

  <para>
   Ces fonctions sont utilisées pour extraire des informations provenant d'un objet
   <structname>PGresult</structname> représentant un résultat valide pour une
   requête (statut <literal>PGRES_TUPLES_OK</literal> ou
   <literal>PGRES_SINGLE_TUPLE</literal>). Elles peuvent aussi être
   utilisés pour extraire des informations à partir d'une opération Describe
   réussie&nbsp;: le résultat d'un Describe a les mêmes informations de colonnes
   qu'une exécution réelle de la requête aurait fournie, mais avec zéro ligne.
   Pour les objets avec d'autres valeurs de statut, ces fonctions agiront comme
   si le résultat avait zéro ligne et zéro colonne.
  </para>

  <variablelist>
   <varlistentry id="libpq-PQntuples">
    <term><function>PQntuples</function><indexterm><primary>PQntuples</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le nombre de lignes (enregistrements, ou
      <foreignphrase>tuples</foreignphrase>) du résultat de la requête.
      (Notez que les objets <structname>PGresult</structname> sont limités à
      au plus <literal>INT_MAX</literal> lignes, donc un résultat de type
      <type>int</type> est suffisant.)
      <synopsis>int PQntuples(const PGresult *res);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQnfields">
    <term><function>PQnfields</function><indexterm><primary>PQnfields</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le nombre de colonnes (champs) de chaque ligne du résultat de
      la requête.
      <synopsis>int PQnfields(const PGresult *res);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfname">
    <term><function>PQfname</function><indexterm><primary>PQfname</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le nom de la colonne associé avec le numéro de colonne donnée.
      Les numéros de colonnes commencent à zéro. L'appelant ne devrait pas
      libérer directement le résultat. Il sera libéré quand le pointeur
      <structname>PGresult</structname> associée est passée à
      <xref linkend="libpq-PQclear"/>.
      <synopsis>char *PQfname(const PGresult *res,
                      int column_number);
      </synopsis>
     </para>

     <para>
      <symbol>NULL</symbol> est renvoyé si le numéro de colonne est en dehors de la
      plage.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfnumber">
    <term><function>PQfnumber</function><indexterm><primary>PQfnumber</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le numéro de colonne associé au nom de la colonne donné.
      <synopsis>int PQfnumber(const PGresult *res,
                     const char *column_name);
      </synopsis>
     </para>

     <para>
      -1 est renvoyé si le nom donné ne correspond à aucune colonne.
     </para>

     <para>
      Le nom donné est traité comme un identifiant dans une commande SQL,
      c'est-à-dire qu'il est mis en minuscule sauf s'il est entre des
      guillemets doubles. Par exemple, pour le résultat de la requête
      suivante&nbsp;:
      <programlisting>SELECT 1 AS FOO, 2 AS "BAR";
      </programlisting>
      nous devons obtenir les résultats suivants&nbsp;:
      <programlisting>PQfname(res, 0)              <lineannotation>foo</lineannotation>
      PQfname(res, 1)              <lineannotation>BAR</lineannotation>
      PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
      PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
      PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
      PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
      </programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQftable">
    <term><function>PQftable</function><indexterm><primary>PQftable</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie l'OID de la table à partir de laquelle la colonne donnée a été
      récupérée. Les numéros de colonnes commencent à 0.
      <synopsis>Oid PQftable(const PGresult *res,
                    int column_number);
      </synopsis>
     </para>

     <para>
      <literal>InvalidOid</literal> est renvoyé si le numéro de colonne est en dehors de la
      plage, ou si la colonne spécifiée n'est pas une simple référence à une colonne de
      table, ou lors de l'utilisation d'un protocole antérieur à la version 3.0. Vous
      pouvez requêter la table système <literal>pg_class</literal>
      pour déterminer exactement quelle table est référencée.
     </para>

     <para>
      Le type <type>Oid</type> et la constante
      <literal>InvalidOid</literal> seront définis lorsque vous incluerez le
      fichier d'en-tête <application>libpq</application>. Ils auront le même
      type entier.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQftablecol">
    <term><function>PQftablecol</function><indexterm><primary>PQftablecol</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le numéro de colonne (dans sa table) de la colonne
      correspondant à la colonne spécifiée de résultat de la requête. Les numéros de
      colonne du résultat commencent à 0, mais les colonnes de table ont des
      numéros supérieurs à zéro.
      <synopsis>int PQftablecol(const PGresult *res,
                      int column_number);
      </synopsis>
     </para>

     <para>
      Zéro est renvoyé si le numéro de colonne est en dehors de la plage, ou si la
      colonne spécifiée n'est pas une simple référence à une colonne de table, ou
      lors de l'utilisation d'un protocole antérieur à la version 3.0.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfformat">
    <term><function>PQfformat</function><indexterm><primary>PQfformat</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le code de format indiquant le format de la colonne donné. Les numéros
      de colonnes commencent à zéro.
      <synopsis>int PQfformat(const PGresult *res,
                     int column_number);
      </synopsis>
     </para>

     <para>
      Le code de format zéro indique une représentation textuelle des données,
      alors qu'un code un indique une représentation binaire (les
      autres codes sont réservés pour des définitions futures).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQftype">
    <term><function>PQftype</function><indexterm><primary>PQftype</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le type de données associé avec le numéro de colonne donné.
      L'entier renvoyé est le numéro OID interne du type. Les numéros de
      colonnes commencent à zéro.
      <synopsis>Oid PQftype(const PGresult *res,
                   int column_number);
      </synopsis>
     </para>

     <para>
      Vous pouvez lancer des requêtes sur la table système <literal>pg_type</literal>
      pour obtenir les noms et propriétés des différents types de données.
      Les <acronym>OID</acronym> des types de données intégrés sont définis dans le
      fichier <filename>src/include/catalog/pg_type.h</filename> dans le code
      source.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfmod">
    <term><function>PQfmod</function><indexterm><primary>PQfmod</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le modificateur de type de la colonne associée avec le numéro
      de colonne donné. Les numéros de colonnes commencent à zéro.
      <synopsis>int PQfmod(const PGresult *res,
                  int column_number);
      </synopsis>
     </para>

     <para>
      L'interprétation des valeurs du modificateur est spécifique au type&nbsp;;
      typiquement elles indiquent la précision ou les limites de taille.
      La valeur -1 est
      utilisée pour indiquer <quote>aucune information disponible</quote>. La
      plupart des types de données n'utilisent pas les modificateurs, auquel cas la
      valeur est toujours -1.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfsize">
    <term><function>PQfsize</function><indexterm><primary>PQfsize</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie la taille en octets de la colonne associée au numéro de
      colonne donné. Les numéros de colonnes commencent à 0.
      <synopsis>int PQfsize(const PGresult *res,
                   int column_number);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQfsize"/> renvoie l'espace alloué pour cette colonne dans une ligne
      de la base de données, en d'autres termes la taille de la représentation
      interne du serveur du type de données (en conséquence ce n'est pas
      réellement utile pour les clients). Une valeur négative indique que les types de
      données ont une longueur variable.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQbinaryTuples">
    <term><function>PQbinaryTuples</function><indexterm><primary>PQbinaryTuples</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie 1 si <structname>PGresult</structname> contient des données binaires et 0 s'il
      contient des données texte.
      <synopsis>int PQbinaryTuples(const PGresult *res);
      </synopsis>
     </para>

     <para>
      Cette fonction est obsolète (sauf dans le cas d'une utilisation en relation avec
      <command>COPY</command>) car un seul <structname>PGresult</structname> peut contenir du texte
      dans certaines colonnes et des données binaires dans d'autres.
      <xref linkend="libpq-PQfformat"/> est à préférer. <xref linkend="libpq-PQbinaryTuples"/>
      renvoie 1 seulement si toutes les colonnes du résultat sont dans un format
      binaire (format 1).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQgetvalue">
    <term><function>PQgetvalue</function><indexterm><primary>PQgetvalue</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie la valeur d'un seul champ d'une seule ligne d'un
      <structname>PGresult</structname>. Les numéros de lignes et de
      colonnes commencent à zéro. L'appelant ne devrait pas libérer
      directement le résultat. Il sera libéré quand le pointeur
      <structname>PGresult</structname> associé sera passé à
      <xref linkend="libpq-PQclear"/>.
      <synopsis>char* PQgetvalue(const PGresult *res,
                        int row_number,
                        int column_number);
      </synopsis>
     </para>

     <para>
      Pour les données au format texte, la valeur renvoyée par
      <xref linkend="libpq-PQgetvalue"/> est une représentation au format chaîne de
      caractères terminée par un octet nul de la valeur du champ. Pour les données au
      format binaire, la valeur dans la représentation binaire est déterminée par le
      type de la donnée, fonctions <function>typsend</function> et
      <function>typreceive</function>. (La valeur est en fait suivie d'un octet
      zéro dans ce cas aussi, mais ce n'est pas réellement utile car la valeur
      a des chances de contenir d'autres valeurs NULL embarquées).
     </para>

     <para>
      Une chaîne vide est renvoyée si la valeur du champ est NULL. Voir
      <xref linkend="libpq-PQgetisnull"/> pour distinguer les valeurs NULL des
      chaînes vides.
     </para>

     <para>
      Le pointeur renvoyé par <xref linkend="libpq-PQgetvalue"/> pointe vers le stockage
      qui fait partie de la structure <structname>PGresult</structname>. Personne ne
      devrait modifier les données vers lesquelles il pointe, et tout le monde
      devrait copier les données dans un autre stockage explicitement si elles
      doivent être utilisées après la durée de vie de la struture
      <structname>PGresult</structname>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQgetisnull">
    <term><function>PQgetisnull</function><indexterm><primary>PQgetisnull</primary></indexterm></term>
    <listitem>
     <indexterm><primary>valeur NULL</primary><secondary sortas="libpq">dans
       libpq</secondary></indexterm>
     <para>
      Teste un champ pour savoir s'il est NULL. Les numéros de lignes et de
      colonnes commencent à 0.
      <synopsis>int PQgetisnull(const PGresult *res,
                       int row_number,
                       int column_number);
      </synopsis>
     </para>

     <para>
      Cette fonction renvoie 1 si le champ est nul et 0 s'il contient une valeur non
      NULL (notez que <xref linkend="libpq-PQgetvalue"/> renverra une chaîne vide, et
      non pas un pointeur NULL, pour un champ NULL).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQgetlength">
    <term><function>PQgetlength</function><indexterm><primary>PQgetlength</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie la longueur réelle de la valeur d'un champ en octet. Les
      numéros de lignes et de colonnes commencent à 0.
      <synopsis>int PQgetlength(const PGresult *res,
                      int row_number,
                      int column_number);
      </synopsis>
     </para>

     <para>
      C'est la longueur réelle des données pour cette donnée en particulier,
      c'est-à-dire la taille de l'objet pointé par <xref linkend="libpq-PQgetvalue"/>.
      Pour le format textuel, c'est identique à <function>strlen()</function>. Pour le format
      binaire, c'est une information essentielle. Notez que l'on ne devrait
      <emphasis>pas</emphasis> se fier à <xref linkend="libpq-PQfsize"/> pour
      obtenir la taille réelle des données.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQnparams">
    <term><function>PQnparams</function><indexterm><primary>PQnparams</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le nombre de paramètres d'une instruction préparée.
      <synopsis>
       int PQnparams(const PGresult *res);
      </synopsis>
     </para>

     <para>
      Cette fonction est utile seulement pour inspecter le résultat de
      <xref linkend="libpq-PQdescribePrepared"/>. Pour les autres types de requêtes,
      elle renverra zéro.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQparamtype">
    <term><function>PQparamtype</function><indexterm><primary>PQparamtype</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le type de donnée du paramètre indiqué dans l'instruction.
      Les numéros des paramètres commencent à 0.
      <synopsis>
       Oid PQparamtype(const PGresult *res, int param_number);
      </synopsis>
     </para>

     <para>
      Cette fonction est utile seulement pour inspecter le résultat de
      <xref linkend="libpq-PQdescribePrepared"/>. Pour les autres types de requêtes,
      elle renverra zéro.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQprint">
    <term><function>PQprint</function><indexterm><primary>PQprint</primary></indexterm></term>
    <listitem>
     <para>
      Affiche toutes les lignes et, optionnellement, les noms des colonnes
      dans le flux de sortie spécifié.
      <synopsis>void PQprint(FILE* fout,      /* flux de sortie */
                   const PGresult *res,
                   const PQprintOpt *po);

        typedef struct
        {
            pqbool  header;      /* affiche les en-têtes des champs et le nombre de
                                    lignes */
            pqbool  align;       /* aligne les champs */
            pqbool  standard;    /* vieux format (mort) */
            pqbool  html3;       /* affiche les tables en HTML */
            pqbool  expanded;    /* étend les tables */
            pqbool  pager;       /* utilise le paginateur pour la sortie si nécessaire
                                    */
            char    *fieldSep;   /* séparateur de champ */
            char    *tableOpt;   /* attributs des éléments de table HTML */
            char    *caption;    /* titre de la table HTML */
            char    **fieldName; /* Tableau terminé par un NULL des noms de remplacement
                                    des champs */
        } PQprintOpt;
      </synopsis>
     </para>

     <para>
      Cette fonction était auparavant utilisée par <application>psql</application>
      pour afficher les résultats des requêtes mais ce n'est plus le cas. Notez
      qu'elle assume que les données sont dans un format textuel.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="libpq-exec-nonselect">
  <title>Récupérer d'autres informations de résultats</title>

  <para>
   Ces fonctions sont utilisées pour extraire d'autres informations des objets
   <structname>PGresult</structname>.
  </para>

  <variablelist>
   <varlistentry id="libpq-PQcmdStatus">
    <term><function>PQcmdStatus</function><indexterm><primary>PQcmdStatus</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie l'état de la commande de l'instruction SQL qui a généré le
      <structname>PGresult</structname>.
      <synopsis>char * PQcmdStatus(PGresult *res);
      </synopsis>
     </para>
     <para>
      D'habitude, c'est juste le nom de la commande mais elle peut inclure des
      données supplémentaires comme le nombre de lignes traitées.
      L'appelant ne devrait pas libérer directement le résultat. Il sera libéré
      quand le pointeur <structname>PGresult</structname> associée sera passé à
      <xref linkend="libpq-PQclear"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQcmdTuples">
    <term><function>PQcmdTuples</function><indexterm><primary>PQcmdTuples</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le nombre de lignes affectées par la commande SQL.
      <synopsis>char * PQcmdTuples(PGresult *res);
      </synopsis>
     </para>

     <para>
      Cette fonction renvoie une chaîne contenant le nombre de lignes affectées par
      l'instruction <acronym>SQL</acronym> qui a généré <structname>PGresult</structname>. Cette
      fonction ne peut être utilisée qu'après l'exécution d'une instruction
      <command>SELECT</command>, <command>CREATE TABLE AS</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command>, <command>MOVE</command>,
      <command>FETCH</command> ou <command>COPY</command>,
      ou un <command>EXECUTE</command> d'une instruction préparée
      contenant une instruction <command>INSERT</command>, <command>UPDATE</command> ou
      <command>DELETE</command>. Si la commande qui a généré <structname>PGresult</structname> était
      autre chose, <xref linkend="libpq-PQcmdTuples"/> renverrait directement une chaîne vide.
      L'appelant ne devrait pas libérer la valeur de retour directement. Elle sera
      libérée quand le pointeur <structname>PGresult</structname> associée sera passé à
      <xref linkend="libpq-PQclear"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQoidValue">
    <term><function>PQoidValue</function><indexterm><primary>PQoidValue</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie l'OID<indexterm><primary>OID</primary><secondary>dans
      libpq</secondary></indexterm> de la ligne insérée, si la commande
      <acronym>SQL</acronym> était un
      <command>INSERT</command> qui a inséré exactement une ligne dans une
      table comprenant des OID, ou un <command>EXECUTE</command> d'une requête
      préparée contenant une instruction <command>INSERT</command> convenable.
      Sinon cette fonction renvoie <literal>InvalidOid</literal>. Cette
      fonction renverra aussi <literal>InvalidOid</literal> si la table
      touchée par l'instruction <command>INSERT</command> ne contient pas d'OID.
      <synopsis>Oid PQoidValue(const PGresult *res);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQoidStatus">
    <term><function>PQoidStatus</function><indexterm><primary>PQoidStatus</primary></indexterm></term>
    <listitem>
     <para>
      Cette fonction est obsolète. Utilisez plutôt
      <xref linkend="libpq-PQoidValue"/>. De plus, elle n'est pas compatible
      avec les threads. Elle renvoie une chaîne contenant l'OID de la
      ligne insérée alors que <xref linkend="libpq-PQoidValue"/> renvoie
      la valeur de l'OID.
      <synopsis>char * PQoidStatus(const PGresult *res);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect2>

 <sect2 id="libpq-exec-escape-string">
  <title>Échapper les chaînes dans les commandes SQL</title>

  <indexterm zone="libpq-exec-escape-string">
   <primary>chaînes d'échappement</primary>
   <secondary>dans libpq</secondary>
  </indexterm>

  <variablelist>
   <varlistentry id="libpq-PQescapeLiteral">
    <term>
     <function>PQescapeLiteral</function>
     <indexterm>
      <primary>PQescapeLiteral</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <synopsis>
        char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQescapeLiteral"/> échappe une chaîne pour l'utiliser
      dans une commande SQL. C'est utile pour insérer des données comme des
      constantes dans des commandes SQL. Certains caractères, comme les
      guillemets et les antislashs, doivent être traités avec des caractères
      d'échappement pour éviter qu'ils ne soient traités d'après leur
      signification spéciale par l'analyseur SQL.
      <xref linkend="libpq-PQescapeLiteral"/> réalise cette opération.
     </para>

     <para>
      <xref linkend="libpq-PQescapeLiteral"/> renvoie une version échappée du
      paramètre <parameter>str</parameter> dans une mémoire allouée avec
      <function>malloc()</function>. Cette mémoire devra être libérée en
      utilisant <function>PQfreemem()</function> quand le résultat ne sera
      plus utile. Un octet zéro final n'est pas requis et ne doit pas être
      compté dans <parameter>length</parameter>. (Si un octet zéro est
      découvert avant le traitement de <parameter>length</parameter>
      octets, <xref linkend="libpq-PQescapeLiteral"/> s'arrête au zéro&nbsp;; ce
      comportement est celui de <function>strncpy</function>.) Les
      caractères spéciaux de la chaîne en retour ont été remplacés pour qu'ils
      puissent être traités correctement par l'analyseur de chaînes de
      <productname>PostgreSQL</productname>. Un octet zéro final est aussi
      ajouté. Les guillemets simples qui doivent entourer les chaînes littérales
      avec <productname>PostgreSQL</productname> sont inclus dans la chaîne
      résultante.
     </para>

     <para>
      En cas d'erreur, <xref linkend="libpq-PQescapeLiteral"/> renvoit
      <symbol>NULL</symbol> et
      un message adéquat est stocké dans l'objet
      <parameter>conn</parameter>.
     </para>

     <tip>
      <para>
       Il est particulièrement important de faire un échappement propre lors
       de l'utilisation de chaînes provenant d'une source qui n'est pas
       de confiance. Sinon, il existe un risque de sécurité&nbsp;:
       vous vous exposez à une attaque de type <quote>injection SQL</quote>
       avec des commandes SQL non voulues injectées dans votre base de
       données.
      </para>
     </tip>

     <para>
      Notez qu'il n'est pas nécessaire ni correct de faire un échappement quand
      une valeur est passée en tant que paramètre séparé dans
      <xref linkend="libpq-PQexecParams"/> ou ses routines sœurs.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQescapeIdentifier">
    <term>
     <function>PQescapeIdentifier</function>
     <indexterm>
      <primary>PQescapeIdentifier</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <synopsis>
        char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQescapeIdentifier"/> échappe une chaîne pour qu'elle
      puisse être utilisé en tant qu'identifiant SQL, par exemple pour le
      nom d'une table, d'une colonne ou d'une fonction. C'est utile quand un
      identifiant fourni par un utilisateur pourrait contenir des caractères
      spéciaux, qui sinon ne seraient pas interprétés comme faisant
      partie de l'identifiant par l'analyseur SQL, ou lorsque l'identifiant
      pourrait contenir des caractères en majuscule, dont la casse doit
      être préservée.
     </para>

     <para>
      <xref linkend="libpq-PQescapeIdentifier"/> renvoit une version du paramètre
      <parameter>str</parameter> échappée comme doit l'être un identifiant SQL,
      dans une mémoire allouée avec <function>malloc()</function>. Cette
      mémoire doit être libérée en utilisant <function>PQfreemem()</function>
      quand le résultat n'est plus nécessaire. Un octet zéro final n'est pas
      nécessaire et ne doit pas être comptabilisé dans
      <parameter>length</parameter>. (Si un octet zéro est trouvé avant
      le traitement de <parameter>length</parameter> octets,
      <xref linkend="libpq-PQescapeIdentifier"/> s'arrête au zéro&nbsp;; ce
      comportement est celui de <function>strncpy</function>.) Les
      caractères spéciaux de la chaîne en retour ont été remplacés pour que
      ce dernier soit traité proprement comme un identifiant SQL. Un octet
      zéro final est aussi ajouté. La chaîne de retour sera aussi entourée de
      guillemets doubles.
     </para>

     <para>
      En cas d'erreur, <xref linkend="libpq-PQescapeIdentifier"/> renvoit
      <symbol>NULL</symbol> et
      un message d'erreur adéquat est stocké dans l'objet
      <parameter>conn</parameter>.
     </para>

     <tip>
      <para>
       Comme avec les chaînes littérales, pour empêcher les attaques par injection
       SQL, les identifiants SQL doivent être échappés lorsqu'ils proviennent
       d'une source non sûre.
      </para>
     </tip>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQescapeStringConn">
    <term>
     <function>PQescapeStringConn</function>
     <indexterm>
      <primary>PQescapeStringConn</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <synopsis>
        size_t PQescapeStringConn (PGconn *conn,
                                   char *to, const char *from, size_t length,
                                   int *error);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQescapeStringConn"/>> échappe les chaînes littérales de
      la même façon que <xref linkend="libpq-PQescapeLiteral"/>. Contrairement à
      <xref linkend="libpq-PQescapeLiteral"/>, l'appelant doit fournir un tampon
      d'une taille appropriée. De plus, <xref linkend="libpq-PQescapeStringConn"/>>
      n'ajoute pas de guillemets simples autour des chaînes littérales de
      <productname>PostgreSQL</productname>&nbsp;; elles doivent être ajoutées
      dans la commande SQL où ce résultat sera inséré. Le paramètre
      <parameter>from</parameter> pointe vers le premier caractère de la chaîne
      à échapper, et le paramètre <parameter>length</parameter> précise le
      nombre d'octets contenus dans cette chaîne. Un octet zéro final n'est
      pas nécessaire et ne doit pas être comptabilisé dans
      <parameter>length</parameter>. (Si un octet zéro est trouvé avant
      le traitement de <parameter>length</parameter> octets,
      <xref linkend="libpq-PQescapeStringConn"/> s'arrête au zéro&nbsp;; ce
      comportement est celui de <function>strncpy</function>.)
      <parameter>to</parameter> doit pointer vers un tampon qui peut contenir
      au moins un octet de plus que deux fois la valeur de
      <parameter>length</parameter>, sinon le comportement de la fonction
      est indéfini. Le comportement est indéfini si les chaînes
      <parameter>to</parameter> et <parameter>from</parameter> se recouvrent.
     </para>

     <para>
      Si le paramètre <parameter>error</parameter> est différent de <symbol>NULL</symbol>,
      alors <literal>*error</literal> est configuré à zéro en cas de succès,
      et est différent de zéro en cas d'erreur. Actuellement, les seules
      conditions permettant une erreur impliquent des encodages multi-octets
      dans la chaîne source. La chaîne en sortie est toujours générée en cas
      d'erreur mais on peut s'attendre à ce que le serveur la rejette comme une
      chaîne malformée. En cas d'erreur, un message adéquat est stocké dans
      l'objet <parameter>conn</parameter>, que <parameter>error</parameter>
      soit <symbol>NULL</symbol> ou non.
     </para>

     <para>
      <xref linkend="libpq-PQescapeStringConn"/> renvoit le nombre d'octets écrits
      dans <parameter>to</parameter>, sans inclure l'octet zéro final.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQescapeString">
    <term><function>PQescapeString</function><indexterm><primary>PQescapeString</primary></indexterm></term>

    <listitem>
     <para>
      <xref linkend="libpq-PQescapeString"/> est une version ancienne et obsolète de
      <xref linkend="libpq-PQescapeStringConn"/>.
      <synopsis>
        size_t PQescapeString (char *to, const char *from, size_t length);
      </synopsis>
     </para>

     <para>
      La seule différence avec <xref linkend="libpq-PQescapeStringConn"/> tient
      dans le fait que <xref linkend="libpq-PQescapeString"/> n'a pas de
      paramètres <parameter>conn</parameter> et <parameter>error</parameter>.
      À cause de cela, elle ne peut ajuster son
      comportement en fonction des propriétés de la connexion (comme l'encodage des
      caractères) et du coup, <emphasis>elle pourrait founir des résultats
      erronés</emphasis>. De plus, elle ne peut pas renvoyer de conditions
      d'erreur.
     </para>

     <para>
      <xref linkend="libpq-PQescapeString"/> peut être utilisé en toute sécurité avec
      des programmes client utilisant une seule connexion
      <productname>PostgreSQL</productname> à la fois (dans ce cas,
      il peut trouver ce qui l'intéresse <quote>en arrière-plan</quote>).
      Dans d'autres contextes, c'est un risque en terme de sécurité. Cette
      fonction devrait être évitée et remplacée par
      <xref linkend="libpq-PQescapeStringConn"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQescapeByteaConn">
    <term><function>PQescapeByteaConn</function><indexterm><primary>PQescapeBytea</primary></indexterm></term>
    <listitem>
     <para>
      Échappe des données binaires à utiliser à l'intérieur d'une commande SQL avec
      le type <type>bytea</type>. Comme avec <xref linkend="libpq-PQescapeStringConn"/>,
      c'est seulement utilisé pour insérer des données directement dans une chaîne
      de commande SQL.
      <synopsis>unsigned char *PQescapeByteaConn(PGconn *conn,
                                const unsigned char *from,
                                size_t from_length,
                                size_t *to_length);</synopsis>
      </para>

      <para>
       Certaines valeurs d'octets <emphasis>doivent</emphasis> être échappées
       lorsqu'elles font partie d'un littéral <type>bytea</type> dans une
       instruction <acronym>SQL</acronym>. <function>PQescapeByteaConn</function>
       échappe les octets en utilisant soit un codage hexadécimal soit un
       échappement avec des antislashs. Voir <xref linkend="datatype-binary"/> pour
       plus d'informations.
      </para>

      <para>
       Le paramètre <parameter>from</parameter> pointe sur le premier octet de la
       chaîne à échapper et le paramètre <parameter>from_length</parameter> donne le
       nombre d'octets de cette chaîne binaire (un octet zéro final n'est
       ni nécessaire ni compté). Le paramètre <parameter>to_length</parameter>
       pointe vers une variable qui contiendra la longueur de la chaîne échappée
       résultante. Cette longueur inclut l'octet zéro de terminaison.
      </para>

      <para>
       <xref linkend="libpq-PQescapeByteaConn"/> renvoie une version échappée du paramètre
       <parameter>from</parameter> dans la mémoire allouée avec
       <function>malloc()</function>. Cette mémoire doit être libérée avec
       <function>PQfreemem</function> lorsque le résultat n'est plus nécessaire. Tous les
       caractères spéciaux de la chaîne de retour sont remplacés de façon à ce
       qu'ils puissent être traités proprement par l'analyseur de chaînes littérales
       de <productname>PostgreSQL</productname> et par la fonction d'entrée
       <type>bytea</type>. Un octet zéro final est aussi
       ajouté. Les guillemets simples qui encadrent les chaînes littérales de
       <productname>PostgreSQL</productname> ne font pas partie de la chaîne
       résultante.
      </para>
      <para>
       En cas d'erreur, un pointeur NULL est renvoyé et un message d'erreur adéquat
       est stocké dans l'objet <parameter>conn</parameter>. Actuellement, la seule erreur
       possible est une mémoire insuffisante pour stocker la chaîne résultante.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQescapeBytea">
     <term><function>PQescapeBytea</function><indexterm><primary>PQescapeBytea</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQescapeBytea"/> est une version ancienne et obsolète de
       <xref linkend="libpq-PQescapeByteaConn"/>.
       <synopsis>
        unsigned char *PQescapeBytea(const unsigned char *from,
                                     size_t from_length,
                                     size_t *to_length);
      </synopsis>
     </para>

     <para>
      La seule différence avec <xref linkend="libpq-PQescapeByteaConn"/> est que
      <xref linkend="libpq-PQescapeBytea"/> ne prend pas de paramètre
      <structname>PGconn</structname>. De ce fait, <xref linkend="libpq-PQescapeBytea"/>
      ne peut être utilisé en toute sécurité que dans des programmes qui n'utilisent
      qu'une seule connexion <productname>PostgreSQL</productname> à la fois (dans
      ce cas, il peut trouver ce dont il a besoin <quote>en arrière-plan</quote>).
      Elle <emphasis>pourrait donner des résultats erronés</emphasis> si elle est
      utilisé dans des programmes qui utilisent plusieurs connexions de bases de
      données (dans ce cas, utilisez <xref linkend="libpq-PQescapeByteaConn"/>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQunescapeBytea">
    <term><function>PQunescapeBytea</function><indexterm><primary>PQunescapeBytea</primary></indexterm></term>
    <listitem>
     <para>
      Convertit une représentation de la chaîne en donnés binaires &mdash;
      l'inverse de <xref linkend="libpq-PQescapeBytea"/>. Ceci est nécessaire lors de
      la récupération de données <type>bytea</type> en format texte, mais pas lors
      de sa récupération au format binaire.

      <synopsis>unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
      </synopsis>
     </para>

     <para>
      Le paramètre <parameter>from</parameter> pointe vers une chaîne de
      telle qu'elle pourrait provenir de <xref linkend="libpq-PQgetvalue"/>
      lorsque la colonne est de type <type>bytea</type>.
      <xref linkend="libpq-PQunescapeBytea"/> convertit cette représentation de la
      chaîne en sa représentation binaire. Elle renvoie un pointeur vers le tampon
      alloué avec <function>malloc()</function>, ou <symbol>NULL</symbol> en cas d'erreur, et place
      la taille du tampon dans <parameter>to_length</parameter>. Le résultat doit
      être libéré en utilisant <xref linkend="libpq-PQfreemem"/> lorsqu'il n'est plus
      nécessaire.
     </para>

     <para>
      Cette conversion n'est pas l'inverse exacte de <xref linkend="libpq-PQescapeBytea"/>
      car la chaîne n'est pas supposée être "échappée" tel qu'elle est renvoyée
      par <xref linkend="libpq-PQgetvalue"/>. Cela veut dire, notamment,
      qu'il n'y a pas besoin de réfléchir à la mise entre
      guillemets de la chaîne, et donc pas besoin d'un paramètre <structname>PGconn</structname>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect2>
</sect1>

<sect1 id="libpq-async">
 <title>Traitement des commandes asynchrones</title>

 <indexterm zone="libpq-async"><primary>connexion non bloquante</primary></indexterm>

 <para>
  La fonction <xref linkend="libpq-PQexec"/> est adéquate pour soumettre des
  commandes aux applications standards, synchrones. Néanmoins, elle a quelques
  défauts pouvant être d'importance à certains utilisateurs&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     <xref linkend="libpq-PQexec"/> attend que la commande se termine. L'application
     pourrait avoir du travail ailleurs (comme le rafraîchissement de
     l'interface utilisateur), auquel cas elle ne voudra pas être bloquée en attente
     de la réponse.
    </para>
   </listitem>
   <listitem>
    <para>
     Comme l'exécution de l'application cliente est suspendue en attendant le
     résultat, il est difficile pour l'application de décider qu'elle voudrait
     annuler la commande en cours (c'est possible avec un gestionnaire de signaux
     mais pas autrement).
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="libpq-PQexec"/> ne peut renvoyer qu'une structure
     <structname>PGresult</structname>. Si la chaîne de commande soumise contient
     plusieurs commandes <acronym>SQL</acronym>, toutes les structures
     <structname>PGresult</structname> sont annulées par
     <xref linkend="libpq-PQexec"/>, sauf la dernière.
    </para>
   </listitem>

   <listitem>
    <para>
     <xref linkend="libpq-PQexec"/> récupère toujours le résultat entier de la
     commande, le mettant en cache dans une seule structure
     <structname>PGresult</structname>. Bien que cela simplifie la logique
     de la gestion des erreurs pour l'application, cela peut ne pas se
     révéler pratique pour les résultats contenant de nombreuses lignes.
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Les applications qui n'apprécient pas ces limitations peuvent utiliser à la
  place les fonctions sous-jacentes à partir desquelles <xref
  linkend="libpq-PQexec"/> est construit&nbsp;: <xref
  linkend="libpq-PQsendQuery"/> et <xref linkend="libpq-PQgetResult"/>. Il
  existe aussi <xref linkend="libpq-PQsendQueryParams"/>, <xref
  linkend="libpq-PQsendPrepare"/>, <xref
  linkend="libpq-PQsendQueryPrepared"/>, <xref
  linkend="libpq-PQsendDescribePrepared"/> et <xref
  linkend="libpq-PQsendDescribePortal"/>, pouvant être utilisées avec <xref
  linkend="libpq-PQgetResult"/> pour dupliquer les fonctionnalités de
  respectivement <xref linkend="libpq-PQexecParams"/>, <xref
  linkend="libpq-PQprepare"/>, <xref linkend="libpq-PQexecPrepared"/>, <xref
  linkend="libpq-PQdescribePrepared"/> et <xref
  linkend="libpq-PQdescribePortal"/>.

  <variablelist>
   <varlistentry id="libpq-PQsendQuery">
    <term><function>PQsendQuery</function><indexterm><primary>PQsendQuery</primary></indexterm></term>
    <listitem>
     <para>
      Soumet une commande au serveur sans attendre le(s) résultat(s). 1 est
      renvoyé si la commande a été correctement envoyée et 0 dans le cas
      contraire (auquel cas, utilisez la fonction <xref linkend="libpq-PQerrorMessage"/>
      pour obtenir plus d'informations sur l'échec).
      <synopsis>int PQsendQuery(PGconn *conn, const char *command);</synopsis>

       Après un appel réussi à <xref linkend="libpq-PQsendQuery"/>, appelez
       <xref linkend="libpq-PQgetResult"/> une ou plusieurs fois pour obtenir
       les résultats. <xref linkend="libpq-PQsendQuery"/> ne peut pas être appelé
       de nouveau (sur la même connexion) tant que
       <xref linkend="libpq-PQgetResult"/> ne renvoie pas de pointeur NULL,
       indiquant que la commande a terminé.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendQueryParams">
     <term><function>PQsendQueryParams</function><indexterm><primary>PQsendQueryParams</primary></indexterm></term>
     <listitem>
      <para>
       Soumet une commande et des paramètres séparés au serveur sans
       attendre le(s) résultat(s).
       <synopsis>int PQsendQueryParams(PGconn *conn,
                             const char *command,
                             int nParams,
                             const Oid *paramTypes,
                             const char * const *paramValues,
                             const int *paramLengths,
                             const int *paramFormats,
                             int resultFormat);
      </synopsis>

      Ceci est équivalent à <xref linkend="libpq-PQsendQuery"/> sauf que les
      paramètres de requêtes peuvent être spécifiés séparément à partir de la chaîne de
      requête. Les paramètres de la fonction sont gérés de façon identique à
      <xref linkend="libpq-PQexecParams"/>. Comme
      <xref linkend="libpq-PQexecParams"/>, cela ne fonctionnera pas
      pour les connexions utilisant le protocole 2.0 et cela ne permet
      qu'une seule commande dans la chaîne de requête.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsendPrepare">
    <term><function>PQsendPrepare</function><indexterm><primary>PQsendPrepare</primary></indexterm></term>
    <listitem>
     <para>
      Envoie une requête pour créer une instruction préparée avec les paramètres
      donnés et redonne la main sans attendre la fin de son exécution.
      <synopsis>      int PQsendPrepare(PGconn *conn,
         const char *stmtName,
         const char *query,
         int nParams,
         const Oid *paramTypes);
      </synopsis>

      Ceci est la version asynchrone de <xref linkend="libpq-PQprepare"/>&nbsp;: elle
      renvoie 1 si elle a été capable d'envoyer la requête, 0 sinon. Après un
      appel terminé avec succès, appelez <xref linkend="libpq-PQgetResult"/> pour
      déterminer si le serveur a créé avec succès l'instruction préparée. Les
      paramètres de la fonction sont gérés de façon identique à
      <xref linkend="libpq-PQprepare"/>. Comme <xref linkend="libpq-PQprepare"/>, cela ne
      fonctionnera pas sur les connexions utilisant le protocole 2.0.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsendQueryPrepared">
    <term><function>PQsendQueryPrepared</function><indexterm><primary>PQsendQueryPrepared</primary></indexterm></term>
    <listitem>
     <para>
      Envoie une requête pour exécuter une instruction préparée avec des
      paramètres donnés sans attendre le(s) résultat(s).
      <synopsis>int PQsendQueryPrepared(PGconn *conn,
                               const char *stmtName,
                               int nParams,
                               const char * const *paramValues,
                               const int *paramLengths,
                               const int *paramFormats,
                               int resultFormat);
      </synopsis>

      Ceci est similaire à <xref linkend="libpq-PQsendQueryParams"/> mais la
      commande à exécuter est spécifiée en nommant une instruction
      préparée précédente au lieu de donner une chaîne contenant la
      requête. Les paramètres de la fonction sont gérés de façon identique à
      <xref linkend="libpq-PQexecPrepared"/>. Comme
      <xref linkend="libpq-PQexecPrepared"/>, cela ne fonctionnera pas pour les
      connexions utilisant le protocole 2.0.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsendDescribePrepared">
    <term><function>PQsendDescribePrepared</function><indexterm><primary>PQsendDescribePrepared</primary></indexterm></term>
    <listitem>
     <para>
      Soumet une requête pour obtenir des informations sur l'instruction
      préparée indiquée sans attendre sa fin.
      <synopsis>
        int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
      </synopsis>

      Ceci est la version asynchrone de <xref linkend="libpq-PQdescribePrepared"/>&nbsp;:
      elle renvoie 1 si elle a été capable d'envoyer la requête, 0 dans le cas
      contraire. Après un appel réussi, appelez <xref linkend="libpq-PQgetResult"/>
      pour obtenir les résultats.
      Les paramètres de la fonction sont gérés de façon identique à
      <xref linkend="libpq-PQdescribePrepared"/>. Comme
      <xref linkend="libpq-PQdescribePrepared"/>, cela ne fontionnera pas avec
      les connexions utilisant le protocole 2.0.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsendDescribePortal">
    <term><function>PQsendDescribePortal</function><indexterm><primary>PQsendDescribePortal</primary></indexterm></term>
    <listitem>
     <para>
      Soumet une requête pour obtenir des informations sur le portail indiqué
      sans attendre la fin de la commande.
      <synopsis>
        int PQsendDescribePortal(PGconn *conn, const char *portalName);
      </synopsis>

      Ceci est la version asynchrone de <xref linkend="libpq-PQdescribePortal"/>&nbsp;:
      elle renvoie 1 si elle a été capable d'envoyer la requête, 0 dans le cas
      contraire. Après un appel réussi, appelez <xref linkend="libpq-PQgetResult"/>
      pour obtenir les résultats.
      Les paramètres de la fonction sont gérés de façon identique à
      <xref linkend="libpq-PQdescribePortal"/>. Comme
      <xref linkend="libpq-PQdescribePortal"/>, cela ne fontionnera pas avec
      les connexions utilisant le protocole 2.0.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQgetResult">
    <term><function>PQgetResult</function><indexterm><primary>PQgetResult</primary></indexterm></term>
    <listitem>
     <para>
      Attend le prochain résultat d'un appel précédent à
      <xref linkend="libpq-PQsendQuery"/>,
      <xref linkend="libpq-PQsendQueryParams"/>,
      <xref linkend="libpq-PQsendPrepare"/>,
      <xref linkend="libpq-PQsendQueryPrepared"/>,
      <xref linkend="libpq-PQsendDescribePrepared"/> ou
      <xref linkend="libpq-PQsendDescribePortal"/>, et le renvoie. Un pointeur
      NULL est renvoyé quand la commande est terminée et qu'il n'y aura plus
      de résultats.
      <synopsis>PGresult *PQgetResult(PGconn *conn);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQgetResult"/> doit être appelé de façon répétée
      jusqu'à ce qu'il retourne un pointeur NULL indiquant que la commande
      s'est terminée. (Si appelée à un moment où aucune commande n'est
      active, <xref linkend="libpq-PQgetResult"/> renverra juste immédiatement un
      pointeur NULL). Chaque résultat non NULL provenant de
      <xref linkend="libpq-PQgetResult"/> devrait être traité en utilisant les
      mêmes fonctions d'accès à <structname>PGresult</structname> que celles
      précédemment décrites. N'oubliez pas de libérer chaque objet résultat
      avec <xref linkend="libpq-PQclear"/> quand vous en avez terminé.
      Notez que <xref linkend="libpq-PQgetResult"/> bloquera seulement si la
      commande est active et que les données nécessaires en réponse n'ont
      pas encore été lues par <function>PQconsumeInput</function>.
     </para>

     <note>
      <para>
       Même quand <xref linkend="libpq-PQresultStatus"/> indique une erreur
       fatale, <xref linkend="libpq-PQgetResult"/> doit être appelé
       jusqu'à ce qu'il renvoie un pointeur NULL pour permettre à
       <application>libpq</application> de traiter l'information sur
       l'erreur correctement.
      </para>
     </note>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Utiliser <xref linkend="libpq-PQsendQuery"/> et <xref linkend="libpq-PQgetResult"/>
  résout un des problèmes de <xref linkend="libpq-PQexec"/>&nbsp;: si une chaîne de
  commande contient plusieurs commandes <acronym>SQL</acronym>, les résultats de
  ces commandes peuvent être obtenus individuellement (ceci permet une simple
  forme de traitement en parallèle&nbsp;: le client peut gérer les résultats
  d'une commande alors que le serveur travaille sur d'autres requêtes de la même
  chaîne de commandes).
 </para>

 <para>
  Une autre fonctionnalité fréquemment demandée, pouvant être obtenue avec
  <xref linkend="libpq-PQsendQuery"/> et <xref linkend="libpq-PQgetResult"/> est
  la récupération d'un gros résultat une ligne à la fois. Ceci est discuté
  dans <xref linkend="libpq-single-row-mode"/>.
 </para>

 <para>
  Néanmoins, appeler <xref linkend="libpq-PQgetResult"/>
  causera toujours un blocage du client jusqu'à la fin de la prochaine commande
  <acronym>SQL</acronym>. Ceci est évitable en utilisant proprement deux
  fonctions supplémentaires&nbsp;:

  <variablelist>
   <varlistentry id="libpq-PQconsumeInput">
    <term><function>PQconsumeInput</function><indexterm><primary>PQconsumeInput</primary></indexterm></term>
    <listitem>
     <para>
      Si l'entrée est disponible à partir du serveur, la consomme.
      <synopsis>int PQconsumeInput(PGconn *conn);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQconsumeInput"/> renvoie normalement 1 indiquant
      <quote>aucune erreur</quote>, mais renvoie zéro s'il y a eu une erreur (auquel
      cas <xref linkend="libpq-PQerrorMessage"/> peut être consulté). Notez que le
      résultat ne dit pas si des données ont été récupérées en entrée. Après avoir
      appelé <xref linkend="libpq-PQconsumeInput"/>, l'application devrait vérifier
      <xref linkend="libpq-PQisBusy"/> et/ou <function>PQnotifies</function> pour voir
      si leur état a changé.
     </para>
     <para>
      <xref linkend="libpq-PQconsumeInput"/> peut être appelée même si l'application
      n'est pas encore préparée à traiter un résultat ou une notification. La fonction
      lira les données disponibles et les sauvegardera dans un tampon indiquant
      ainsi qu'une lecture d'un <function>select()</function> est possible.
      L'application peut donc utiliser <xref linkend="libpq-PQconsumeInput"/> pour
      effacer la condition <function>select()</function> immédiatement, puis
      examiner les résultats à loisir.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQisBusy">
    <term><function>PQisBusy</function><indexterm><primary>PQisBusy</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie 1 si une commande est occupée, c'est-à-dire que
      <xref linkend="libpq-PQgetResult"/> bloque en attendant une entrée. Un zéro
      indique que <xref linkend="libpq-PQgetResult"/> peut être appelé avec
      l'assurance de ne pas bloquer.
      <synopsis>int PQisBusy(PGconn *conn);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQisBusy"/> ne tentera pas lui-même de lire les données à
      partir du serveur&nbsp;; du coup, <xref linkend="libpq-PQconsumeInput"/> doit être
      appelé d'abord ou l'état occupé ne prendra jamais fin.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Une application typique de l'utilisation de ces fonctions aura une boucle
  principale utilisant <function>select()</function> ou <function>poll()</function> pour
  attendre que toutes les conditions soient remplies. Une des conditions
  sera la disponibilité des données à partir du serveur, ce qui signifie des données
  lisibles pour <function>select()</function> sur le descripteur de
  fichier identifié par <xref linkend="libpq-PQsocket"/>. Lorsque la boucle
  principale détecte la disponibilité de données, elle devrait appeler
  <xref linkend="libpq-PQconsumeInput"/> pour lire l'en-tête. Elle peut ensuite appeler
  <xref linkend="libpq-PQisBusy"/> suivi par <xref linkend="libpq-PQgetResult"/> si
  <xref linkend="libpq-PQisBusy"/> renvoie false (0). Elle peut aussi appeler
  <function>PQnotifies</function> pour détecter les messages <command>NOTIFY</command>
  (voir la <xref linkend="libpq-notify"/>).
 </para>

 <para>
  Un client qui utilise
  <xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/> peut aussi
  tenter d'annuler une commande en cours de traitement par le
  serveur&nbsp;; voir la <xref linkend="libpq-cancel"/>. Mais quelle que soit la valeur
  renvoyée par <xref linkend="libpq-PQcancel"/>, l'application doit continuer avec
  la séquence normale de lecture du résultat en utilisant
  <xref linkend="libpq-PQgetResult"/>. Une annulation réussie causera simplement une
  fin plus rapide de la commande.
 </para>

 <para>
  En utilisant les fonctions décrites ci-dessus, il est possible d'éviter le
  blocage pendant l'attente de données du serveur. Néanmoins, il est toujours
  possible que l'application se bloque en attendant l'envoi vers le serveur.
  C'est relativement peu fréquent mais cela peut arriver si de très longues
  commandes SQL ou données sont envoyées (mais c'est bien plus probable si
  l'application envoie des données via <command>COPY IN</command>). Pour
  éviter cette possibilité et parvenir à des opérations de bases de données
  totalement non bloquantes, les fonctions supplémentaires suivantes peuvent
  être utilisées.

  <variablelist>
   <varlistentry id="libpq-PQsetnonblocking">
    <term><function>PQsetnonblocking</function><indexterm><primary>PQsetnonblocking</primary></indexterm></term>
    <listitem>
     <para>
      Initialise le statut non bloquant de la connexion.
      <synopsis>int PQsetnonblocking(PGconn *conn, int arg);
      </synopsis>
     </para>

     <para>
      Initialise l'état de la connexion à non bloquant si
      <parameter>arg</parameter> vaut 1 et à bloquant si
      <parameter>arg</parameter> vaut 0. Renvoie 0 si OK, -1 en cas d'erreur.
     </para>
     <para>
      Dans l'état non bloquant, les appels à
      <xref linkend="libpq-PQsendQuery"/>, <xref linkend="libpq-PQputline"/>,
      <xref linkend="libpq-PQputnbytes"/>, <xref linkend="libpq-PQputCopyData"/>
      et <xref linkend="libpq-PQendcopy"/> ne bloqueront pas mais renverront à la
      place une erreur s'ils ont besoin d'être de nouveau appelés.
     </para>
     <para>
      Notez que <xref linkend="libpq-PQexec"/> n'honore pas le mode non
      bloquant&nbsp;; s'il est appelé, il agira d'une façon bloquante malgré tout.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQisnonblocking">
    <term><function>PQisnonblocking</function><indexterm><primary>PQisnonblocking</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie le statut bloquant de la connexion à la base de données.
      <synopsis>int PQisnonblocking(const PGconn *conn);
      </synopsis>
     </para>

     <para>
      Renvoie 1 si la connexion est en mode non bloquant, 1 dans le
      cas contraire.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQflush">
    <term><function>PQflush</function><indexterm><primary>PQflush</primary></indexterm></term>
    <listitem>
     <para>
      Tente de vider les données des queues de sortie du serveur. Renvoie 0 en cas de
      succès (ou si la queue d'envoi est vide), -1 en cas d'échec quelle que soit la
      raison ou 1 s'il a été incapable d'envoyer encore toutes les données dans la
      queue d'envoi (ce cas arrive seulement si la connexion est non bloquante).
      <synopsis>int PQflush(PGconn *conn);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <para>
  Après avoir envoyé une commande ou des données dans une connexion non bloquante,
  appelez <xref linkend="libpq-PQflush"/>. S'il renvoie 1, attendez que la socket
  devienne prête en lecture ou en écriture. Si elle est prête en écriture,
  appelez de nouveau <xref linkend="libpq-PQflush"/>. Si elle est prête en lecture,
  appelez <xref linkend="libpq-PQconsumeInput"/>, puis appelez
  <xref linkend="libpq-PQflush"/>. Répétez jusqu'à ce que
  <xref linkend="libpq-PQflush"/> renvoie 0. (Il est nécessaire de vérifier si elle
  est prête en lecture, et de vidanger l'entrée avec
  <xref linkend="libpq-PQconsumeInput"/> car le serveur peut bloquer en essayant
  d'envoyer des données, par exemple des messages NOTICE, et ne va pas lire nos
  données tant que nous n'avons pas lu les siennes.) Une fois que
  <xref linkend="libpq-PQflush"/> renvoie 0, attendez que la socket soit disponible
  en lecture, puis lisez la réponse comme décrit ci-dessus.
 </para>

</sect1>

<sect1 id="libpq-single-row-mode">
 <title>Récupérer le résultats des requêtes ligne par ligne</title>

 <indexterm zone="libpq-single-row-mode">
  <primary>libpq</primary>
  <secondary>mode ligne-à-ligne</secondary>
 </indexterm>

 <para>
  D'habitude, <application>libpq</application> récupère le résultat complet
  d'une commande SQL et la renvoie à l'application sous la forme d'une seule
  structure <structname>PGresult</structname>. Ce peut être impraticable
  pour les commandes renvoyant un grand nombre de lignes. Dans
  de tels cas, les applications peuvent utiliser
  <xref linkend="libpq-PQsendQuery"/> et <xref linkend="libpq-PQgetResult"/> dans
  le <firstterm>mode ligne-à-ligne</firstterm>. Dans ce mode, les lignes du
  résultat sont renvoyées à l'application une par une, au fur et à mesure
  qu'elles sont reçues du serveur.
 </para>

 <para>
  Pour entrer dans le mode ligne-à-ligne, appelez
  <xref linkend="libpq-PQsetSingleRowMode"/> immédiatement après un appel
  réussi à <xref linkend="libpq-PQsendQuery"/> (ou une fonction similaire).
  Cette sélection de mode ne fonctionne que pour la requête en cours
  d'exécution. Puis appelez <xref linkend="libpq-PQgetResult"/> de façon répétée,
  jusqu'à ce qu'elle renvoit NULL, comme documenté dans <xref
  linkend="libpq-async"/>. Si la requête renvoit des lignes, elles sont renvoyées
  en tant qu'objets <structname>PGresult</structname> individuels, qui ressemblent
  à des résultats de requêtes standards en dehors du fait qu'elles ont le code
  de statut <literal>PGRES_SINGLE_TUPLE</literal> au lieu de
  <literal>PGRES_TUPLES_OK</literal>. Après la dernière ligne, ou immédiatement
  si la requête ne renvoit aucune ligne, un objet à zéro ligne avec le statut
  <literal>PGRES_TUPLES_OK</literal> est renvoyé&nbsp;; c'est le signal
  qu'aucune autre ligne ne va arriver. (Notez cependant qu'il est toujours
  nécessaire de continuer à appeler <xref linkend="libpq-PQgetResult"/> jusqu'à
  ce qu'elle renvoit NULL.) Tous les objets <structname>PGresult</structname>
  contiendront les mêmes données de description de lignes (noms de colonnes,
  types, etc.) qu'un objet <structname>PGresult</structname> standard aurait
  pour cette requête. Chaque objet doit être libéré avec la fonction
  <xref linkend="libpq-PQclear"/> comme d'ordinaire.
 </para>

 <para>
  <variablelist>
   <varlistentry id="libpq-PQsetSingleRowMode">
    <term>
     <function>PQsetSingleRowMode</function>
     <indexterm>
      <primary>PQsetSingleRowMode</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      Sélectionne le mode ligne simple pour la requête en cours d'exécution.

      <synopsis>
       int PQsetSingleRowMode(PGconn *conn);
      </synopsis>
     </para>

     <para>
      Cette fonction peut seulement être appelée immédiatement après
      <xref linkend="libpq-PQsendQuery"/> ou une de ses fonctions sœurs, avant
      toute autre opération sur la connexion comme
      <xref linkend="libpq-PQconsumeInput"/> ou
      <xref linkend="libpq-PQgetResult"/>. Si elle est appelée au bon moment,
      la fonction active le mode ligne-à-ligne pour la requête en cours et
      renvoit 1. Sinon, le mode reste inchangé et la fonction renvoit 0. Dans
      tous les cas, le mode retourne à la normale après la fin de la requête
      en cours.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <caution>
  <para>
   Lors du traitement d'une requête, le serveur peut renvoyer quelques
   lignes puis rencontrer une erreur, causant l'annulation de la requête.
   D'ordinaire, la bibliothèque partagée <application>libpq</application>
   jette ces lignes et renvoit une erreur. Avec le mode ligne-à-ligne,
   des lignes ont déjà pu être envoyées à l'application. Du coup, l'application
   verra quelques objets <structname>PGresult</structname> de statut
   <literal>PGRES_SINGLE_TUPLE</literal> suivis par un objet de statut
   <literal>PGRES_FATAL_ERROR</literal>. Pour un bon comportement transactionnel,
   l'application doit être conçue pour invalider ou annuler tout ce qui a été
   fait avec les lignes précédemment traitées si la requête finit par échouer.
  </para>
 </caution>

</sect1>

<sect1 id="libpq-cancel">
 <title>Annuler des requêtes en cours d'exécution</title>

 <indexterm zone="libpq-cancel">
  <primary>annulation</primary><secondary>commande SQL</secondary></indexterm>

 <para>
  Une application client peut demander l'annulation d'une commande qui est
  toujours en cours d'exécution par le serveur en utilisant les fonctions
  décrites dans cette section.

  <variablelist>
   <varlistentry id="libpq-PQgetCancel">
    <term><function>PQgetCancel</function>
     <indexterm><primary>PQgetCancel</primary></indexterm></term>
    <listitem>
     <para>
      Crée une structure de données contenant les informations
      nécessaires à l'annulation d'une commande lancée sur une
      connexion particulière à la base de données.
      <synopsis>PGcancel *PQgetCancel(PGconn *conn);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQgetCancel"/> crée un objet
      <structname>PGcancel</structname><indexterm><primary>PGcancel</primary></indexterm>
      à partir d'un objet connexion <structname>PGconn</structname>. Il renverra
      <symbol>NULL</symbol> si le paramètre <parameter>conn</parameter>
      donné est <symbol>NULL</symbol> ou est une connexion
      invalide. L'objet <structname>PGcancel</structname> est une structure opaque
      qui n'a pas pour but d'être accédé directement par
      l'application&nbsp;; elle peut seulement être passée à
      <xref linkend="libpq-PQcancel"/> ou <xref linkend="libpq-PQfreeCancel"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfreeCancel">
    <term><function>PQfreeCancel</function>
     <indexterm><primary>PQfreeCancel</primary></indexterm></term>
    <listitem>
     <para>
      Libère une structure de données créée par
      <xref linkend="libpq-PQgetCancel"/>.
      <synopsis>void PQfreeCancel(PGcancel *cancel);
      </synopsis>
     </para>

     <para>
      <xref linkend="libpq-PQfreeCancel"/> libère un objet donné par
      <xref linkend="libpq-PQgetCancel"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQcancel">
    <term><function>PQcancel</function>
     <indexterm><primary>PQcancel</primary></indexterm></term>
    <listitem>
     <para>
      Demande que le serveur abandonne l'exécution de la commande en
      cours.
      <synopsis>int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
      </synopsis>
     </para>

     <para>
      La valeur renvoyée est 1 si la demande d'annulation a été
      correctement envoyée et 0 sinon. Si non, <parameter>errbuf</parameter>
      contient un message d'erreur expliquant pourquoi.
      <parameter>errbuf</parameter> doit être un tableau de caractères d'une
      taille de <parameter>errbufsize</parameter> octets (la taille
      recommandée est de 256 octets).
     </para>

     <para>
      Un envoi réussi ne garantit pas que la demande aura un quelconque
      effet. Si l'annulation est réelle, la commande en cours terminera
      plus tôt et renverra une erreur. Si l'annulation échoue (disons,
      parce que le serveur a déjà exécuté la commande), alors il n'y
      aura aucun résultat visible.
     </para>

     <para>
      <xref linkend="libpq-PQcancel"/> peut être invoqué de façon sûre
      par le gestionnaire de signaux si <parameter>errbuf</parameter> est une
      variable locale dans le gestionnaire de signaux. L'objet
      <structname>PGcancel</structname> est en lecture seule en ce qui
      concerne <xref linkend="libpq-PQcancel"/>, pour qu'il puisse aussi
      être appelé à partir d'un thread séparé de celui manipulant
      l'objet <structname>PGconn</structname>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <variablelist>
   <varlistentry id="libpq-PQrequestCancel">
    <term><function>PQrequestCancel</function>
     <indexterm><primary>PQrequestCancel</primary></indexterm></term>
    <listitem>
     <para>
      <xref linkend="libpq-PQrequestCancel"/> est une variante obsolète de
      <xref linkend="libpq-PQcancel"/>.
      <synopsis>int PQrequestCancel(PGconn *conn);
      </synopsis>
     </para>

     <para>
      Demande au serveur l'abandon du traitement de la commande en cours
      d'exécution. Elle opère directement sur l'objet
      <structname>PGconn</structname> et, en cas d'échec, stocke le message d'erreur
      dans l'objet <structname>PGconn</structname> (d'où il peut être récupéré avec
      <xref linkend="libpq-PQerrorMessage"/>). Bien qu'il s'agisse de la même
      fonctionnalité, cette approche est hasardeuse dans les programmes
      multi-threads et les gestionnaires de
      signaux car il est possible que la surcharge du message d'erreur de
      <structname>PGconn</structname> gênera l'opération en cours sur la connexion.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

</sect1>

<sect1 id="libpq-fastpath">
 <title>Interface rapide (Fast Path)</title>

 <indexterm zone="libpq-fastpath"><primary>fast path</primary></indexterm>

 <indexterm zone="libpq-fastpath"><primary>chemin rapide</primary></indexterm>

 <para>
  <productname>PostgreSQL</productname> fournit une interface rapide
  (<foreignphrase>Fast Path</foreignphrase>) pour des appels de fonctions
  simples au serveur.
 </para>

 <tip>
  <para>
   Cette interface est quelque peu obsolète car vous pourriez réaliser les mêmes
   choses avec des performances similaires et plus de fonctionnalités en initialisant
   une instruction préparée pour définir l'appel de fonction. Puis, exécuter
   l'instruction avec une transmission binaire des paramètres et des substitutions
   de résultats pour un appel de fonction à chemin rapide.
  </para>
 </tip>

 <para>
  La fonction <function id="libpq-PQfn">PQfn</function><indexterm><primary>PQfn</primary></indexterm> demande
  l'exécution d'une fonction du serveur via l'interface de chemin rapide&nbsp;:
  <synopsis>PGresult* PQfn(PGconn* conn,
                   int fnid,
                   int *result_buf,
                   int *result_len,
                   int result_is_int,
                   const PQArgBlock *args,
                   int nargs);

    typedef struct
    {
        int len;
        int isint;
        union
        {
            int *ptr;
            int integer;
        } u;
    } PQArgBlock;
  </synopsis>
 </para>

 <para>
  L'argument <parameter>fnid</parameter> est l'OID de la fonction à exécuter.
  <parameter>args</parameter> et <parameter>nargs</parameter> définissent les
  paramètres à passer à la fonction&nbsp;; ils doivent correspondre à la liste
  d'arguments déclarés de la fonction. Quand le champ
  <parameter>isint</parameter> d'une structure est vrai, la valeur de
  <parameter>u.integer</parameter> est envoyée au serveur en tant qu'entier de
  la longueur indiquée (qui doit être 2 ou 4 octets)&nbsp;; les permutations
  d'octets adéquates sont opérées.
  Quand <parameter>isint</parameter> est faux, le nombre
  d'octets indiqué sur <parameter>*u.ptr</parameter> est envoyé sans
  traitement&nbsp;; les données doivent être dans le format attendu par le
  serveur pour la transmission binaire du type de données de l'argument de la
  fonction. (La déclaration de <parameter>u.ptr</parameter> en tant que type
  <type>int *</type> est historique&nbsp;; il serait préférable de la considérer
  comme un <type>void *</type>.) <parameter>result_buf</parameter> pointe vers
  le tampon dans lequel placer le code de retour de la fonction. L'appelant doit
  avoir alloué suffisamment d'espace pour stocker le code de retour (il n'y a
  pas de vérification&nbsp;!). La longueur effective du résultat en octet sera
  renvoyée dans l'entier pointé par <parameter>result_len</parameter>. Si un
  résultat sur un entier de 2 ou 4 octets est attendu, initialisez
  <parameter>result_is_int</parameter> à 1, sinon initialisez-le à 0.
  Initialiser <parameter>result_is_int</parameter> à 1 fait que
  <application>libpq</application> permute les octets de la valeur si nécessaire,
  de façon à ce que la bonne valeur <type>int</type> soit délivrée pour la
  machine cliente&nbsp;; notez qu'un entier sur quatre octets est fourni dans
  <parameter>*result_buf</parameter> pour chaque taille de résultat autorisée. Quand
  <parameter>result_is_int</parameter> vaut 0, la chaîne d'octets au format
  binaire envoyée par le serveur est renvoyée non modifiée. (Dans ce cas, il est
  préférable de considérer <parameter>result_buf</parameter> comme étant du type
  <type>void *</type>.)
 </para>

 <para>
  <function>PQfn</function> renvoie toujours un pointeur
  <structname>PGresult</structname> valide. L'état du résultat devrait être
  vérifié avant que le résultat ne soit utilisé. Le demandeur est responsable de
  la libération de la structure <structname>PGresult</structname> avec
  <xref linkend="libpq-PQclear"/> lorsque celle-ci n'est plus nécessaire.
 </para>

 <para>
  Notez qu'il n'est pas possible de gérer les arguments NULL, les résultats NULL
  et les résultats d'ensembles NULL en utilisant cette interface.
 </para>

</sect1>

<sect1 id="libpq-notify">
 <title>Notification asynchrone</title>

 <indexterm zone="libpq-notify">
  <primary>NOTIFY</primary>
  <secondary>dans libpq</secondary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> propose des notifications asynchrones via
  les commandes <command>LISTEN</command> et <command>NOTIFY</command>. Une
  session cliente enregistre son intérêt dans un canal particulier avec
  la commande <command>LISTEN</command> (et peut arrêter son écoute avec la
  commande <command>UNLISTEN</command>). Toutes les sessions écoutant un
  canal particulier seront notifiées de façon asynchrone lorsqu'une commande
  <command>NOTIFY</command> avec ce nom de canal sera exécutée par une
  session. Une chaîne de <quote>charge</quote> peut être renseignée pour fournir
  des données supplémentaires aux processus en écoute.
 </para>

 <para>
  Les applications <application>libpq</application> soumettent les commandes
  <command>LISTEN</command>, <command>UNLISTEN</command> et <command>NOTIFY</command>
  comme des commandes
  SQL ordinaires. L'arrivée des messages <command>NOTIFY</command> peut être
  détectée ensuite en appelant
  <function id="libpq-PQnotifies">PQnotifies</function>.<indexterm><primary>PQnotifies</primary></indexterm>
 </para>

 <para>
  La fonction <function>PQnotifies</function> renvoie la prochaine notification à
  partir d'une liste de messages de notification non gérés reçus à partir du
  serveur. Il renvoie un pointeur NULL s'il n'existe pas de notification en
  attente. Une fois qu'une notification est renvoyée à partir de
  <function>PQnotifies</function>, elle est considérée comme étant gérée et sera supprimée
  de la liste des notifications.
  <synopsis>PGnotify* PQnotifies(PGconn *conn);

   typedef struct pgNotify
   {
       char *relname;              /* nom du canal de la notification */
       int  be_pid;                /* ID du processus serveur notifiant */
       char *extra;                /* chaîne de charge pour la notification */
   } PGnotify;
  </synopsis>
  Après avoir traité un objet <structname>PGnotify</structname> renvoyé par
  <function>PQnotifies</function>, assurez-vous de libérer le pointeur
  <xref linkend="libpq-PQfreemem"/>. Il est suffisant de libérer le pointeur
  <structname>PGnotify</structname>&nbsp;; les champs
  <structfield>relname</structfield> et <structfield>extra</structfield> ne
  représentent pas des allocations séparées
  (le nom de ces champs est historique&nbsp;; en particulier, les noms des
  canaux n'ont pas besoin d'être liés aux noms des relations.)
 </para>

 <para>
  <xref linkend="libpq-example-2"/> donne un programme d'exemple illustrant
  l'utilisation d'une notification asynchrone.
 </para>

 <para>
  <function>PQnotifies</function> ne lit pas réellement les données à partir du
  serveur&nbsp;; il renvoie simplement les messages précédemment absorbés par une
  autre fonction de <application>libpq</application>. Dans les anciennes
  versions de <application>libpq</application>, la seule façon de s'assurer une
  réception à temps des messages <command>NOTIFY</command> consistait à soumettre
  constamment des commandes de soumission, même vides, puis de vérifier
  <function>PQnotifies</function> après chaque <xref linkend="libpq-PQexec"/>. Bien
  que ceci fonctionnait, cela a été abandonné car un gaspillage de ressources.
 </para>

 <para>
  Une meilleure façon de vérifier les messages <command>NOTIFY</command> lorsque vous
  n'avez pas de commandes utiles à exécuter est d'appeler
  <xref linkend="libpq-PQconsumeInput"/> puis de vérifier
  <function>PQnotifies</function>. Vous pouvez utiliser
  <function>select()</function> pour attendre l'arrivée des données à partir du
  serveur, donc sans utiliser de <acronym>CPU</acronym> sauf
  lorsqu'il y a quelque chose à faire (voir <xref linkend="libpq-PQsocket"/> pour
  obtenir le numéro du descripteur de fichiers à utiliser avec
  <function>select()</function>). Notez que ceci fonctionnera que vous
  soumettiez les commandes avec
  <xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/> ou que vous
  utilisiez simplement <xref linkend="libpq-PQexec"/>. Néanmoins, vous devriez vous
  rappeler de vérifier <function>PQnotifies</function> après chaque
  <xref linkend="libpq-PQgetResult"/> ou <xref linkend="libpq-PQexec"/> pour savoir si
  des notifications sont arrivées pendant le traitement de la commande.
 </para>

</sect1>

<sect1 id="libpq-copy">
 <title>Fonctions associées à la commande <command>COPY</command></title>

 <indexterm zone="libpq-copy">
  <primary>COPY</primary>
  <secondary>avec libpq</secondary>
 </indexterm>

 <para>
  Dans <productname>PostgreSQL</productname>, la commande <command>COPY</command>
  a des options pour lire ou écrire à
  partir de la connexion réseau utilisée par <application>libpq</application>.
  Les fonctions décrites dans cette section autorisent les applications à prendre
  avantage de cette capacité en apportant ou en consommant les données copiées.
 </para>

 <para>
  Le traitement complet est le suivant. L'application lance tout d'abord la
  commande SQL <command>COPY</command> via <function>PQexec</function><xref linkend="libpq-PQexec"/> ou une
  des fonctions équivalentes. La réponse à ceci (s'il n'y a pas d'erreur dans la
  commande) sera un objet <structname>PGresult</structname> avec un code de retour
  <literal>PGRES_COPY_OUT</literal> ou <literal>PGRES_COPY_IN</literal> (suivant
  la direction spécifiée pour la copie). L'application devrait alors utiliser les
  fonctions de cette section pour recevoir ou transmettre des lignes de données.
  Quand le transfert de données est terminé, un autre objet
  <structname>PGresult</structname> est renvoyé pour indiquer le succès ou l'échec du
  transfert. Son statut sera <literal>PGRES_COMMAND_OK</literal> en cas de succès
  et <literal>PGRES_FATAL_ERROR</literal> si un problème a été rencontré. À ce
  point, d'autres commandes SQL peuvent être exécutées via
  <xref linkend="libpq-PQexec"/> (il n'est pas possible d'exécuter d'autres
  commandes SQL en utilisant la même connexion tant que l'opération
  <command>COPY</command> est en cours).
 </para>

 <para>
  Si une commande <command>COPY</command> est lancée via
  <xref linkend="libpq-PQexec"/> dans une chaîne qui pourrait contenir d'autres
  commandes supplémentaires, l'application doit continuer à récupérer les
  résultats via <xref linkend="libpq-PQgetResult"/> après avoir terminé la séquence
  <command>COPY</command>. C'est seulement quand <xref linkend="libpq-PQgetResult"/> renvoie
  <symbol>NULL</symbol> que vous pouvez être certain que la chaîne de commandes
  <xref linkend="libpq-PQexec"/> est terminée et qu'il est possible de lancer
  d'autres commandes.
 </para>

 <para>
  Les fonctions de cette section devraient seulement être exécutées pour obtenir
  un statut de résultat <literal>PGRES_COPY_OUT</literal> ou
  <literal>PGRES_COPY_IN</literal> à partir de <xref linkend="libpq-PQexec"/> ou
  <xref linkend="libpq-PQgetResult"/>.
 </para>

 <para>
  Un objet <structname>PGresult</structname> gérant un de ces statuts comporte quelques
  données supplémentaires sur l'opération <command>COPY</command> qui commence.
  Les données supplémentaires sont disponibles en utilisant les fonctions qui sont
  aussi utilisées en relation avec les résultats de requêtes&nbsp;:

  <variablelist>
   <varlistentry id="libpq-PQnfields-1">
    <term><function>PQnfields</function><indexterm><primary>PQnfields</primary><secondary>with COPY</secondary></indexterm></term>
    <listitem>
     <para>
      Renvoie le nombre de colonnes (champs) à copier.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQbinaryTuples-1">
    <term><function>PQbinaryTuples</function><indexterm><primary>PQbinaryTuples</primary><secondary>with COPY</secondary></indexterm></term>
    <listitem>
     <para>
      0 indique que le format de copie complet est textuel (lignes
      séparées par des retours chariots, colonnes séparées par des
      caractères de séparation, etc).
      1 indique que le format de copie complet est binaire. Voir
      <xref linkend="sql-copy"/> pour plus
      d'informations.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfformat-1">
    <term><function>PQfformat</function><indexterm><primary>PQfformat</primary><secondary>with COPY</secondary></indexterm></term>
    <listitem>
     <para>
      Renvoie le code de format (0 pour le texte, 1 pour le binaire)
      associé avec chaque colonne de l'opération de copie. Les codes de
      format par colonne seront toujours zéro si le format de copie complet
      est textuel, mais le format binaire supporte à la fois des colonnes
      textuelles et des colonnes binaires (néanmoins, avec l'implémentation
      actuelle de <command>COPY</command>, seules les colonnes binaires
      apparaissent dans une copie binaire&nbsp; donc pour le moment
      les formats par colonnes correspondent toujours au format complet).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </para>

 <note>
  <para>
   Ces valeurs de données supplémentaires sont seulement disponibles en
   utilisant le protocole 3.0. Lors de l'utilisation du protocole 2.0, toutes ces
   fonctions renvoient 0.
  </para>
 </note>

 <sect2 id="libpq-copy-send">
  <title>Fonctions d'envoi de données pour <command>COPY</command></title>

  <para>
   Ces fonctions sont utilisées pour envoyer des données lors d'un <literal>COPY
    FROM STDIN</literal>. Elles échoueront si elles sont appelées alors que la connexion
   ne se trouve pas dans l'état <literal>COPY_IN</literal>.
  </para>

  <variablelist>
   <varlistentry id="libpq-PQputCopyData">
    <term><function>PQputCopyData</function><indexterm><primary>PQputCopyData</primary></indexterm></term>
    <listitem>
     <para>
      Envoie des données au serveur pendant un état <literal>COPY_IN</literal>.
      <synopsis>int PQputCopyData(PGconn *conn,
                         const char *buffer,
                         int nbytes);
      </synopsis>
     </para>

     <para>
      Transmet les données de <command>COPY</command> dans le tampon spécifié
      (<parameter>buffer</parameter>), sur <parameter>nbytes</parameter> octets, au serveur. Le résultat
      vaut 1 si les données ont été placées dans la queue, zéro si elles n'ont
      pas été placées dans la queue à casue de tampons pleins (cela n'arrivera
      qu'en mode non bloquant) ou -1 si une erreur s'est produite. (Utilisez
      <xref linkend="libpq-PQerrorMessage"/> pour récupérer des détails si la valeur de
      retour vaut -1. Si la valeur vaut zéro, attendez qu'il soit prêt à écrire et
      ré-essayez).
     </para>

     <para>
      L'application peut diviser le flux de données de <command>COPY</command>
      dans des tampons de taille adéquate. Les limites des tampons n'ont pas de
      signification sémantique lors de l'envoi. Le contenu du flux de données doit
      correspondre au format de données attendu par la commande
      <command>COPY</command>&nbsp;; voir <xref linkend="sql-copy"/>
      pour des détails.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQputCopyEnd">
    <term><function>PQputCopyEnd</function><indexterm><primary>PQputCopyEnd</primary></indexterm></term>
    <listitem>
     <para>
      Envoie une indication de fin de transfert au serveur lors de l'état
      <literal>COPY_IN</literal>.
      <synopsis>int PQputCopyEnd(PGconn *conn,
                        const char *errormsg);
      </synopsis>
     </para>

     <para>
      Termine l'opération <literal>COPY_IN</literal> avec succès si <parameter>errormsg</parameter>
      est <symbol>NULL</symbol>. Si <parameter>errormsg</parameter> n'est pas
      <symbol>NULL</symbol> alors <command>COPY</command> est passé en échec,
      avec la chaîne pointée par <parameter>errormsg</parameter>
      comme message d'erreur. (Mais ne pas supposer que ce message d'erreur précis
      proviendra du serveur car le serveur pourrait avoir déjà échoué sur la commande
      <command>COPY</command> pour des raisons qui lui sont propres). Notez aussi que
      l'option forçant l'échec ne fonctionnera pas lors de l'utilisation de
      connexions avec un protocole pre-3.0.
     </para>

     <para>
      Le résultat est 1 si le message de terminaison a été envoyé&nbsp;; ou en
      mode non bloquant, cela peut seulement indiquer que le message de
      terminaison a été correctement mis en file d'attente. (En mode non
      bloquant, pour être certain que les données ont été correctement
      envoyées, vous devriez ensuite attendre que le mode écriture soit
      disponible puis appeler <xref linkend="libpq-PQflush"/>, à répéter
      jusqu'à ce que 0 soit renvoyé). Zéro indique que la fonction n'a
      pas pu mettre en file d'attente le message de terminaison à cause d'une
      file pleine&nbsp;; ceci ne peut survenir qu'en mode non bloquant. (Dans ce
      cas, attendez que le mode écriture soit disponible puis rappelez
      à nouveau la fonction <xref linkend="libpq-PQputCopyEnd"/>). Si
      une erreur physique survient, -1 est renvoyé&nbsp;; vous pouvez alors
      appeler <xref linkend="libpq-PQerrorMessage"/> pour avoir plus de
      détails sur l'erreur.
     </para>

     <para>
      Après un appel réussi à <xref linkend="libpq-PQputCopyEnd"/>, appelez
      <xref linkend="libpq-PQgetResult"/> pour obtenir le statut de résultat final de la commande
      <command>COPY</command>. Vous pouvez attendre que le résultat soit disponible de la
      même façon. Puis, retournez au fonctionnement normal.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect2>

 <sect2 id="libpq-copy-receive">
  <title>Fonctions de réception des données de <command>COPY</command></title>

  <para>
   Ces fonctions sont utilisées pour recevoir des données lors d'un <literal>COPY
    TO STDOUT</literal>. Elles échoueront si elles sont appelées alors que la connexion
   n'est pas dans l'état <literal>COPY_OUT</literal>
  </para>

  <variablelist>
   <varlistentry id="libpq-PQgetCopyData">
    <term><function>PQgetCopyData</function><indexterm><primary>PQgetCopyData</primary></indexterm></term>
    <listitem>
     <para>
      Reçoit des données à partir du serveur lors d'un état <literal>COPY_OUT</literal>.
      <synopsis>int PQgetCopyData(PGconn *conn,
                         char **buffer,
                         int async);
      </synopsis>
     </para>

     <para>
      Tente d'obtenir une autre ligne de données du serveur lors d'une
      opération <command>COPY</command>. Les données ne sont renvoyées qu'une ligne à
      la fois&nbsp;; si seulement une ligne partielle est disponible, elle n'est pas
      renvoyée. Le retour d'une ligne avec succès implique l'allocation d'une portion
      de mémoire pour contenir les données. Le paramètre <parameter>buffer</parameter> ne doit
      pas être <symbol>NULL</symbol>. <parameter>*buffer</parameter> est initialisé pour
      pointer vers la mémoire allouée ou vers <symbol>NULL</symbol> au cas où aucun
      tampon n'est renvoyé. Un tampon résultat non <symbol>NULL</symbol> devra être
      libéré en utilisant <xref linkend="libpq-PQfreemem"/> lorsqu'il ne sera plus utile.
     </para>

     <para>
      Lorsqu'une ligne est renvoyée avec succès, la valeur de retour est le
      nombre d'octets de la donnée dans la ligne (et sera donc toujours supérieur
      à zéro). La chaîne renvoyée est toujours terminée par un octet nul bien que ce
      ne soit utile que pour les <command>COPY</command> textuels. Un résultat
      zéro indique que la commande <command>COPY</command> est toujours en cours mais
      qu'aucune ligne n'est encore disponible (ceci est seulement possible lorsque
      <parameter>async</parameter> est vrai). Un résultat -1 indique que
      <command>COPY</command> a terminé. Un résultat -2 indique qu'une erreur est
      survenue (consultez <xref linkend="libpq-PQerrorMessage"/> pour en connaître la raison).
     </para>

     <para>
      Lorsque <parameter>async</parameter> est vraie (différent de zéro),
      <xref linkend="libpq-PQgetCopyData"/> ne bloquera pas en attente d'entrée&nbsp;; il
      renverra zéro si <command>COPY</command> est toujours en cours mais qu'aucune
      ligne n'est encore disponible. (Dans ce cas, attendez qu'il soit prêt à
      lire puis appelez <xref linkend="libpq-PQconsumeInput"/> avant d'appeler
      <xref linkend="libpq-PQgetCopyData"/> de nouveau). Quand <parameter>async</parameter> est faux (zéro),
      <xref linkend="libpq-PQgetCopyData"/> bloquera tant que les données ne seront pas
      disponibles ou tant que l'opération n'aura pas terminée.
     </para>

     <para>
      Après que <xref linkend="libpq-PQgetCopyData"/> a renvoyé -1, appelez
      <xref linkend="libpq-PQgetResult"/> pour obtenir le statut de résultat final de la commande
      <command>COPY</command>. On peut attendre la disponibilité de ce résultat comme
      d'habitude. Puis, retournez aux opérations habituelles.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect2>

 <sect2 id="libpq-copy-deprecated">
  <title>Fonctions obsolètes pour <command>COPY</command></title>

  <para>
   Ces fonctions représentent d'anciennes méthodes de gestion de
   <command>COPY</command>. Bien qu'elles fonctionnent toujours, elles sont obsolètes à
   cause de leur pauvre gestion des erreurs, des méthodes inadéquates de
   détection d'une fin de transmission, et du manque de support des transferts
   binaires et des transferts non bloquants.
  </para>

  <variablelist>
   <varlistentry id="libpq-PQgetline">
    <term><function>PQgetline</function><indexterm><primary>PQgetline</primary></indexterm></term>
    <listitem>
     <para>
      Lit une ligne de caractères terminée par un retour chariot (transmis
      par le serveur) dans un tampon de taille <parameter>length</parameter>.
      <synopsis>int PQgetline(PGconn *conn,
                     char *buffer,
                     int length);
      </synopsis>
     </para>

     <para>
      Cette fonction copie jusqu'à <parameter>length</parameter>-1 caractères dans le tampon
      et convertit le retour chariot en un octet nul. <xref linkend="libpq-PQgetline"/>
      renvoie <symbol>EOF</symbol> à la fin de l'entrée, 0 si la ligne entière a été
      lue et 1 si le tampon est complet mais que le retour chariot à la fin n'a pas
      encore été lu.
     </para>
     <para>
      Notez que l'application doit vérifier si un retour chariot est constitué de
      deux caractères <literal>\.</literal>, ce qui indique que le serveur a terminé
      l'envoi des résultats de la commande <command>COPY</command>. Si l'application
      peut recevoir des lignes de plus de <parameter>length</parameter>-1 caractères, une
      attention toute particulière est nécessaire pour s'assurer qu'elle reconnaisse
      la ligne <literal>\.</literal> correctement (et ne confond pas, par exemple,
      la fin d'une longue ligne de données pour une ligne de terminaison).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQgetlineAsync">
    <term><function>PQgetlineAsync</function><indexterm><primary>PQgetlineAsync</primary></indexterm></term>
    <listitem>
     <para>
      Lit une ligne de données <command>COPY</command>
      (transmise par le serveur) dans un tampon sans blocage.
      <synopsis>int PQgetlineAsync(PGconn *conn,
                          char *buffer,
                          int bufsize);
      </synopsis>
     </para>

     <para>
      Cette fonction est similaire à <xref linkend="libpq-PQgetline"/> mais elle peut
      être utilisée par des applications qui doivent lire les données de
      <command>COPY</command> de façon asynchrone, c'est-à-dire sans blocage. Après
      avoir lancé la commande <command>COPY</command> et obtenu une réponse
      <literal>PGRES_COPY_OUT</literal>, l'application devrait appeler
      <xref linkend="libpq-PQconsumeInput"/> et
      <xref linkend="libpq-PQgetlineAsync"/> jusqu'à ce que le signal de fin des données
      soit détecté.
     </para>
     <para>
      Contrairement à <xref linkend="libpq-PQgetline"/>, cette fonction prend la
      responsabilité de détecter la fin de données.
     </para>
     <para>
      À chaque appel, <xref linkend="libpq-PQgetlineAsync"/> renverra des données si une
      ligne de données complète est disponible dans le tampon d'entrée de
      <application>libpq</application>. Sinon, aucune ligne n'est renvoyée jusqu'à l'arrivée du
      reste de la ligne. La fonction renvoie -1 si le marqueur de fin de copie des
      données a été reconnu, 0 si aucune donnée n'est disponible ou un nombre
      positif indiquant le nombre d'octets renvoyés. Si -1 est renvoyé, l'appelant
      doit ensuite appeler <xref linkend="libpq-PQendcopy"/> puis retourner aux
      traitements habituels.
     </para>
     <para>
      Les données renvoyées ne seront pas étendues au-delà de la limite de la ligne.
      Si possible, une ligne complète sera retournée en une fois. Mais si le tampon
      offert par l'appelant est trop petit pour contenir une ligne envoyée par le
      serveur, alors une ligne de données partielle sera renvoyée. Avec des données
      textuelles, ceci peut être détecté en testant si le dernier octet renvoyé est
      <literal>\n</literal> ou non (dans un <command>COPY</command> binaire, l'analyse
      réelle du format de données <command>COPY</command> sera nécessaire pour faire la
      détermination équivalente). La chaîne renvoyée n'est pas terminée par un
      octet nul. (Si vous voulez ajouter un octet nul de terminaison, assurez-vous de
      passer un <parameter>bufsize</parameter> inférieur de 1 par rapport à l'espace
      réellement disponible).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQputline">
    <term><function>PQputline</function><indexterm><primary>PQputline</primary></indexterm></term>
    <listitem>
     <para>
      Envoie une chaîne terminée par un octet nul au serveur. Renvoie 0 si tout va
      bien et <symbol>EOF</symbol> s'il est incapable d'envoyer la chaîne.
      <synopsis>int PQputline(PGconn *conn,
                     const char *string);
      </synopsis>
     </para>

     <para>
      Le flux de données de <command>COPY</command> envoyé par une série d'appels à
      <xref linkend="libpq-PQputline"/> a le même format que celui renvoyé par
      <xref linkend="libpq-PQgetlineAsync"/>, sauf que les applications ne sont pas
      obligées d'envoyer exactement une ligne de données par appel à
      <xref linkend="libpq-PQputline"/>&nbsp;; il est correct d'envoyer une ligne
      partielle ou plusieurs lignes par appel.
     </para>

     <note>
      <para>
       Avant le protocole 3.0 de <productname>PostgreSQL</productname>, il était
       nécessaire pour l'application d'envoyer explicitement les deux caractères
       <literal>\.</literal> comme ligne finale pour indiquer au serveur
       qu'elle a terminé l'envoi des données du <command>COPY</command>.
       Bien que ceci fonctionne toujours, cette
       méthode est obsolète et la signification spéciale de <literal>\.</literal>
       pourrait être supprimée dans une prochaine version. Il est suffisant d'appeler
       <xref linkend="libpq-PQendcopy"/> après avoir envoyé les vraies données.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQputnbytes">
    <term><function>PQputnbytes</function><indexterm><primary>PQputnbytes</primary></indexterm></term>
    <listitem>
     <para>
      Envoie une chaîne non terminée par un octet nul au serveur. Renvoie 0 si tout
      va bien et <symbol>EOF</symbol> s'il n'a pas été capable d'envoyer la chaîne.
      <synopsis>int PQputnbytes(PGconn *conn,
                       const char *buffer,
                       int nbytes);
      </synopsis>
     </para>

     <para>
      C'est exactement comme <xref linkend="libpq-PQputline"/>, sauf que le tampon de
      données n'a pas besoin d'être terminé avec un octet nul car le nombre d'octets
      envoyés est spécifié directement. Utilisez cette procédure pour envoyer des
      données binaires.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQendcopy">
    <term><function>PQendcopy</function><indexterm><primary>PQendcopy</primary></indexterm></term>
    <listitem>
     <para>
      Se synchronise avec le serveur.
      <synopsis>int PQendcopy(PGconn *conn);
      </synopsis>
      Cette fonction attend que le serveur ait terminé la copie. Elle devrait
      indiquer soit le moment où la dernière chaîne a été envoyée au serveur en utilisant
      <xref linkend="libpq-PQputline"/>, soit le moment où la dernière chaîne a été reçue
      du serveur en utilisant <function>PQgetline</function>. Si ce n'est pas fait,
      le serveur renverra un <quote>out of sync</quote> (perte de
      synchronisation) au client. Au retour de cette fonction, le serveur est
      prêt à recevoir la prochaine commande SQL. Le code de retour 0 indique un
      succès complet et est différent de zéro dans le cas contraire (utilisez
      <xref linkend="libpq-PQerrorMessage"/> pour récupérer des détails sur l'échec).
     </para>

     <para>
      Lors de l'utilisation de <xref linkend="libpq-PQgetResult"/>, l'application
      devrait répondre à un résultat <literal>PGRES_COPY_OUT</literal> en exécutant
      <xref linkend="libpq-PQgetline"/> de façon répétée, suivi par un
      <xref linkend="libpq-PQendcopy"/> une fois la ligne de terminaison aperçue.
      Il devrait ensuite retourner à la boucle <xref linkend="libpq-PQgetResult"/>
      jusqu'à ce que <xref linkend="libpq-PQgetResult"/> renvoie un pointeur NULL. De
      façon similaire, un résultat <literal>PGRES_COPY_IN</literal> est traité par une
      série d'appels à <xref linkend="libpq-PQputline"/> suivis par un
      <xref linkend="libpq-PQendcopy"/>, ensuite retour à la boucle
      <xref linkend="libpq-PQgetResult"/>. Cet arrangement vous assurera qu'une commande
      <command>COPY</command> intégrée dans une série de commandes
      <acronym>SQL</acronym> sera exécutée correctement.
     </para>

     <para>
      Les anciennes applications sont susceptibles de soumettre un
      <command>COPY</command> via <xref linkend="libpq-PQexec"/> et supposent que
      la transaction est faite après un
      <xref linkend="libpq-PQendcopy"/>. Ceci fonctionnera correctement seulement si
      <command>COPY</command> est la seule commande <acronym>SQL</acronym> dans la
      chaîne de commandes.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect2>

</sect1>

<sect1 id="libpq-control">
 <title>Fonctions de contrôle</title>

 <para>
  Ces fonctions contrôlent divers détails du comportement de
  <application>libpq</application>.
 </para>

 <variablelist>
  <varlistentry id="libpq-PQclientEncoding">
   <term>
    <function>PQclientEncoding</function>
    <indexterm>
     <primary>PQclientEncoding</primary>
    </indexterm>
   </term>

   <listitem>
    <para>
     Renvoie l'encodage client.
     <synopsis>
      int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
     </synopsis>

     Notez qu'il renvoie l'ID de l'encodage, pas une chaîne symbolique
     telle que <literal>EUC_JP</literal>. Renvoie -1 en cas d'échec. Pour
     convertir un ID d'encodage en nom, vous pouvez utiliser&nbsp;:

     <synopsis>
       char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
     </synopsis>
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQsetClientEncoding">
   <term>
    <function>PQsetClientEncoding</function>
    <indexterm>
     <primary>PQsetClientEncoding</primary>
    </indexterm>
   </term>

   <listitem>
    <para>
     Configure l'encodage client.
     <synopsis>
      int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
     </synopsis>

     <replaceable>conn</replaceable> est la connexion au serveur, et
     <replaceable>encoding</replaceable> est l'encodage que vous voulez
     utiliser. Si la fonction initialise l'encodage avec succès, elle
     renvoie 0, sinon -1. L'encodage en cours pour cette connexion peut être
     déterminé en utilisant <xref linkend="libpq-PQclientEncoding"/>.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQsetErrorVerbosity">
   <term><function>PQsetErrorVerbosity</function><indexterm><primary>PQsetErrorVerbosity</primary></indexterm></term>
   <listitem>
    <para>
     Détermine la verbosité des messages renvoyés par
     <xref linkend="libpq-PQerrorMessage"/> et <xref linkend="libpq-PQresultErrorMessage"/>.
     <synopsis>typedef enum
       {
           PQERRORS_TERSE,
           PQERRORS_DEFAULT,
           PQERRORS_VERBOSE,
           PQERRORS_SQLSTATE
       } PGVerbosity;

       PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
     </synopsis>
     <xref linkend="libpq-PQsetErrorVerbosity"/> initialise le mode de verbosité, renvoyant le
     paramétrage précédant de cette connexion. Dans le mode
     <firstterm>TERSE</firstterm>, les
     messages renvoyés incluent seulement la sévérité, le texte principal et la
     position&nbsp;; ceci tiendra normalement sur une seule ligne. Le mode
     <firstterm>DEFAULT</firstterm> produit des messages qui incluent ces champs ainsi que les champs détail,
     astuce ou contexte (ils pourraient être sur plusieurs lignes). Le mode
     <firstterm>VERBOSE</firstterm> inclut tous les champs disponibles. Le mode
     <firstterm>SQLSTATE</firstterm> inclut seulement la sévérité de l'erreur
     et le code d'erreur <symbol>SQLSTATE</symbol>, s'il est disponible (dans le
     cas contraire, la sortie est identique au mode <firstterm>TERSE</firstterm>).
    </para>

    <para>
     Modifier la verbosité
     n'affecte pas les messages disponibles à partir d'objets
     <structname>PGresult</structname> déjà existants, seulement ceux créés après.
     (Mais voyez <xref linkend="libpq-PQresultVerboseErrorMessage"/> si vous voulez
     afficher une erreur précédente avec une verbosité différente).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetErrorContextVisibility">
    <term>
     <function>PQsetErrorContextVisibility</function>
     <indexterm>
      <primary>PQsetErrorContextVisibility</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      Détermine la gestion des champs <literal>CONTEXT</literal> dans les
      messages renvoyées par <xref linkend="libpq-PQerrorMessage"/>
      et <xref linkend="libpq-PQresultErrorMessage"/>.
<synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis>

      <xref linkend="libpq-PQsetErrorContextVisibility"/> configure le mode
      d'affichage du contexte, renvoyant la précédente configuration de la
      connexion. Ce mode contrôle si le champ <literal>CONTEXT</literal> est
      inclus dans les messages. Le mode <firstterm>NEVER</firstterm> n'inclut jamais
      <literal>CONTEXT</literal>, alors que <firstterm>ALWAYS</firstterm> l'inclut
      en permanence s'il est disponible. Dans le mode par défaut,
      <firstterm>ERRORS</firstterm>, les champs <literal>CONTEXT</literal> sont
      inclus seulement pour les messages d'erreur, et non pas pour les messages
      d'informations et d'avertissements. (Cependant, si le paramètre verbosity est <firstterm>TERSE</firstterm>
      ou <firstterm>SQLSTATE</firstterm>, les champs <literal>CONTEXT</literal>
      sont omis quelque soit le contexte de mode d'affichage.)
     </para>

     <para>
      La modification de ce mode n'affecte
      pas les messages disponibles à partir des objets
      <structname>PGresult</structname> déjà existants, seulement ceux créés
      après. (Cependant, voyez <xref linkend="libpq-PQresultVerboseErrorMessage"/>
      si vous voulez afficher une erreur précédente avec un mode d'affichage
      différent.)
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQtrace">
   <term><function>PQtrace</function><indexterm><primary>PQtrace</primary></indexterm></term>
   <listitem>
    <para>
     Active la trace de la communication entre client et serveur vers un
     fichier de débogage.
     <synopsis>void PQtrace(PGconn *conn, FILE *stream);
     </synopsis>
    </para>
    <note>
     <para>
      Sur Windows, si la bibliothèque <application>libpq</application> et une application sont
      compilées avec des options différentes, cet appel de fonction fera
      planter l'application car la représentation interne des pointeurs
      <literal>FILE</literal> diffère. Spécifiquement, les options multi-threaded/single-threaded
      release/debug et static/dynamic devraient être identiques pour la bibliothèque et les
      applications qui l'utilisent.
     </para>
    </note>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQuntrace">
   <term><function>PQuntrace</function><indexterm><primary>PQuntrace</primary></indexterm></term>
   <listitem>
    <para>
     Désactive les traces commencées avec <xref linkend="libpq-PQtrace"/>.
     <synopsis>void PQuntrace(PGconn *conn);
     </synopsis>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="libpq-misc">
 <title>Fonctions diverses</title>

 <para>
  Comme toujours, certaines fonctions ne sont pas catégorisables.
 </para>

 <variablelist>
  <varlistentry id="libpq-PQfreemem">
   <term><function>PQfreemem</function><indexterm><primary>PQfreemem</primary></indexterm></term>

   <listitem>
    <para>
     Libère la mémoire allouée par <application>libpq</application>.
     <synopsis>
       void PQfreemem(void *ptr);
     </synopsis>
    </para>

    <para>
     Libère la mémoire allouée par <application>libpq</application>,
     particulièrement <xref linkend="libpq-PQescapeByteaConn"/>,
     <xref linkend="libpq-PQescapeBytea"/>,
     <xref linkend="libpq-PQunescapeBytea"/>,
     et <function>PQnotifies</function>. Il est particulièrement important
     que cette fonction, plutôt que <function>free()</function>, soit utilisée
     sur Microsoft Windows. Ceci est dû au fait qu'allouer de la mémoire dans une
     DLL et la relâcher dans l'application ne marche que si les drapeaux
     multi-thread/mon-thread, release/debug et static/dynamic sont les mêmes
     pour la DLL et l'application. Sur les plateformes autres que Microsoft
     Windows, cette fonction est identique à la fonction
     <function>free()</function> de la bibliothèque standard.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQconninfoFree">
   <term><function>PQconninfoFree</function><indexterm><primary>PQconninfoFree</primary></indexterm></term>

   <listitem>
    <para>
     Libère les structures de données allouées par
     <xref linkend="libpq-PQconndefaults"/> ou <xref linkend="libpq-PQconninfoParse"/>.
     <synopsis>
       void PQconninfoFree(PQconninfoOption *connOptions);
     </synopsis>
    </para>

    <para>
     Un simple appel à <xref linkend="libpq-PQfreemem"/> ne suffira pas car le
     tableau contient des références à des chaînes complémentaires.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQencryptPasswordConn">
   <term><function>PQencryptPasswordConn</function><indexterm><primary>PQencryptPasswordConn</primary></indexterm></term>
   <listitem>
    <para>
     Prépare la forme chiffrée du mot de passe <productname>PostgreSQL</productname>.
     <synopsis>
      char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
     </synopsis>
     Cette fonction est utilisée par les applications clientes qui souhaitent envoyer
     des commandes comme <literal>ALTER USER joe PASSWORD 'passe'</literal>.
     Une bonne pratique est de ne pas envoyer le mot de passe en clair dans une
     telle commande car le mot de passe serait exposé dans les journaux, les affichages
     d'activité et ainsi de suite. À la place, utilisez cette fonction pour convertir
     le mot de passe sous forme chiffrée avant de l'envoyer.
    </para>

    <para>
      Les arguments <parameter>passwd</parameter> et
      <parameter>user</parameter> sont le mot de passe en clair et le nom
      SQL de l'utilisateur correspondant.
      <parameter>algorithm</parameter> spécifie l'algorithme de chiffrement à
      utiliser pour chiffrer le mot de passe. Pour le moment, les algorithmes
      supportés sont <literal>md5</literal> et <literal>scram-sha-256</literal>
      (<literal>on</literal> et <literal>off</literal> sont également acceptés
      comme des alias pour <literal>md5</literal>, pour compatibilité avec les
      versions des anciens serveurs). Veuillez noter que le support de
      <literal>scram-sha-256</literal> a été introduit dans la version 10 de
      <productname>PostgreSQL</productname>, et ne fonctionnera pas
      corrrectement avec des versions de serveur plus ancienne. Si
      <parameter>algorithm</parameter> est <symbol>NULL</symbol>, cette
      fonction demandera au serveur la valeur actuelle du réglage
      <xref linkend="guc-password-encryption"/>. Cela peut être bloquant, et
      échouera si la transaction courante est annulée ou si la connexion est
      occupée à effectuer une autre requête. Si vous souhaitez utiliser
      l'algorithme par défaut du serveur mais que vous voulez éviter un
      blocage, vérifiez vous-même <varname>password_encryption</varname> avant
      d'appeler <xref linkend="libpq-PQencryptPasswordConn"/>, et fournissez cette
      valeur pour <parameter>algorithm</parameter>.
     </para>

     <para>
      La valeur retournée est une chaîne allouée par
      <function>malloc</function>. L'appelant peut partir du principe que la
      chaîne ne contient pas de caractères spéciaux qui nécessiteraient un
      échappement. Utilisez <xref linkend="libpq-PQfreemem"/> pour libérer le
      résultat quand vous avez fini de l'utiliser. En cas d'erreur,
      <symbol>NULL</symbol> est retourné, et un message d'erreur adéquat est
      stocké dans l'objet de connexion.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQencryptPassword">
    <term><function>PQencryptPassword</function><indexterm><primary>PQencryptPassword</primary></indexterm></term>

    <listitem>
     <para>
      Prépare la version chiffrée en md5 du mot de passe
      <productname>PostgreSQL</productname>.
 <synopsis>
char *PQencryptPassword(const char *passwd, const char *user);
 </synopsis>
      <xref linkend="libpq-PQencryptPassword"/> est une version ancienne et
      obsolète de <xref linkend="libpq-PQencryptPasswordConn"/>. La différence
      est que <xref linkend="libpq-PQencryptPassword"/> ne nécessite pas d'objet
      de connexion, et que l'algorithme de chiffrement utilisé est toujours
      <literal>md5</literal>.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQmakeEmptyPGresult">
   <term><function>PQmakeEmptyPGresult</function><indexterm><primary>PQmakeEmptyPGresult</primary></indexterm></term>

   <listitem>
    <para>
     Construit un objet <structname>PGresult</structname> vide avec le statut
     indiqué.
     <synopsis>
       PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
     </synopsis>
    </para>

    <para>
     C'est une fonction interne de la <application>libpq</application> pour
     allouer et initialiser un objet <structname>PGresult</structname> vide.
     Cette fonction renvoit NULL si la mémoire n'a pas pu être allouée. Elle
     est exportée car certaines applications trouveront utiles de générer
     elles-mêmes des objets de résultat (tout particulièrement ceux avec des
     statuts d'erreur). Si <parameter>conn</parameter> n'est pas <symbol>NULL</symbol> et que
     <parameter>status</parameter> indique une erreur, le message d'erreur
     courant de la connexion indiquée est copié dans
     <structname>PGresult</structname>. De plus, si
     <parameter>conn</parameter> n'est pas NULL, toute procédure d'événement
     enregistrée dans la connexion est copiée dans le
     <structname>PGresult</structname>. (Elles n'obtiennent pas d'appels
     <literal>PGEVT_RESULTCREATE</literal>, mais jetez un &oelig;il à
     <xref linkend="libpq-PQfireResultCreateEvents"/>.)
     Notez que <xref linkend="libpq-PQclear"/> devra être appelé sur l'objet,
     comme pour un <structname>PGresult</structname> renvoyé par
     <application>libpq</application> lui-même.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQfireResultCreateEvents">
   <term><function>PQfireResultCreateEvents</function><indexterm><primary>PQfireResultCreateEvents</primary></indexterm></term>
   <listitem>
    <para>
     Déclenche un événement <literal>PGEVT_RESULTCREATE</literal> (voir <xref
     linkend="libpq-events"/>) pour chaque procédure d'événement enregistrée
     dans l'objet <structname>PGresult</structname>. Renvoit autre chose que
     zéro en cas de succès, zéro si une des procédures d'événement échoue.

     <synopsis>
       int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
     </synopsis>
    </para>

    <para>
     L'argument <literal>conn</literal> est passé aux procédures d'événement
     mais n'est pas utilisé directement. Il peut être <literal>NULL</literal>
     si les procédures de l'événement ne l'utilisent pas.
    </para>

    <para>
     Les procédures d'événements qui ont déjà reçu un événement
     <literal>PGEVT_RESULTCREATE</literal> ou
     <literal>PGEVT_RESULTCOPY</literal> pour cet objet ne sont pas déclenchées
     de nouveau.
    </para>

    <para>
     La raison principale pour séparer cette fonction de
     <xref linkend="libpq-PQmakeEmptyPGresult"/> est qu'il est souvent approprié
     de créer un <structname>PGresult</structname> et de le remplir avec des
     données avant d'appeler les procédures d'événement.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQcopyResult">
   <term><function>PQcopyResult</function><indexterm><primary>PQcopyResult</primary></indexterm></term>

   <listitem>
    <para>
     Fait une copie de l'objet <structname>PGresult</structname>. La copie
     n'est liée en aucune façon au résultat source et
     <xref linkend="libpq-PQclear"/> doit être appelée quand la copie n'est
     plus nécessaire. Si la fonction échoue, <symbol>NULL</symbol> est renvoyé.

     <synopsis>
       PGresult *PQcopyResult(const PGresult *src, int flags);
     </synopsis>
    </para>

    <para>
     Cela n'a pas pour but de faire une copie exacte. Le résultat renvoyé a
     toujours le statut <literal>PGRES_TUPLES_OK</literal>, et ne copie aucun
     message d'erreur de la source. (Néanmoins, elle copie la chaîne de statut
     de commande.) L'argument <parameter>flags</parameter> détermine ce qui
     est copié. C'est un OR bit à bit de plusieurs drapeaux.
     <literal>PG_COPYRES_ATTRS</literal> indique la copie des attributs du
     résultat source (définition des colonnes).
     <literal>PG_COPYRES_TUPLES</literal> indique la copie des lignes du
     résultat source. (Cela implique de copier aussi les attributs.)
     <literal>PG_COPYRES_NOTICEHOOKS</literal> indique la copie des
     gestionnaires de notification du résultat source.
     <literal>PG_COPYRES_EVENTS</literal> indique la copie des événements du
     résultat source. (Mais toute instance de données associée avec la source
     n'est pas copiée.)
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQsetResultAttrs">
   <term><function>PQsetResultAttrs</function><indexterm><primary>PQsetResultAttrs</primary></indexterm></term>

   <listitem>
    <para>
     Initialise les attributs d'un objet <structname>PGresult</structname>.
     <synopsis>
       int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
     </synopsis>
    </para>

    <para>
     Les <parameter>attDescs</parameter> fournis sont copiés dans le résultat.
     Si le pointeur <parameter>attDescs</parameter> est <symbol>NULL</symbol> ou si
     <parameter>numAttributes</parameter> est inférieur à 1, la requête est
     ignorée et la fonction réussit. Si <parameter>res</parameter> contient
     déjà les attributs, la fonction échouera. Si la fonction échoue, la valeur
     de retour est zéro. Si la fonction réussit, la valeur de retour est
     différente de zéro.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQsetvalue">
   <term><function>PQsetvalue</function><indexterm><primary>PQsetvalue</primary></indexterm></term>

   <listitem>
    <para>
     Initialise la valeur d'un champ d'une ligne d'un objet
     <structname>PGresult</structname>.
     <synopsis>
       int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
     </synopsis>
    </para>

    <para>
     La fonction fera automatiquement grossir le tableau de lignes internes des
     résultats, si nécessaire. Néanmoins, l'argument
     <parameter>tup_num</parameter> doit être inférieur ou égal à
     <xref linkend="libpq-PQntuples"/>, ceci signifiant que la fonction peut
     seulement faire grossir le tableau des lignes une ligne à la fois. Mais
     tout champ d'une ligne existante peut être modifié dans n'importe quel
     ordre. Si une valeur à <parameter>field_num</parameter> existe déjà, elle
     sera écrasée. Si <parameter>len</parameter> vaut 1 ou
     si <parameter>value</parameter> est <literal>NULL</literal>, la valeur
     du champ sera configurée à la valeur SQL <literal>NULL</literal>.
     <parameter>value</parameter> est copié dans le stockage privé du résultat,
     donc n'est plus nécessaire après le retour de la fonction. Si la fonction échoue,
     la valeur de retour est zéro. Dans le cas contraire, elle a une valeur
     différente de zéro.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQresultAlloc">
   <term><function>PQresultAlloc</function><indexterm><primary>PQresultAlloc</primary></indexterm></term>

   <listitem>
    <para>
     Alloue un stockage supplémentaire pour un objet
     <structname>PGresult</structname>.
     <synopsis>
       void *PQresultAlloc(PGresult *res, size_t nBytes);
     </synopsis>
    </para>

    <para>
     Toute mémoire allouée avec cette fonction sera libérée quand
     <parameter>res</parameter> sera effacé. Si la fonction échoue, la valeur
     de retour vaut <literal>NULL</literal>. Le résultat est garanti d'être
     correctement aligné pour tout type de données, comme pour un
     <function>malloc</function>.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry id="libpq-PQresultMemorySize">
   <term><function>PQresultMemorySize</function><indexterm><primary>PQresultMemorySize</primary></indexterm></term>

    <listitem>
     <para>
      Renvoie le nombre d'octets alloués pour un objet
      <structname>PGresult</structname>.
<synopsis>
size_t PQresultMemorySize(const PGresult *res);
</synopsis>
     </para>

     <para>
      La valeur est la somme de tous les appels <function>malloc</function>
      associés avec l'objet <structname>PGresult</structname>, c'est-à-dire
      tout l'espace qui peut être libéré par <xref linkend="libpq-PQclear"/>.
      Cette information est utile pour gérer la consommation mémoire.
     </para>
    </listitem>
   </varlistentry>

  <varlistentry id="libpq-PQlibVersion">
   <term><function>PQlibVersion</function><indexterm><primary>PQlibVersion</primary><seealso>PQserverVersion</seealso></indexterm></term>

   <listitem>
    <para>
     Renvoie la version de <productname>libpq</productname> en cours
     d'utilisation.
     <synopsis>
      int PQlibVersion(void);
     </synopsis>
    </para>

    <para>
     Le résultat de cette fonction peut être utilisé pour déterminer,
     à l'exécution, si certaines fonctionnalités spécifiques sont
     disponibles dans la version chargée de libpq. Par exemple, cette
     fonction peut être utilisée pour déterminer les options de
     connexions disponibles pour <xref linkend="libpq-PQconnectdb"/>.
    </para>

    <para>
     Le résultat est obtenu en multipliant le numéro de version majeure de la
     bibliothèque par 10000 et en ajoutant le numéro de version mineure. Par
     exemple, la version 10.1 renverra 100001, et la version 11.0 renverra
     110000.
    </para>

    <para>
     Avant la version majeure 10, <productname>PostgreSQL</productname>
     utilisait des numéros de version en trois parties, pour lesquelles les
     deux premières parties représentaient la version majeure. Pour ces
     versions, <xref linkend="libpq-PQlibVersion"/> utilise deux chiffres pour
     chaque partie. Par exemple, la version 9.1.5 renverra 90105, et la
     version 9.2.0 renverra 90200.
    </para>

    <para>
     De ce fait, pour déterminer la compatibilité de certaines
     fonctionnalités, les applications devraient diviser le résultat de
     <xref linkend="libpq-PQlibVersion"/> par 100, et non pas par 10000, pour
     déterminer le numéro de version majeure logique. Dans toutes les
     versions, seuls les deux derniers chiffres diffèrent entre des versions
     mineures (versions correctives).
    </para>

    <note>
     <para>
      Cette fonction apparaît dans <productname>PostgreSQL</productname> 9.1,
      donc elle ne peut pas être
      utilisée pour détecter des fonctionnalités des versions
      précédentes car l'appeler créera une dépendance sur la
      version 9.1 et les versions ultérieures.
     </para>
    </note>
   </listitem>
  </varlistentry>

 </variablelist>

</sect1>

<sect1 id="libpq-notice-processing">
 <title>Traitement des messages</title>

 <indexterm zone="libpq-notice-processing">
  <primary>traitement des messages</primary>
  <secondary>dans libpq</secondary>
 </indexterm>

 <para>
  Les messages de note et d'avertissement générés par le serveur ne sont pas
  renvoyés par les fonctions d'exécution des requêtes car elles n'impliquent pas
  d'échec dans la requête. À la place, elles sont passées à la fonction de
  gestion des messages et l'exécution continue normalement après le retour du
  gestionnaire. La fonction par défaut de gestion des messages affiche le message
  sur <filename>stderr</filename> mais l'application peut surcharger ce
  comportement en proposant sa propre fonction de gestion.
 </para>

 <para>
  Pour des raisons historiques, il existe deux niveaux de gestion de messages,
  appelés la réception des messages et le traitement. Pour la réception, le
  comportement par défaut est de formater le message et de passer une chaîne au
  traitement pour affichage. Néanmoins, une application qui choisit de
  fournir son propre receveur de messages ignorera typiquement la couche d'envoi
  de messages et effectuera tout le travail au niveau du receveur.
 </para>

 <para>
  La fonction <function id="libpq-PQsetNoticeReceiver">PQsetNoticeReceiver</function>
  <indexterm><primary>receveur
    de message</primary></indexterm><indexterm><primary>PQsetNoticeReceiver</primary></indexterm>
  initialise ou examine le receveur actuel de messages pour un objet de
  connexion. De la même façon, <function id="libpq-PQsetNoticeProcessor">PQsetNoticeProcessor</function>
  <indexterm><primary>traiteur de messages</primary></indexterm><indexterm><primary>
    PQsetNoticeProcessor</primary></indexterm> initialise ou examine l'émetteur actuel de messages.

  <synopsis>typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

    PQnoticeReceiver
    PQsetNoticeReceiver(PGconn *conn,
                        PQnoticeReceiver proc,
                        void *arg);

    typedef void (*PQnoticeProcessor) (void *arg, const char *message);

    PQnoticeProcessor
    PQsetNoticeProcessor(PGconn *conn,
                         PQnoticeProcessor proc,
                         void *arg);
  </synopsis>

  Chacune de ces fonctions reçoit le pointeur de fonction du précédent receveur
  ou émetteur de messages et configure la nouvelle valeur. Si vous fournissez un
  pointeur de fonction NULL, aucune action n'est réalisée mais le pointeur actuel
  est renvoyé.
 </para>

 <para>
  Quand un message de note ou d'avertissement est reçu du serveur ou généré de
  façon interne par <application>libpq</application>, la fonction de réception du
  message est appelée. Le message lui est passé sous la forme d'un
  <structname>PGresult</structname> <symbol>PGRES_NONFATAL_ERROR</symbol> (ceci
  permet au receveur d'extraire les champs individuels en utilisant
  <xref linkend="libpq-PQresultErrorField"/> ou d'obtenir le message complet préformaté en utilisant
  <xref linkend="libpq-PQresultErrorMessage"/> ou <xref linkend="libpq-PQresultVerboseErrorMessage"/>). Le même pointeur void passé à
  <function>PQsetNoticeReceiver</function> est aussi renvoyé (ce pointeur peut
  être utilisé pour accéder à un état spécifique de l'application si nécessaire).
 </para>

 <para>
  Le receveur de messages par défaut extrait simplement le message (en utilisant
  <xref linkend="libpq-PQresultErrorMessage"/>) et le passe au système de traitement du
  message.
 </para>

 <para>
  Ce dernier est responsable de la gestion du message de note ou d'avertissement,
  fourni au format texte. La chaîne texte du message est passée (avec un retour
  chariot final), plus un pointeur sur void identique à celui passé à
  <function>PQsetNoticeProcessor</function> (ce pointeur est utilisé pour
  accéder à un état spécifique de l'application si nécessaire).
 </para>

 <para>
  Le traitement des messages par défaut est simplement&nbsp;:
  <programlisting>static void
    defaultNoticeProcessor(void * arg, const char * message)
    {
        fprintf(stderr, "%s", message);
    }
  </programlisting>
 </para>

 <para>
  Une fois que vous avez initialisé un receveur ou une fonction de traitement des
  messages, vous devez vous attendre à ce que la fonction soit appelée aussi
  longtemps que l'objet <structname>PGconn</structname> ou qu'un objet
  <structname>PGresult</structname> réalisé à partir de celle-ci existent. À la création
  d'un <structname>PGresult</structname>, les pointeurs de gestion courants de
  <structname>PGconn</structname> sont copiés dans <structname>PGresult</structname> pour une
  utilisation possible par des fonctions comme <xref linkend="libpq-PQgetvalue"/>.
 </para>

</sect1>

<sect1 id="libpq-events">
 <title>Système d'événements</title>

 <para>
  Le système d'événements de <application>libpq</application> est conçu pour
  notifier les gestionnaires d'événements enregistrés de l'arrivée d'événements
  intéressants de la <application>libpq</application>, comme par exemple la
  création ou la destruction d'objets <structname>PGconn</structname> et
  <structname>PGresult</structname>. Un cas d'utilisation principal est de
  permettre aux applications d'associer leur propres données avec un
  <structname>PGconn</structname> ou un <structname>PGresult</structname> et
  de s'assurer que les données soient libérées au bon moment.
 </para>

 <para>
  Chaque gestionnaire d'événement enregistré est associé avec deux types de
  données, connus par <application>libpq</application> comme des pointeurs
  opaques, c'est-à-dire <literal>void *</literal>. Il existe un pointeur
  <firstterm>passthrough</firstterm> fourni par l'application quand le
  gestionnaire d'événements est enregistré avec un <structname>PGconn</structname>.
  Le pointeur passthrough ne change jamais pendant toute la durée du
  <structname>PGconn</structname> et des <structname>PGresult</structname>
  générés grâce à lui&nbsp;; donc s'il est utilisé, il doit pointer vers
  des données à longue vie. De plus, il existe un pointeur de <firstterm>données
  instanciées</firstterm>, qui commence à NULL dans chaque objet
  <structname>PGconn</structname> et <structname>PGresult</structname>. Ce
  pointeur peut être manipulé en utilisant les fonctions
  <xref linkend="libpq-PQinstanceData"/>,
  <xref linkend="libpq-PQsetInstanceData"/>,
  <xref linkend="libpq-PQresultInstanceData"/> et
  <function>PQsetResultInstanceData</function>. Notez que, contrairement au
  pointeur passthrough, les <structname>PGresult</structname> n'héritent pas
  automatiquement des données instanciées d'un
  <structname>PGconn</structname>. <application>libpq</application> ne sait
  pas vers quoi pointent les pointeurs passthrough et de données instanciées,
  et n'essaiera hamais de les libérer &mdash; cela tient de la responsabilité
  du gestionnaire d'événements.
 </para>

 <sect2 id="libpq-events-types">
  <title>Types d'événements</title>

  <para>
   L'enum <literal>PGEventId</literal> précise tous les types
   d'événements gérés par le système d'événements. Toutes ses valeurs ont des
   noms commençant avec <literal>PGEVT</literal>. Pour chaque type d'événement,
   il existe une structure d'informations sur l'événement, précisant les
   paramètres passés aux gestionnaires d'événement. Les types d'événements
   sont&nbsp;:
  </para>

  <variablelist>
   <varlistentry id="libpq-pgevt-register">
    <term><literal>PGEVT_REGISTER</literal></term>
    <listitem>
     <para>
      L'événement d'enregistrement survient quand <xref linkend="libpq-PQregisterEventProc"/>
      est appelé. C'est le moment idéal pour initialiser toute structure
      <literal>instanceData</literal> qu'une procédure d'événement pourrait avoir
      besoin. Seul un événement d'enregistrement sera déclenché par gestionnaire
      d'évévenement sur une connexion. Si la procédure échoue, l'enregistrement
      est annulé.

      <synopsis>
        typedef struct
        {
            PGconn *conn;
        } PGEventRegister;
      </synopsis>

      Quand un événement <literal>PGEVT_REGISTER</literal> est reçu, le pointeur
      <parameter>evtInfo</parameter> doit être converti en un
      <structname>PGEventRegister *</structname>. Cette structure contient un
      <structname>PGconn</structname> qui doit être dans le statut
      <literal>CONNECTION_OK</literal>&nbsp;; garanti si
      <xref linkend="libpq-PQregisterEventProc"/> est appelé juste après avoir
      obtenu un bon <structname>PGconn</structname>. Lorsqu'elle renvoit
      un code d'erreur, le nettoyage doit être réalisé car aucun événement
      <literal>PGEVT_CONNDESTROY</literal> ne sera envoyé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pgevt-connreset">
    <term><literal>PGEVT_CONNRESET</literal></term>
    <listitem>
     <para>
      L'événement de réinitialisation de connexion est déclenché après un
      <xref linkend="libpq-PQreset"/> ou un <function>PQresetPoll</function>. Dans
      les deux cas, l'événement est seulement déclenché si la ré-initialisation
      est réussie. Si la procédure échoue, la réinitialisation de connexion
      échouera&nbsp;; la structure <structname>PGconn</structname> est placée
      dans le statut <literal>CONNECTION_BAD</literal> et
      <function>PQresetPoll</function> renverra
      <literal>PGRES_POLLING_FAILED</literal>.

      <synopsis>
        typedef struct
        {
            PGconn *conn;
        } PGEventConnReset;
      </synopsis>

      Quand un événement <literal>PGEVT_CONNRESET</literal> est reçu, le
      pointeur <parameter>evtInfo</parameter> doit être converti en un
      <structname>PGEventConnReset *</structname>. Bien que le
      <structname>PGconn</structname> a été réinitialisé, toutes les données
      de l'événement restent inchangées. Cet événement doit être utilisé pour
      ré-initialiser/recharger/re-requêter tout <literal>instanceData</literal>
      associé. Notez que même si la procédure d'événement échoue à traiter
      <literal>PGEVT_CONNRESET</literal>, elle recevra toujours un événement
      <literal>PGEVT_CONNDESTROY</literal> à la fermeture de la connexion.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pgevt-conndestroy">
    <term><literal>PGEVT_CONNDESTROY</literal></term>
    <listitem>
     <para>
      L'événement de destruction de la connexion est déclenché en réponse
      à <xref linkend="libpq-PQfinish"/>. Il est de la responsabilité de la
      procédure de l'événement de nettoyer proprement ses données car
      libpq n'a pas les moyens de gérer cette mémoire. Un échec du
      nettoyage amènera des fuites de mémoire.

      <synopsis>
        typedef struct
        {
            PGconn *conn;
        } PGEventConnDestroy;
      </synopsis>

      Quand un événement <literal>PGEVT_CONNDESTROY</literal> est reçu, le
      pointeur <parameter>evtInfo</parameter> doit être converti en un
      <structname>PGEventConnDestroy *</structname>. Cet événement est
      déclenché avant que <xref linkend="libpq-PQfinish"/> ne réalise d'autres
      nettoyages. La valeur de retour de la procédure est ignorée car il
      n'y a aucun moyen d'indiquer un échec de <xref linkend="libpq-PQfinish"/>.
      De plus, un échec de la procédure ne doit pas annuler le nettoyage de
      la mémoire non désirée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pgevt-resultcreate">
    <term><literal>PGEVT_RESULTCREATE</literal></term>
    <listitem>
     <para>
      L'événement de création de résultat est déclenché en réponse à
      l'utilisation d'une fonction d'exécution d'une requête, par exemple
      <xref linkend="libpq-PQgetResult"/>. Cet événement sera déclenché seulement
      après la création réussie du résultat.

      <synopsis>
        typedef struct
        {
            PGconn *conn;
            PGresult *result;
        } PGEventResultCreate;
      </synopsis>

      Quand un événement <literal>PGEVT_RESULTCREATE</literal> est reçu, le
      pointeur <parameter>evtInfo</parameter> doit être converti en un
      <structname>PGEventResultCreate *</structname>. Le paramètre
      <parameter>conn</parameter> est la connexion utilisée pour générer le
      résultat. C'est le moment idéal pour initialiser tout
      <literal>instanceData</literal> qui doit être associé avec le résultat.
      Si la procédure échoue, le résultat sera effacé et l'échec sera propagé.
      La procédure d'événement ne doit pas tenter elle-même un
      <xref linkend="libpq-PQclear"/> sur l'objet résultat.
      Lors du renvoi d'un code d'échec, tout le
      nettoyage doit être fait car aucun événement
      <literal>PGEVT_RESULTDESTROY</literal> ne sera envoyé.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pgevt-resultcopy">
    <term><literal>PGEVT_RESULTCOPY</literal></term>
    <listitem>
     <para>
      L'événement de copie du résultat est déclenché en réponse à un
      <xref linkend="libpq-PQcopyResult"/>. Cet événement se déclenchera
      seulement une fois la copie terminée. Seules les procédures qui ont
      géré avec succès l'événement <literal>PGEVT_RESULTCREATE</literal>
      ou <literal>PGEVT_RESULTCOPY</literal> pour le résultat source recevront
      les événements <literal>PGEVT_RESULTCOPY</literal>.

      <synopsis>
        typedef struct
        {
            const PGresult *src;
            PGresult *dest;
        } PGEventResultCopy;
      </synopsis>

      Quand un événement <literal>PGEVT_RESULTCOPY</literal> est reçu, le
      pointeur <parameter>evtInfo</parameter> doit être converti en un
      <structname>PGEventResultCopy *</structname>. Le résultat
      <parameter>src</parameter> correspond à ce qui a été copié
      alors que le résultat <parameter>dest</parameter> correspond à la
      destination. Cet événement peut être utilisé pour fournir une copie
      complète de <literal>instanceData</literal>, ce que
      <literal>PQcopyResult</literal> ne peut pas faire. Si la procédure
      échoue, l'opération complète de copie échouera et le résultat
      <parameter>dest</parameter> sera effacé. Au renvoi d'un code d'échec,
      tout le nettoyage doit être réalisé car aucun événement
      <literal>PGEVT_RESULTDESTROY</literal> ne sera envoyé pour le résultat
      de destination.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pgevt-resultdestroy">
    <term><literal>PGEVT_RESULTDESTROY</literal></term>
    <listitem>
     <para>
      L'événement de destruction de résultat est déclenché en réponse à la
      fonction <xref linkend="libpq-PQclear"/>. Il est de la responsabilité de
      l'événement de nettoyer proprement les données de l'événement car libpq
      n'a pas la capacité de gérer cette mémoire. Si le nettoyage
      échoue, cela sera la cause de pertes mémoire.

      <synopsis>
        typedef struct
        {
            PGresult *result;
        } PGEventResultDestroy;
      </synopsis>

      Quand un événement <literal>PGEVT_RESULTDESTROY</literal> est reçu, le
      pointeur <parameter>evtInfo</parameter> doit être converti en un
      <structname>PGEventResultDestroy *</structname>. Cet événement est
      déclenché avant que <xref linkend="libpq-PQclear"/> ne puisse faire de
      nettoyage. La valeur de retour de la procédure est ignorée car il
      n'existe aucun moyen d'indiquer un échec à partir de
      <xref linkend="libpq-PQclear"/>. De plus, un échec de la procédure ne doit
      pas annuler le nettoyage de la mémoire non désirée.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="libpq-events-proc">
  <title>Procédure de rappel de l'événement</title>

  <variablelist>
   <varlistentry id="libpq-PGEventProc">
   <term><literal>PGEventProc</literal><indexterm><primary>PGEventProc</primary></indexterm></term>

    <listitem>
     <para>
      <literal>PGEventProc</literal> est une définition de type pour un pointeur
      vers une procédure d'événement, c'est-à-dire la fonction utilisateur
      appelée pour les événements de la libpq. La signature d'une telle fonction
      doit être&nbsp;:

      <synopsis>
        int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
      </synopsis>

      Le paramètre <parameter>evtId</parameter> indique l'événement
      <literal>PGEVT</literal> qui est survenu. Le pointeur
      <parameter>evtInfo</parameter> doit être converti vers le type
      de structure approprié pour obtenir plus d'informations sur l'événement.
      Le paramètre <parameter>passThrough</parameter> est le pointeur fourni
      à <xref linkend="libpq-PQregisterEventProc"/> quand la procédure de
      l'événement a été enregistrée. La fonction doit renvoyer une valeur
      différente de zéro en cas de succès et zéro en cas d'échec.
     </para>

     <para>
      Une procédure d'événement particulière peut être enregistrée une fois
      seulement pour un <structname>PGconn</structname>. Ceci est dû au fait
      que l'adresse de la procédure est utilisée comme clé de recherche pour
      identifier les données instanciées associées.
     </para>

     <caution>
      <para>
       Sur Windows, les fonctions peuvent avoir deux adresses différentes&nbsp;:
       une visible de l'extérieur de la DLL et une visible de l'intérieur. Il
       faut faire attention que seule une de ces adresses soit utilisée avec les
       fonctions d'événement de la <application>libpq</application>, sinon une
       confusion en résultera. La règle la plus simple pour écrire du code
       fonctionnel est de s'assurer que les procédures d'événements sont
       déclarées <literal>static</literal>. Si l'adresse de la procédure doit
       être disponible en dehors de son propre fichier source, il faut exposer
       une fonction séparée pour renvoyer l'adresse.
      </para>
     </caution>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="libpq-events-funcs">
  <title>Fonctions de support des événements</title>

  <variablelist>
   <varlistentry id="libpq-PQregisterEventProc">
    <term><function>PQregisterEventProc</function><indexterm><primary>PQregisterEventProc</primary></indexterm></term>

    <listitem>
     <para>
      Enregistre une procédure de rappel pour les événements avec libpq.

      <synopsis>
        int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                                const char *name, void *passThrough);
      </synopsis>
     </para>

     <para>
      Une procédure d'événement doit être enregistrée une fois pour chaque
      <structname>PGconn</structname> pour lequel vous souhaitez recevoir des
      événements. Il n'existe pas de limite, autre que la mémoire, sur le
      nombre de procédures d'événements qui peuvent être enregistrées avec
      une connexion. La fonction renvoie une valeur différente de zéro en cas
      de succès, et zéro en cas d'échec.
     </para>

     <para>
      L'argument <parameter>proc</parameter> sera appelé quand se déclenchera
      un événement libpq. Son adresse mémoire est aussi utilisée pour rechercher
      <literal>instanceData</literal>. L'argument <parameter>name</parameter>
      est utilisé pour faire référence à la procédure d'évenement dans les
      messages d'erreur. Cette valeur ne peut pas être <symbol>NULL</symbol> ou une chaîne de
      longueur nulle. La chaîne <parameter>name</parameter> est copiée dans
      <structname>PGconn</structname>, donc ce qui est passé n'a pas besoin
      d'exister longtemps. Le pointeur <parameter>passThrough</parameter> est
      passé à <parameter>proc</parameter> à chaque arrivée d'un événement. Cet
      argument peut être <symbol>NULL</symbol>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetInstanceData">
    <term><function>PQsetInstanceData</function><indexterm><primary>PQsetInstanceData</primary></indexterm></term>
    <listitem>
     <para>
      Initialise avec <parameter>data</parameter>
      l'<literal>instanceData</literal> de la connexion
      <parameter>conn</parameter> pour la
      procédure <parameter>proc</parameter>.
      Cette fonction renvoit zéro en cas d'échec et autre chose en cas de réussite.
      (L'échec est seulement possible si <parameter>proc</parameter> n'a pas
      été correctement enregistré dans <parameter>conn</parameter>.)

      <synopsis>
        int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQinstanceData">
    <term><function>PQinstanceData</function><indexterm><primary>PQinstanceData</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie l'<literal>instanceData</literal> de la connexion
      <parameter>conn</parameter> associée
      au <parameter>proc</parameter> ou <symbol>NULL</symbol> s'il
      n'y en a pas.

      <synopsis>
        void *PQinstanceData(const PGconn *conn, PGEventProc proc);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQresultSetInstanceData">
    <term><function>PQresultSetInstanceData</function><indexterm><primary>PQresultSetInstanceData</primary></indexterm></term>
    <listitem>
     <para>
      Initialise avec <parameter>data</parameter>
      l'<literal>instanceData</literal> du résultat pour la
      procédure <parameter>proc</parameter>.
      Cette fonction renvoit zéro en cas d'échec et autre chose en cas de réussite.
      (L'échec est seulement possible si <parameter>proc</parameter> n'a pas
      été correctement enregistré dans le résultat.)

      <synopsis>
        int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
      </synopsis>
     </para>

     <para>
      Attention, aucun stockage représenté par <parameter>data</parameter> ne
      sera pris en compte par <xref linkend="libpq-PQresultMemorySize"/>, à moins
      qu'il est alloué en utilisant <xref linkend="libpq-PQresultAlloc"/>.
      (Faire ceci est recommandé car cela élimine le besoin de libérer le stockage explicitement
      quand le résultat est supprimé.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQresultInstanceData">
    <term><function>PQresultInstanceData</function><indexterm><primary>PQresultInstanceData</primary></indexterm></term>
    <listitem>
     <para>
      Renvoie l'<literal>instanceData</literal> du résultat associé à
      <parameter>proc</parameter> ou <symbol>NULL</symbol> s'il n'y
      en a pas.

      <synopsis>
        void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
      </synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="libpq-events-example">
  <title>Exemple d'un événement</title>

  <para>
   Voici un exemple d'une gestion de données privées associée aux connexions
   et aux résultats de la libpq.
  </para>

  <programlisting>
<![CDATA[
/* en-tête nécssaire pour les événements de la libpq (note : inclut libpq-fe.h) */
#include <libpq-events.h>

/* la donnée instanciée : instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn =
        PQconnectdb("dbname=postgres options=-csearch_path=");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* appelée une fois pour toute connexion qui doit recevoir des événements.
     * Envoit un PGEVT_REGISTER à myEventProc.
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* la connexion instanceData est disponible */
    data = PQinstanceData(conn, myEventProc);

    /* Envoit un PGEVT_RESULTCREATE à myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* le résultat instanceData est disponible */
    data = PQresultInstanceData(res, myEventProc);

    /* Si PG_COPYRES_EVENTS est utilisé, envoit un PGEVT_RESULTCOPY à myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* le résultat instanceData est disponible si PG_COPYRES_EVENTS a été
     * utilisé lors de l'appel à PQcopyResult.
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    /* Les deux fonctions de nettoyage envoient PGEVT_RESULTDESTROY à myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* Envoit un PGEVT_CONNDESTROY à myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* associe des données spécifiques de l'application avec la connexion */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* libère les données instanciées car la connexion est en cours de destruction */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* associe des données spécifiques à l'application avec les résultats (copié de la connexion) */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* associe des données spécifiques à l'application avec les résultats (copié d'un résultat) */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* libère les données instanciées car le résultat est en cours de destruction */
            if (data)
              free_mydata(data);
            break;
        }

        /* unknown event id, just return TRUE. */
        default:
            break;
    }

    return TRUE; /* event processing succeeded */
}
]]>
  </programlisting>
 </sect2>
</sect1>

<sect1 id="libpq-envars">
 <title>Variables d'environnement</title>

 <indexterm zone="libpq-envars">
  <primary>variable d'environnement</primary>
 </indexterm>

 <para>
  Les variables d'environnement suivantes peuvent être utilisées pour
  sélectionner des valeurs par défaut pour les paramètres de connexion,
  valeurs qui seront utilisées par <xref linkend="libpq-PQconnectdb"/>, <xref
  linkend="libpq-PQsetdbLogin"/> et <xref linkend="libpq-PQsetdb"/> si aucune
  valeur n'est directement précisée par le code appelant. Elles sont utiles
  pour éviter de coder en dur les informations de connexion à la base de
  données dans les applications clients, par exemple.

  <itemizedlist>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGHOST</envar></primary>
     </indexterm>
     <envar>PGHOST</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-host"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGHOSTADDR</envar></primary>
     </indexterm>
     <envar>PGHOSTADDR</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-hostaddr"/>.
     Elle peut être initialisée à la place ou en plus de <envar>PGHOST</envar>
     pour éviter la charge supplémentaire d'une résolution DNS.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGPORT</envar></primary>
     </indexterm>
     <envar>PGPORT</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-port"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGDATABASE</envar></primary>
     </indexterm>
     <envar>PGDATABASE</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-dbname"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGUSER</envar></primary>
     </indexterm>
     <envar>PGUSER</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-user"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGPASSWORD</envar></primary>
     </indexterm>
     <envar>PGPASSWORD</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-password"/>. L'utilisation de cette variable
     d'environnement n'est pas recommandée pour des raisons de sécurité, car certains
     systèmes d'exploitation autorisent les utilisateurs autres que root à voir les
     variables d'environnement du processus via <application>ps</application>)&nbsp;; à la
     place, envisagez l'utilisation d'un fichier de mots de passe (voir la <xref
     linkend="libpq-pgpass"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGPASSFILE</envar></primary>
     </indexterm>
     <envar>PGPASSFILE</envar> se comporte de la même façon que le paramètre de
     connexion <xref linkend="libpq-connect-passfile"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGCHANNELBINDING</envar></primary>
     </indexterm>
     <envar>PGCHANNELBINDING</envar> se comporte de la même façon que le paramètre
     de connexion <xref linkend="libpq-connect-channel-binding"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSERVICE</envar></primary>
     </indexterm>
     <envar>PGSERVICE</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-service"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSERVICEFILE</envar></primary>
     </indexterm>
     <envar>PGSERVICEFILE</envar> indique le nom du fichier service de
     connexion par utilisateur. S'il n'est pas configuré, sa valeur par
     défaut est <filename>~/.pg_service.conf</filename>
     (voir <xref linkend="libpq-pgservice"/>).
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGOPTIONS</envar></primary>
     </indexterm>
     <envar>PGOPTIONS</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-options"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGAPPNAME</envar></primary>
     </indexterm>
     <envar>PGAPPNAME</envar> se comporte de la même façon que le paramètre
     de connexion <xref linkend="libpq-connect-application-name"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLMODE</envar></primary>
     </indexterm>
     <envar>PGSSLMODE</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-sslmode"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGREQUIRESSL</envar></primary>
     </indexterm>
     <envar>PGREQUIRESSL</envar> se comporte de la même façon que le paramètre
      de configuration <xref linkend="libpq-connect-requiressl"/>.
      Cette variable d'environnement est obsolète, remplacée par la variable
      <envar>PGSSLMODE</envar>&nbsp; si les deux variables sont initialisées,
      <envar>PGREQUIRESSL</envar> est ignoré.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLCOMPRESSION</envar></primary>
     </indexterm>
     <envar>PGSSLCOMPRESSION</envar> se comporte de la même façon que le
     paramètre de connexion <xref linkend="libpq-connect-sslcompression"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLCERT</envar></primary>
     </indexterm>
     <envar>PGSSLCERT</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-sslcert"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLKEY</envar></primary>
     </indexterm>
     <envar>PGSSLKEY</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-sslkey"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLROOTCERT</envar></primary>
     </indexterm>
     <envar>PGSSLROOTCERT</envar> se comporte de la même façon que le paramètre
     de configuration <xref linkend="libpq-connect-sslrootcert"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLCRL</envar></primary>
     </indexterm>
     <envar>PGSSLCRL</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-sslcrl"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGREQUIREPEER</envar></primary>
     </indexterm>
     <envar>PGREQUIREPEER</envar> se comporte de la même façon que le
     paramètre de connexion <xref linkend="libpq-connect-requirepeer"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLMINPROTOCOLVERSION</envar></primary>
     </indexterm>
     <envar>PGSSLMINPROTOCOLVERSION</envar> se comporte de la même façon que le paramètre
     de connexion <xref linkend="libpq-connect-ssl-min-protocol-version"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSSLMAXPROTOCOLVERSION</envar></primary>
     </indexterm>
     <envar>PGSSLMAXPROTOCOLVERSION</envar> se comporte de la même façon que le paramètre
     de connexion <xref linkend="libpq-connect-ssl-min-protocol-version"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGKRBSRVNAME</envar></primary>
     </indexterm>
     <envar>PGKRBSRVNAME</envar> se comporte de la même façon que le paramètre
     de configuration <xref linkend="libpq-connect-krbsrvname"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGGSSENCMODE</envar></primary>
     </indexterm>
     <envar>PGGSSENCMODE</envar> se comporte de la même façon que le
     paramètre de connexion <xref linkend="libpq-connect-gssencmode"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGGSSLIB</envar></primary>
     </indexterm>
     <envar>PGGSSLIB</envar> se comporte de la même façon que le paramètre de
     configuration <xref linkend="libpq-connect-gsslib"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
     </indexterm>
     <envar>PGCONNECT_TIMEOUT</envar> se comporte de la même façon que le
     paramètre de configuration <xref linkend="libpq-connect-connect-timeout"/>.
    </para>
   </listitem>

   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGCLIENTENCODING</envar></primary>
     </indexterm>
     <envar>PGCLIENTENCODING</envar> se comporte de la même façon que
     le paramètre de connexion <xref
     linkend="libpq-connect-client-encoding"/>.
    </para>
   </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTARGETSESSIONATTRS</envar></primary>
      </indexterm>
      <envar>PGTARGETSESSIONATTRS</envar> se comporte de la même façon que le
      paramètre de connexion <xref
          linkend="libpq-connect-target-session-attrs"/>.
     </para>
    </listitem>
  </itemizedlist>
 </para>

 <para>
  Les variables d'environnement peuvent être utilisées pour
  spécifier le comportement par défaut de chaque session
  <productname>PostgreSQL</productname> (voir aussi les commandes
  <xref linkend="sql-alterrole"/> et
  <xref linkend="sql-alterdatabase"/>
  pour modifier le comportement par défaut par utilisateur ou par base de données).

  <itemizedlist>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGDATESTYLE</envar></primary>
     </indexterm>
     <envar>PGDATESTYLE</envar>
     initialise le style par défaut de la représentation de la date et de l'heure
     (équivalent à <literal>SET datestyle TO ...</literal>).
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGTZ</envar></primary>
     </indexterm>
     <envar>PGTZ</envar> initialise le fuseau horaire par défaut
     (équivalent à <literal>SET timezone TO ...</literal>).
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGGEQO</envar></primary>
     </indexterm>
     <envar>PGGEQO</envar>
     initialise le mode par défaut pour l'optimiseur génétique de requêtes
     (équivalent à <literal>SET geqo TO ...</literal>).
    </para>
   </listitem>
  </itemizedlist>

  Référez-vous à la commande <acronym>SQL</acronym>
  <xref linkend="sql-set"/> pour
  plus d'informations sur des valeurs correctes pour ces variables
  d'environnement.
 </para>

 <para>
  Les variables d'environnement suivantes déterminent le comportement interne
  de <application>libpq</application>&nbsp;; elles surchargent les valeurs
  par défaut issues de la compilation.

  <itemizedlist>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGSYSCONFDIR</envar></primary>
     </indexterm>
     <envar>PGSYSCONFDIR</envar>
     configure le répertoire contenant le fichier
     <filename>pg_service.conf</filename> et, peut-être dans une future version,
     d'autres fichiers de configuration globaux au système.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm>
      <primary><envar>PGLOCALEDIR</envar></primary>
     </indexterm>
     <envar>PGLOCALEDIR</envar>
     configure le répertoire contenant les fichiers <literal>locale</literal> pour
     l'internationalisation des messages.
    </para>
   </listitem>
  </itemizedlist>
 </para>

</sect1>


<sect1 id="libpq-pgpass">
 <title>Fichier de mots de passe</title>

 <indexterm zone="libpq-pgpass">
  <primary>fichier de mots de passe</primary>
 </indexterm>
 <indexterm zone="libpq-pgpass">
  <primary>.pgpass</primary>
 </indexterm>

 <para>
  Le fichier <filename>.pgpass</filename>, situé dans le répertoire personnel de
  l'utilisateur est un fichier contenant les mots de passe à utiliser si la
  connexion requiert un mot de passe (et si aucun mot de passe n'a été spécifié).
  Sur Microsoft Windows, le fichier est nommé
  <filename>%APPDATA%\postgresql\pgpass.conf</filename> (où <filename>%APPDATA%</filename>
  fait référence au sous-répertoire Application Data du profil de l'utilisateur).
  De manière alternative, un fichier de mots de passe peut être spécifié en
  utilisant le paramètre de connexion <xref linkend="libpq-connect-passfile"/>
  ou la variable d'environnement <envar>PGPASSFILE</envar>.
 </para>

 <para>
  Ce fichier devra être composé de lignes au format suivant (une ligne par connexion)&nbsp;:
  <synopsis><replaceable>nom_hote</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>nomutilisateur</replaceable>:<replaceable>motdepasse</replaceable> </synopsis>
   (Vous pouvez ajouter un rappel en commentaire dans le fichier en copiant
   cette ligne et en la précédant d'un dièse (<literal>#</literal>).)
   Chacun des quatre premiers champs peut être une valeur littérale ou
   <literal>*</literal>, qui correspond à tout.
   La première ligne correspondant aux paramètres de
   connexion sera utilisée (du coup, placez les entrées les plus spécifiques
   en premier lorsque vous utilisez des jokers). Si une entrée doit contenir
   <literal>:</literal> ou <literal>\</literal>, échappez ce caractère avec
   <literal>\</literal>. Le nom de l'hôte est rapproché du paramètre de connexion
   <literal>host</literal> s'il est spécifié, sinon au paramètre
   <literal>hostaddr</literal> si spécifié. Si ni l'un ni l'autre ne sont
   fournis, l'hôte <literal>localhost</literal> sera alors recherché.
   L'hôte <literal>localhost</literal> est également recherché si la connexion
   est une socket de domaine Unix et que le paramètre <literal>host</literal>
   correspond au répertoire par défaut de la <application>libpq</application>.

   Sur un serveur secondaire, un champ <literal>database</literal> à
   <literal>replication</literal> correspond aux connexions de réplication
   par flux au serveur maître. À part cela, le champ <literal>database</literal>
   est d'une utilité limitée, puisque les utilisateurs ont le même mot de
   passe pour toutes les bases de données de l'instance.
  </para>

  <para>
   Sur les systèmes Unix, les droits sur un fichier de mots de passe doivent
   interdire l'accès au groupe et au reste du monde&nbsp;; faites-le avec une
   commande comme <command>chmod 0600 ~/.pgpass</command>. Si les droits sont
   moins stricts, le fichier sera ignoré. Sur Microsoft Windows, il est
   supposé que le fichier est stocké dans un répertoire qui est sécurisé, donc
   aucune vérification des droits n'est effectuée.
  </para>
 </sect1>

 <sect1 id="libpq-pgservice">
  <title>Fichier des services de connexion</title>

  <indexterm zone="libpq-pgservice">
   <primary>fichier des services de connexion</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>

  <para>
   Le fichier des services de connexion permet d'associer des paramètres de
   connexion à un nom de service unique. Ce nom de service peut ensuite être
   spécifié par une connexion libpq et les paramétrages associés seront utilisés.
   On peut donc modifier les paramètres de connexion sans avoir à recompiler
   l'application libpq. Le nom de service peut aussi être spécifié en utilisant
   la variable d'environnement <envar>PGSERVICE</envar>.
  </para>

  <para>
   Le fichier de service peut être un fichier par utilisateur
   sur <filename>~/.pg_service.conf</filename> ou à l'emplacement indiqué par
   la variable d'environnement <envar>PGSERVICEFILE</envar>. Il peut aussi être
   un fichier global au système dans le répertoire
   <filename>`pg_config --sysconfdir`/pg_service.conf</filename> ou dans le répertoire indiqué par
   la variable d'environnement <envar>PGSYSCONFDIR</envar>. Si des définitions
   de service de même nom existent dans les fichiers utilisateur et système,
   le fichier utilisateur est prioritaire.
  </para>

  <para>
   Le fichier utilise le format des <quote>fichiers INI</quote> où le nom de
   section et les paramètres sont des paramètres de connexion&nbsp;; voir
   <xref linkend="libpq-paramkeywords"/> pour une liste. Par exemple&nbsp;:
   <programlisting>
    # comment
    [mabase]
    host=unhote
    port=5433
    user=admin
  </programlisting>
  <filename>share/pg_service.conf.sample</filename> est fourni comme
  fichier d'exemple.
 </para>
</sect1>

<sect1 id="libpq-ldap">
 <title>Recherche LDAP des paramètres de connexion</title>

 <indexterm zone="libpq-ldap">
  <primary>Recherche LDAP des paramètres de connexion</primary>
 </indexterm>

 <para>
  Si <application>libpq</application> a été compilé avec le support de LDAP (option
  <literal><option>--with-ldap</option></literal> du script <command>configure</command>),
  il est possible de récupérer les options de connexion comme <literal>host</literal>
  ou <literal>dbname</literal> via LDAP à partir d'un serveur central.
  L'avantage en est que, si les paramètres de connexion d'une base évolue,
  l'information de connexion n'a pas à être modifiée sur toutes les machines
  clientes.
 </para>

 <para>
  La recherche LDAP des paramètres de connexion utilise le fichier service
  <filename>pg_service.conf</filename> (voir <xref linkend="libpq-pgservice"/>).
  Une ligne dans <filename>pg_service.conf</filename> commençant par
  <literal>ldap://</literal> sera reconnue comme une URL LDAP et une requête LDAP
  sera exécutée. Le résultat doit être une liste de paires <literal>motclé =
   valeur</literal> qui sera utilisée pour configurer les options de connexion.
  L'URL doit être conforme à la RFC 1959 et être de la forme&nbsp;:
  <synopsis>
   ldap://[<replaceable>hôte</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>base_recherche</replaceable>?<replaceable>attribut</replaceable>?<replaceable>étendue_recherche</replaceable>?<replaceable>filtre</replaceable>
  </synopsis>
  où <replaceable>hôte</replaceable> vaut par défaut <literal>localhost</literal>
  et <replaceable>port</replaceable> vaut par défaut 389.
 </para>

 <para>
  Le traitement de <filename>pg_service.conf</filename> se termine après une
  recherche LDAP réussie, mais continue si le serveur LDAP ne peut pas
  être contacté. Cela fournit un moyen de préciser d'autres URL LDAP pointant
  vers d'autres serveurs LDAP, des paires classiques <literal>motclé =
   valeur</literal> ou les options de connexion par défaut. Si dans ce cas
   vous préférez avoir un message d'erreur, ajoutez une ligne syntaxiquement
   incorrecte après l'URL LDAP.
 </para>

 <para>
  À titre d'exemple, une entrée LDAP créée à partir du fichier LDIF suivant
  <programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
  </programlisting>
  peut être retrouvée avec l'URL LDAP suivante&nbsp;:
  <programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
  </programlisting>
 </para>

 <para>
  Dans le fichier de service, vous pouvez mélanger des entrées standards avec
  des recherches LDAP. Voici un exemple complet d'un bloc dans
  <filename>pg_service.conf</filename>&nbsp;:
  <programlisting>
    # seuls l'hôte et le port sont stockés dans LDAP,
    # spécifiez explicitement le nom de la base et celui de l'utilisateur
    [customerdb]
    dbname=clients
    user=utilisateurappl
    ldap://ldap.acme.com/cn=serveur,cn=hosts?pgconnectinfo?base?(objectclass=*)
  </programlisting>
 </para>
</sect1>


<sect1 id="libpq-ssl">
 <title>Support de SSL</title>

 <indexterm zone="libpq-ssl">
  <primary>SSL</primary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname> dispose d'un support natif des connexions
  <acronym>SSL</acronym> pour chiffrer les connexions client/serveur et améliorer
  ainsi la sécurité. Voir la <xref linkend="ssl-tcp"/> pour des détails sur la
  fonctionnalité <acronym>SSL</acronym> côté serveur.
 </para>

 <para>
  <application>libpq</application> lit le fichier de configuration système
  d'<productname>OpenSSL</productname>. Par défaut, ce fichier est nommé
  <filename>openssl.cnf</filename> et est placé dans le répertoire indiqué par
  <literal>openssl version -d</literal>. Cette valeur par défaut peut être
  surchargée en configurant la variable d'environnement
  <envar>OPENSSL_CONF</envar> avec le nom du fichier de configuration
  souhaité.
 </para>

 <sect2 id="libq-ssl-certificates">
  <title>Vérification par le client du certificat serveur</title>

  <para>
   Par défaut, <productname>PostgreSQL</productname> ne vérifie pas le certificat
   du serveur. Cela signifie qu'il est possible de se faire passer pour le
   serveur final (par exemple en modifiant un enregistrement DNS ou en prenant
   l'adresse IP du serveur) sans que le client ne le sache.
   Pour empêcher cette usurpation (<foreignphrase>spoofing</foreignphrase>),
   le client doit être capable de vérifier l'identité du serveur via une
   chaîne de confiance. Une chaîne de confiance est établie en plaçant
   sur un ordinateur le certificat racine (auto-signé) d'une autorité de
   certification (<acronym>CA</acronym>), et sur un autre
   ordinateur un certificat feuille <emphasis>signé</emphasis> avec
   le certificat racine. Il est aussi possible d'utiliser un certificat
   <quote>intermédiaire</quote> signé par le certificat racine et qui signe
   des certificats feuilles.
  </para>

  <para>
   Pour permettre au client de vérifier l'identité du serveur, placez un
   certificat racine sur le client et un certificat feuille signé par le
   certificat racine sur le serveur. Pour permettre au serveur de vérifier
   l'identité du client, placez un certificat racine sur le serveur et un
   certificat feuille signé par le certificat racine sur le client. Un ou
   plusieurs certificats intermédiaires (habituellement stockés avec le
   certificat feuille) peuvent aussi être utilisés pour lier le certificat
   feuille au certificat racine.
  </para>

  <para>
   Une fois qu'une chaîne de confiance a été établie, il existe deux façons
   pour le client de valider le certificat feuille envoyé par le serveur. Si
   le paramètre <literal>sslmode</literal> est configuré à
   <literal>verify-ca</literal>, libpq vérifiera qu'il peut faire confiance
   au serveur en vérifiant
   la chaîne des certificats jusqu'au certificat racine stocké sur le client.
   Si <literal>sslmode</literal> est configuré à
   <literal>verify-full</literal>, libpq va <emphasis>aussi</emphasis>
   vérifier que le nom
   d'hôte du serveur correspond au nom stocké dans le certificat du serveur.
   La connexion SSL échouera si le certificat du serveur n'établit pas ces
   correspondances. La connexion SSL échouera si le certificat du serveur ne
   peut pas être vérifié. <literal>verify-full</literal> est recommandé pour
   les environnements les plus sensibles à la sécurité.
  </para>

  <para>
   En mode <literal>verify-full</literal>, le nom de l'hôte est mis
   en correspondance avec le ou les attributs <literal>Subject Alternative
   Name</literal> du certificat, ou avec l'attribut
   <literal>Common Name</literal> si aucun
   <literal>Subject Alternative Name</literal> de type
   <literal>dNSName</literal> n'est présent. Si le nom du
   certificat débute avec le caractère étoile (<literal>*</literal>),
   l'étoile sera traitée comme un métacaractère qui
   correspondra à tous les caractères <emphasis>à l'exception
   </emphasis> du point. Cela signifie que le certificat ne pourra pas
   correspondre à des sous-domaines. Si la connexion se
   fait en utilisant une adresse IP au lieu d'un nom d'hôte, l'adresse
   IP sera vérifiée (sans faire de résolution DNS).
  </para>

  <para>
   Pour permettre la vérification du certificat du serveur, un ou plusieurs
   certificats racines doivent être placés dans le fichier
   <filename>~/.postgresql/root.crt</filename> du répertoire personnel de
   l'utilisateur (sur Windows, le fichier est nommé
   <filename>%APPDATA%\postgresql\root.crt</filename>). Les certificats
   intermédiaires doivent aussi être ajoutés au fichier s'ils sont nécessaires
   pour lier la chaîne de certificats envoyée par le serveur aux certificats
   racines stockés sur le client.
  </para>

  <para>

   Les entrées de la liste de révocation des certificats (CRL) sont aussi
   vérifiées si le fichier <filename>~/.postgresql/root.crl</filename> existe
   (<filename>%APPDATA%\postgresql\root.crl</filename> sur Microsoft
   Windows).
  </para>

  <para>
   L'emplacement du certificat racine et du CRL peuvent être changés avec
   les paramètres de connexion <literal>sslrootcert</literal> et
   <literal>sslcrl</literal>, ou les variables d'environnement
   <envar>PGSSLROOTCERT</envar> et <envar>PGSSLCRL</envar>.
  </para>

  <note>
   <para>
    Par compatibilité avec les anciennes versions de
    PostgreSQL, si un certificat racine d'autorité existe, le comportement
    de <literal>sslmode</literal>=<literal>require</literal> sera identique
    à celui de <literal>verify-ca</literal>. Cela signifie que le
    certificat du serveur est validé par l'autorité de certification. Il ne
    faut pas se baser sur ce comportement. Les applications qui ont besoin
    d'une validation du certificat doivent toujours utiliser
    <literal>verify-ca</literal> ou <literal>verify-full</literal>.
   </para>
  </note>

 </sect2>

 <sect2 id="libpq-ssl-clientcert">
  <title>Certificats des clients</title>

  <para>
   Si le serveur tente de vérifier l'identité du client en réclamant le
   certificat feuille du client, <application>libpq</application> enverra lse
   certificats stockés dans le fichier
   <filename>~/.postgresql/postgresql.crt</filename> du répertoire personnel
   de l'utilisateur. Les certificats doivent former une chaîne jusqu'au
   certificat racine de confiance du serveur. Un fichier de
   clé privé correspondant <filename>~/.postgresql/postgresql.key</filename>
   doit aussi être présent. Aucun accès au fichier de clé privée ne doit
   être autorisé pour le groupe ou pour le reste du monde&nbsp;; cela se fait avec la
   commande <command>chmod 0600 ~/.postgresql/postgresql.key</command>. Sur
   Microsoft Windows, ces fichiers sont nommés
   <filename>%APPDATA%\postgresql\postgresql.crt</filename> et
   <filename>%APPDATA%\postgresql\postgresql.key</filename>, et il n'y a pas
   de vérification des droits car ce répertoire est présumé sécurisé.
   L'emplacement des fichiers certificat et clé peut être surchargé par les
   paramètres de connexion <literal>sslcert</literal> et
   <literal>sslkey</literal>, ou les variables d'environnement
   <envar>PGSSLCERT</envar> et <envar>PGSSLKEY</envar>.
  </para>

  <para>
   Le premier certificat dans <filename>postgresql.crt</filename> doit être le
   certificat du client parce qu'il doit correspondre à la clé privée du
   client. Les certificats <quote>intermédiaires</quote> peuvent être ajoutés
   au fichier en option &mdash; faire ainsi permet d'éviter d'avoir à stocker les
   certificats intermédiaires sur le serveur (<xref linkend="guc-ssl-ca-file"/>).
  </para>

  <para>
   Le certificat et la clé doit être en format PEM ou ASN.1 DER.
  </para>

  <para>
   La clé peut être stockée en clair dans le texte ou chiffrée avec un
   passphrase utilisant un algorithme supporté par OpenSSL, comme AES-128. Si
   la clé est stockée chiffrée, alors la passphrase doit être fournie dans
   l'option de connexion <xref linkend="libpq-connect-sslpassword"/>. Si une
   clé chiffrée est fournie et que l'option <literal>sslpassword</literal> est
   absente ou vide, une invite de saisie de mot de passe interactive par
   OpenSSL s'affichera avec <literal>Enter PEM pass phrase:</literal> si un
   TTY est présent. Les applications peuvent passer outre l'invite du
   certificat client et la gestion du paramètre <literal>sslpassword</literal>
   en fournissant leur propre callback pour la clé du mot de passe, voir <xref
   linkend="libpq-pqsetsslkeypasshook-openssl"/>.
  </para>

  <para>
   Pour des instructions sur la création de certificats, voir <xref
   linkend="ssl-certificate-creation"/>.
  </para>

 </sect2>

 <sect2 id="libpq-ssl-protection">
  <title>Protection fournie dans les différents modes</title>

  <para>
   Les différentes valeurs du paramètre <literal>sslmode</literal> fournissent
   différents niveaux de protection. SSL peut fournir une protection contre trois types d'attaques différentes&nbsp;:
   <variablelist>
    <varlistentry>
     <term>Écoute clandestine (<foreignphrase>eavesdropping</foreignphrase>)</term>
     <listitem>
      <para>Si une tierce partie peut examiner le trafic réseau entre le
       client et le serveur, elle peut lire à la fois les informations de
       connexion (dont le nom de l'utilisateur et son mot de passe)
       ainsi que les données transmises <acronym>SSL</acronym> utilise
       le chiffrement pour empêcher cela.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Homme du milieu (<acronym>MITM</acronym>,
     <foreignphrase>Man in the middle</foreignphrase>)</term>
     <listitem>
      <para>Si une tierce partie peut modifier les données transitant entre
       le client et le serveur, il peut prétendre être le serveur et, du coup,
       voir et modifier les données <emphasis>y compris si elles sont
       chiffrées</emphasis>. La tierce partie peut ensuite renvoyer les
       informations de connexion et les données au serveur d'origine, rendant
       impossible à ce dernier la détection de l'attaque. Les vecteurs habituels
       pour parvenir à ce type d'attaque sont l'empoisonnement des DNS
       (<foreignphrase>DNS poisoning</foreignphrase>) et le détournement
       d'adresses (<foreignphrase>address hijacking</foreignphrase>),
       où le client est dirigé vers un autre serveur
       que celui attendu. Il existe encore plusieurs autres méthodes
       pour accomplir ceci. <acronym>SSL</acronym> utilise la vérification des
       certificats pour l'empêcher, en authentifiant le serveur auprès du
       client.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Usurpation d'identité</term>
     <listitem>
      <para>Si une tierce partie peut prétendre être un client autorisé, il
       peut tout simplement accéder aux données auquel il n'a pas droit.
       Typiquement, cela peut arriver avec une gestion incorrecte des mots de
       passe. <acronym>SSL</acronym> utilise les certificats clients pour
       empêcher ceci, en s'assurant que seuls les propriétaires de certificats
       valides peuvent accéder au serveur.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Pour qu'une connexion soit sûre, l'utilisation de SSL doit être configurée
   <emphasis>sur le client et sur le serveur</emphasis> avant que
   la connexion ne soit effective. Si elle n'est configurée que sur le serveur,
   le client pourrait envoyer des informations sensibles (comme les mots de
   passe) avant de savoir que le serveur exige une haute sécurité.
   Dans libpq, les connexions sécurisées peuvent être garanties en
   configurant le paramètre
   <literal>sslmode</literal> à <literal>verify-full</literal> ou
   <literal>verify-ca</literal>, et en fournissant au système un certificat
   racine à vérifier. Ceci est analogue à l'utilisation des <acronym>URL</acronym>
   <literal>https</literal> pour la navigation web chiffrée.
  </para>

  <para>
   Une fois que le serveur est authentifié, le client peut envoyer des données
   sensibles. Cela signifie que, jusqu'à ce point, le client n'a pas besoin de
   savoir si les certificats seront utilisés pour l'authentification&nbsp; ne
   le spécifier que dans la configuration du serveur est donc sûr.
  </para>

  <para>
   Toutes les options <acronym>SSL</acronym> impliquent une charge
   supplémentaire sous forme de chiffrement et d'échange de clés.
   Il y a donc un compromis à trouver entre performance et sécurité.
   <xref linkend="libpq-ssl-sslmode-statements"/> illustre les risques que les
   différentes valeurs
   de <literal>sslmode</literal> cherchent à protéger, et ce que cela apporte
   en sécurité et fait perdre en performances.
  </para>

  <table id="libpq-ssl-sslmode-statements">
   <title>Description des modes SSL</title>
   <tgroup cols="4">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="1*"/>
    <colspec colname="col4" colwidth="2*"/>
    <thead>
     <row>
      <entry><literal>sslmode</literal></entry>
      <entry>Protection contre l'écoute clandestine</entry>
      <entry>Protection contre l'attaque <acronym>MITM</acronym></entry>
      <entry>Remarques</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>disable</literal></entry>
      <entry>Non</entry>
      <entry>Non</entry>
      <entry>Peu m'importe la sécurité, et je ne veux pas le coût apporté
       par le chiffrement.
      </entry>
     </row>

     <row>
      <entry><literal>allow</literal></entry>
      <entry>Peut-être</entry>
      <entry>Non</entry>
      <entry>Peu m'importe la sécurité, mais je vais accepter le coût du
       chiffrement si le serveur insiste.
      </entry>
     </row>

     <row>
      <entry><literal>prefer</literal></entry>
      <entry>Peut-être</entry>
      <entry>Non</entry>
      <entry>Peu m'importe le chiffrement, mais j'accepte le coût du
       chiffrement si le serveur le supporte.
      </entry>
     </row>

     <row>
      <entry><literal>require</literal></entry>
      <entry>Oui</entry>
      <entry>Non</entry>
      <entry>Je veux chiffrer mes données, et j'en accepte le coût. Je fais
       confiance au réseau pour me garantir que je me connecterai toujours au
       serveur que je veux.
      </entry>
     </row>

     <row>
      <entry><literal>verify-ca</literal></entry>
      <entry>Oui</entry>
      <entry>Dépend de la politique de la CA</entry>
      <entry>Je veux chiffrer mes données, et j'en accepte le coût. Je veux
       être sûr que je me connecte à un serveur en qui j'ai confiance.
      </entry>
     </row>

     <row>
      <entry><literal>verify-full</literal></entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Je veux chiffrer mes données, et j'en accepte le coût. Je veux
       être sûr que je me connecte à un serveur en qui j'ai confiance et que
       c'est bien celui que j'ai indiqué.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   La différence entre <literal>verify-ca</literal> et <literal>verify-full</literal>
   dépend de la politique de la <acronym>CA</acronym> racine. Si une
   <acronym>CA</acronym> publique est utilisé, <literal>verify-ca</literal> permet
   les connexions à un serveur que <emphasis>quelqu'un d'autre</emphasis> a pu
   enregistrer pour cette <acronym>CA</acronym>. Dans ce cas,
   <literal>verify-full</literal> devrait toujours être utilisé. Si une
   <acronym>CA</acronym> locale est utilisée, voire un certificat auto-signé,
   utiliser <literal>verify-ca</literal> fournit souvent suffisamment de
   protection.
  </para>

  <para>
   La valeur par défaut pour <literal>sslmode</literal> est <literal>prefer</literal>.
   Comme l'indique la table ci-dessus, cela n'a pas de sens d'un point de vue
   de la sécurité, et ne promet, si elle possible, qu'un surcoût en terme
   de performance.
   Cette valeur est fournie par défaut uniquement pour la
   compatibilité descendante, et n'est pas recommandée pour les déploiements de
   serveurs nécessitant de la sécurité.
  </para>

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
  <title>Utilisation des fichiers SSL</title>

  <para>
   <xref linkend="libpq-ssl-file-usage"/> résume les fichiers liés à la
   configuration de SSL sur le client.
  </para>

  <table id="libpq-ssl-file-usage">
   <title>Utilisation des fichiers SSL libpq/client</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Fichier</entry>
      <entry>Contenu</entry>
      <entry>Effet</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><filename>~/.postgresql/postgresql.crt</filename></entry>
      <entry>certificat client</entry>
      <entry>envoyé au serveur</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/postgresql.key</filename></entry>
      <entry>clé privée du client</entry>
      <entry>prouve le certificat client envoyé par l'utilisateur&nbsp;;
       n'indique pas que le propriétaire du certificat est de
       confiance</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crt</filename></entry>
      <entry>autorités de confiance</entry>
      <entry>vérifie que le certificat du serveur est signé par une autorité
       de confiance</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crl</filename></entry>
      <entry>certificats révoqués par les autorités de confiance</entry>
      <entry>le certificat du serveur ne doit pas être sur cette liste</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
  <title>Initialisation de la bibliothèque SSL</title>

  <para>
   Si votre application initialise les bibliothèques <literal>libssl</literal>
   et/ou <literal>libcrypto</literal> et que <application>libpq</application>
   est construit avec le support de <acronym>SSL</acronym>, vous devez appeler
   la fonction <xref linkend="libpq-PQinitOpenSSL"/> pour indiquer à
   <application>libpq</application> que les bibliothèques
   <literal>libssl</literal> et/ou <literal>libcrypto</literal> ont été
   initialisées par votre application, de façon à ce que
   <application>libpq</application> n'initialise pas elle aussi ces
   bibliothèques.
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-PQinitOpenSSL">
     <term><function>PQinitOpenSSL</function><indexterm><primary>PQinitOpenSSL</primary></indexterm></term>

     <listitem>
      <para>
       Permet aux applications de sélectionner les bibliothèques de sécurité
       à initialiser.
       <synopsis>
         void PQinitOpenSSL(int do_ssl, int do_crypto);
       </synopsis>
      </para>

      <para>
       Quand <parameter>do_ssl</parameter> est différent de zéro,
       <application>libpq</application> initialisera la bibliothèque
       <application>OpenSSL</application> avant d'ouvrir une connexion à la base
       de données. Quand <parameter>do_crypto</parameter> est différent de
       zéro, la bibliothèque <literal>libcrypto</literal> sera initialisée. Par
       défaut (si <xref linkend="libpq-PQinitOpenSSL"/> n'est pas appelé), les deux
       bibliothèques sont initialisées. Quand le support de SSL n'est pas
       intégré, cette fonction est présente mais ne fait rien.
      </para>

      <para>
       Si votre application utilise et initialise soit
       <application>OpenSSL</application> soit <literal>libcrypto</literal>,
       vous <emphasis>devez</emphasis> appeler cette fonction avec des zéros
       pour les paramètres appropriés avant d'ouvrir la première connexion à la
       base de données. De plus, assurez-vous que vous avez fait cette
       initialisation avant d'ouvrir une connexion à la base de données.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQinitSSL">
     <term><function>PQinitSSL</function><indexterm><primary>PQinitSSL</primary></indexterm></term>

     <listitem>
      <para>
       Permet aux applications de sélectionner les bibliothèques de sécurité
       à initialiser.
       <synopsis>
         void PQinitSSL(int do_ssl);
       </synopsis>
      </para>

      <para>
       Cette fonction est équivalente à
       <literal>PQinitOpenSSL(do_ssl, do_ssl)</literal>. C'est suffisant pour les
       applications qui initialisent à la fois <application>OpenSSL</application>
       et<literal>libcrypto</literal> ou aucune des deux.
      </para>

      <para>
       <xref linkend="libpq-PQinitSSL"/> est présente depuis
       <productname>PostgreSQL</productname> 8.0, alors que
       <xref linkend="libpq-PQinitOpenSSL"/> a été ajoutée dans
       <productname>PostgreSQL</productname> 8.4, donc
       <xref linkend="libpq-PQinitSSL"/> peut être préférée pour les applications
       qui ont besoin de fonctionner avec les anciennes versions de
       <application>libpq</application>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

</sect1>

<sect1 id="libpq-threading">
 <title>Comportement des programmes threadés</title>

 <indexterm zone="libpq-threading">
  <primary>threads</primary>
  <secondary>avec libpq</secondary>
 </indexterm>

 <para>
  <application>libpq</application> est réentrante et compatible avec les threads par
  défaut. Vous pourriez avoir besoin d'utiliser des options de
  compilation supplémentaires en ligne lorsque vous compilez le code de votre
  application. Référez-vous à la documentation de votre système pour savoir
  comment construire des applications avec threads ou recherchez
  <literal>PTHREAD_CFLAGS</literal> et <literal>PTHREAD_LIBS</literal> dans
  <filename>src/Makefile.global</filename>. Cette fonction permet d'interroger
  le statut de compatibilité de <application>libpq</application> avec les
  threads&nbsp;:
 </para>

 <variablelist>
  <varlistentry id="libpq-PQisthreadsafe">
   <term><function>PQisthreadsafe</function><indexterm><primary>PQisthreadsafe</primary></indexterm></term>
   <listitem>
    <para>
     Renvoie le statut de compatibilité avec les threads pour <application>libpq</application>
     library.
     <synopsis>
      int PQisthreadsafe();
     </synopsis>
    </para>

    <para>
     Renvoie 1 si <application>libpq</application> supporte les threads,
     0 dans le cas contraire.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

 <para>
  Une restriction&nbsp;: il ne doit pas y avoir deux threads
  manipulant le même objet <structname>PGconn</structname> à la fois. En particulier, vous
  ne pouvez pas lancer des commandes concurrentes depuis des threads
  différents à travers le même objet de connexion (si vous avez besoin de lancer des
  commandes concurrentes, utilisez plusieurs connexions).
 </para>

 <para>
  Les objets <structname>PGresult</structname> sont normalement en lecture seule
  après leur création et, du coup, peuvent être passés librement entre les
  threads. Néanmoins, si vous utilisez une des fonctions
  décrites dans <xref linkend="libpq-misc"/> ou <xref linkend="libpq-events"/>
  qui modifient <structname>PGresult</structname>, il est de votre responsabilité
  d'éviter des opérations concurrentes sur le même
  <structname>PGresult</structname>.
 </para>

 <para>
  Les fonctions obsolètes
  <xref linkend="libpq-PQrequestCancel"/> et
  <xref linkend="libpq-PQoidStatus"/>
  ne gèrent pas les threads et ne devraient pas être utilisées dans des programmes multithreads. <xref linkend="libpq-PQrequestCancel"/> peut être
  remplacé par <xref linkend="libpq-PQcancel"/>.
  <xref linkend="libpq-PQoidStatus"/> peut être remplacé par
  <xref linkend="libpq-PQoidValue"/>.
 </para>

 <para>
  Si vous utilisez Kerberos avec votre application (en plus de
  <application>libpq</application>), vous aurez besoin de verrouiller les appels
  Kerberos car les fonctions Kerberos ne supportent pas les threads.
  Voir la fonction <function>PQregisterThreadLock</function>
  dans le code source de <application>libpq</application> sur comment
  faire un verrouillage coopératif entre <application>libpq</application> et
  votre application.
 </para>

 <para>
  Si vous rencontrez des problèmes avec les applications utilisant des threads,
  lancez le programme dans <filename>src/tools/thread</filename> pour voir si votre
  plateforme possède des fonctions incompatibles avec les threads. Ce programme
  est lancé par <filename>configure</filename> mais, dans le cas des
  distributions binaires, votre bibliothèque peut ne pas correspondre à
  la bibliothèque utilisée pour construire les binaires.
 </para>
</sect1>


<sect1 id="libpq-build">
 <title>Construire des applications avec
  <application>libpq</application></title>

 <indexterm zone="libpq-build">
  <primary>compilation</primary>
  <secondary>applications libpq</secondary>
 </indexterm>

 <para>
  Pour construire (c'est-à-dire compiler et lier) un programme utilisant
  <application>libpq</application>, vous avez besoin de faire tout ce qui
  suit&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Ajoutez le fichier d'en-tête <filename>libpq-fe.h</filename>&nbsp;:
     <programlisting>#include &lt;libpq-fe.h&gt;
     </programlisting>
     Si vous ne le faites pas, alors vous obtiendrez normalement des messages
     d'erreurs similaires à&nbsp;:
     <screen>foo.c: In function `main':
       foo.c:34: `PGconn' undeclared (first use in this function)
       foo.c:35: `PGresult' undeclared (first use in this function)
       foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
       foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
       foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
     </screen>
    </para>
   </listitem>

   <listitem>
    <para>
     Faites pointer votre compilateur sur le répertoire où les fichiers d'en-tête
     de <productname>PostgreSQL</productname> ont été installés, en lui
     fournissant l'option <literal>-I<replaceable>répertoire</replaceable>
     </literal> (dans certains cas, le compilateur cherchera dans le
     répertoire en question par défaut, donc vous pouvez omettre cette
     option). Par exemple, votre ligne de commande de compilation devrait
     ressembler à ceci&nbsp;:
     <programlisting>cc -c -I/usr/local/pgsql/include testprog.c
     </programlisting>
     Si vous utilisez des makefiles, alors ajoutez cette option à la variable
     <varname>CPPFLAGS</varname>&nbsp;:
     <programlisting>CPPFLAGS += -I/usr/local/pgsql/include
     </programlisting>
    </para>

    <para>
     S'il y a une chance que votre programme soit compilé par
     d'autres utilisateurs, alors vous ne devriez pas coder en dur
     l'emplacement du répertoire. À la place, vous pouvez exécuter l'outil
     <command>pg_config</command><indexterm><primary>pg_config</primary><secondary
      sortas="libpq">avec libpq</secondary></indexterm> pour trouver
      où sont placés les fichiers d'en-tête sur le système local&nbsp;:
     <screen><prompt>$</prompt> pg_config --includedir
      <computeroutput>/usr/local/include</computeroutput>
     </screen>
    </para>

    <para>
     Si vous avez installé <command>pkg-config</command>
     <indexterm><primary>pkg-config</primary><secondary sortas="libpq">avec
       libpq</secondary></indexterm>, vous pouvez lancer à la place&nbsp;:
     <screen>
       <prompt>$</prompt> pkg-config --cflags libpq
       <computeroutput>-I/usr/local/include</computeroutput>
     </screen>
     Notez que l'option <option>-I</option> sera déjà précisée au début du chemin.
    </para>

    <para>
     Une erreur dans la spécification de la bonne option au compilateur
     résultera en un message d'erreur tel que
     <screen>testlibpq.c:8:22: libpq-fe.h: No such file or directory
     </screen>
    </para>
   </listitem>

   <listitem>
    <para>
     Lors de l'édition des liens du programme final, spécifiez l'option
     <literal>-lpq</literal> de façon à ce que
     les bibliothèques <application>libpq</application> soient intégrées, ainsi
     que l'option <literal>-L<replaceable>répertoire</replaceable></literal>
     pour faire pointer le compilateur vers le répertoire où les bibliothèques
     <application>libpq</application> résident. (Là encore le compilateur
     cherchera certains répertoires par défaut). Pour une portabilité maximale,
     placez l'option <option>-L</option> avant l'option <option>-lpq</option>.
     Par exemple&nbsp;:
     <programlisting>cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
     </programlisting>
    </para>

    <para>
     Vous pouvez aussi récupérer le répertoire des bibliothèques en utilisant
     <command>pg_config</command>&nbsp;:
     <screen><prompt>$</prompt> pg_config --libdir
       <computeroutput>/usr/local/pgsql/lib</computeroutput>
     </screen>
    </para>

    <para>
     Ou utiliser de nouveau <command>pkg-config</command>&nbsp;:
     <screen>
       <prompt>$</prompt> pkg-config --libs libpq
       <computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
     </screen>
     Notez aussi que cela affiche les options complètes, pas seulement le
     chemin.
    </para>

    <para>
     Les messages d'erreurs liés à des problèmes de ce style
     pourraient ressembler à ce qui suit.
     <screen>testlibpq.o: In function `main':
       testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
       testlibpq.o(.text+0x71): undefined reference to `PQstatus'
       testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
     </screen>
     Ceci signifie que vous avez oublié <option>-lpq</option>.
     <screen>/usr/bin/ld: cannot find -lpq
     </screen>
     Ceci signifie que vous avez oublié l'option <option>-L</option> ou que
     vous n'avez pas indiqué le bon répertoire.
    </para>
   </listitem>
  </itemizedlist>
 </para>

</sect1>


<sect1 id="libpq-example">
 <title>Exemples de programmes</title>

 <para>
  Ces exemples (et d'autres) sont disponibles dans le répertoire
  <filename>src/test/examples</filename> de la distribution des sources.
 </para>

 <example id="libpq-example-1">
  <title>Premier exemple de programme pour
   <application>libpq</application></title>

  <programlisting><![CDATA[/*
 * src/test/examples/testlibpq.c
 *
 *
 * testlibpq.c
 *
 *      Teste la version C de libpq, la bibliothèque frontend de PostgreSQL.
 */
#include <stdio.h>
#include <stdlib.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * Si l'utilisateur fournit un paramètre sur la ligne de commande,
     * l'utiliser comme une chaîne conninfo ; sinon prendre par défaut
     * dbname=postgres et utiliser les variables d'environnement ou les
     * valeurs par défaut pour tous les autres paramètres de connexion.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Crée une connexion à la base de données */
    conn = PQconnectdb(conninfo);

    /* Vérifier que la connexion au backend a été faite avec succès */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /* Initialise un search path sûr, pour qu'un utilisateur
       malveillant ne puisse prendre le contrôle. */
    res = PQexec(conn,
                 "SELECT pg_catalog.set_config('search_path', '', false)");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
    * Il faut libérer PGresult avec PQclear dès que l'on en a plus besoin pour
    * éviter les fuites de mémoire.
    */
    PQclear(res);

    /*
     * Notre exemple inclut un curseur, pour lequel il faut que nous soyons dans
     * un bloc de transaction. On pourrait tout faire dans un seul PQexec()
     * d'un "select * from pg_database" mais c'est trop trivial pour faire
     * un bon exemple.
     */

    /* Démarre un bloc de transaction */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    /*
     * Récupère les lignes de pg_database, catalogue système des bases de
     * données
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* affiche d'abord les noms des attributs */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* puis affiche les lignes */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* ferme le portail... nous ne cherchons pas s'il y a des erreurs... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* termine la transaction */
    res = PQexec(conn, "END");
    PQclear(res);

    /* ferme la connexion à la base et nettoie */
    PQfinish(conn);

    return 0;
}
]]></programlisting>
  </example>

  <example id="libpq-example-2">
   <title>Deuxième exemple de programme pour
    <application>libpq</application></title>

<programlisting><![CDATA[/*
 * src/test/examples/testlibpq2.c
 *
 *
 * testlibpq2.c
 *      Teste l'interface de notification asynchrone
 *
 * Démarrez ce programme, puis depuis psql dans une autre fenêtre faites
 *   NOTIFY TBL2;
 * Répétez quatre fois pour terminer ce programme.
 *
 * Ou, si vous voulez vous faire plaisir, faites ceci :
 * remplissez une base avec les commandes suivantes
 * (issues de src/test/examples/testlibpq2.sql):
 *
 *   CREATE SCHEMA TESTLIBPQ2;
 *   SET search_path = TESTLIBPQ2;
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * Démarrez ce programme, puis depuis psql faites quatre fois :
 *
 *   INSERT INTO TESTLIBPQ2.TBL1 VALUES (10);
 */

#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * Si l'utilisateur fournit un paramètre sur la ligne de commande,
     * l'utiliser comme une chaîne conninfo ; sinon prendre par défaut
     * dbname=postgres et utiliser les variables d'environnement ou les
     * pour tous les autres paramètres de connection.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Se connecte à la base */
    conn = PQconnectdb(conninfo);

    /* Vérifier que la connexion au backend a été faite avec succès */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /* Initialise un search path sûr, pour qu'un utilisateur
       malveillant ne puisse prendre le contrôle. */
    res = PQexec(conn,
                 "SELECT pg_catalog.set_config('search_path', '', false)");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
    * Il faut libérer PGresult avec PQclear dès que l'on en a plus besoin pour
    * éviter les fuites de mémoire.
    */
    PQclear(res);

    /*
     * Lance une commande LISTEN pour démarrer des notifications depuis le
     * NOTIFY.
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    PQclear(res);

    /* Quitte après avoir reçu quatre notifications. */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * Dort jusqu'à ce que quelque chose arrive sur la connexion. Nous
         * utilisons select(2) pour attendre une entrée, mais vous pouvez
         * utiliser poll() ou des fonctions similaires.
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* ne devrait pas arriver */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* Cherche une entrée */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
            PQconsumeInput(conn);
        }
    }

    fprintf(stderr, "Done.\n");

    /* ferme la connexion à la base et nettoie */
    PQfinish(conn);

    return 0;
}
]]></programlisting>
  </example>

  <example id="libpq-example-3">
   <title>Troisième exemple de programme pour
    <application>libpq</application></title>

<programlisting><![CDATA[/*
 * src/test/examples/testlibpq3.c
 *
 *
 * testlibpq3.c
 *      Teste des paramètres délicats et des entrées-sorties binaires.
 *
 * Avant de lancer ceci, remplissez une base avec les commandes suivantes
 * (fournies dans src/test/examples/testlibpq3.sql):
 *
 * CREATE SCHEMA testlibpq3;
 * SET search_path = testlibpq3;
 * SET standard_conforming_strings = ON;
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\000\001\002\003\004');
 * INSERT INTO test1 values (2, 'ho there', '\004\003\002\001\000');
 *
 * La sortie attendue est :
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */

#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * Cette fonction affiche un résultat qui est la récupération
 * au format binaire d'une table définie dans le commentaire ci-dessus.
 * Nous l'avons extraite car la fonction main() l'utilise deux fois.
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /*
     * Utilise PQfnumber pour éviter de deviner l'ordre des champs
     * dans le résultat
     */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /*
         * Récupère les valeurs des champs
         * (on ignore la possibilité qu'ils soient NULL !)
         */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * La représentation binaire d'INT4 est dans l'ordre d'octets
         * du réseau (network byte order), qu'il vaut mieux forcer à
         * l'ordre local.
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * La représentation binaire de TEXT est, hé bien, du texte,
         * et puisque libpq a été assez sympa pour rajouter un octet zéro,
         * cela marchera très bien en tant que chaîne C.
         *
         * La représentation binaire de BYTEA est un paquet d'octets,
         * pouvant incorporer des nulls, donc nous devons faire attention à
         * la longueur des champs.
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * Si l'utilisateur fournit un paramètre sur la ligne de commande,
     * l'utiliser comme une chaîne conninfo ; sinon prendre par défaut
     * dbname=postgres et utiliser les variables d'environnement ou les
     * valeurs par défaut pour tous les autres paramètres de connexion.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Crée une connexion à la base */
    conn = PQconnectdb(conninfo);

    /* Vérifie que la connexion à la base s'est bien déroulée */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
    * Il faut libérer PGresult avec PQclear dès que l'on en a plus besoin pour
    * éviter les fuites de mémoire.
    */
    res = PQexec(conn, "SET search_path = testlibpq3");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    /*
     * Le sujet de ce programme est d'illustrer l'utilisation de PQexecParams()
     * avec des paramètres délicats aussi bien que la transmission de
     * données binaires.
     *
     * Ce premier exemple transmet les paramètres en tant que texte, mais
     * reçoit les résultats en format binaire. Avec des paramètres
     * un peu délicats il n'y a pas besoin de nettoyage fastidieux en
     * terme de guillemets et d'échappement, même si les données sont du
     * texte. Notez que nous ne faisons rien de spécial avec les guillemets
     * dans la valeur du paramètre.
     */

    /* Voici notre paramètre délicat */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* un paramètre */
                       NULL,    /* laissons le backend déduire le type */
                       paramValues,
                       NULL,    /* pas besoin de la longueur des paramètres,
                                   c'est du texte */
                       NULL,    /* par défaut tous les paramètres sont du texte */
                       1);      /* demande le résultat en binaire */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * Dans ce second exemple, on transmet un paramètre entier sous
     * forme binaire, et on récupère à nouveau les paramètres sous forme
     * binaire.
     *
     * Bien que nous disions à PQexecParams que nous laissons le backend
     * déduire le type du paramètre, nous forçons la décision en convertissant
     * le symbole du paramètre dans le texte de la requête. C'est une bonne
     * précaution quand on envoie des paramètres binaires.
     */

    /* Convertit l'entier "2" dans l'ordre d'octets du réseau */
    binaryIntVal = htonl((uint32_t) 2);

    /* Met en place les tableaux de paramètres pour PQexecParams */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* un paramètre */
                       NULL,    /* laissons le backend déduire le type
                                   du paramètre */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* demande des résultats binaires */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* ferme la connexion et nettoie */
    PQfinish(conn);

    return 0;
}
]]></programlisting>
  </example>

 </sect1>
</chapter>
