<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="datatype-json">
 <title>Types <acronym>JSON</acronym></title>

 <indexterm zone="datatype-json">
  <primary>JSON</primary>
 </indexterm>

 <indexterm zone="datatype-json">
  <primary>JSONB</primary>
 </indexterm>

 <para>
  Les types de données JSON sont faits pour stocker des données JSON (JavaScript
  Object Notation), comme spécifié dans la <ulink
  url="https://tools.ietf.org/html/rfc7159">RFC 7159</ulink>. De telles données
  peuvent également être stockées comme <type>text </type>, mais les types de
  données JSON ont l'avantage d'assurer que chaque valeur stockée est valide
  d'après les règles JSON. Il y a également des fonctions et opérateurs
  spécifiques à JSON associés disponibles pour les données stockées dans ces
  types de données. Voir <xref linkend="functions-json"/>.
 </para>

 <para>
  <productname>PostgreSQL</productname> propose deux types de données pour stocker des
  données JSON : <type>json</type> et <type>jsonb</type>.
  Pour implémenter des mécanismes de requêtage efficaces pour ces types de
  données, <productname>PostgreSQL</productname> propose aussi le type
  <type>jsonpath</type> décrit dans <xref linkend="datatype-jsonpath"/>.
 </para>

 <para>
  Les types de données <type>json</type> et <type>jsonb</type>
  acceptent <emphasis>quasiment</emphasis> des ensembles de valeurs
  identiques en entrée.  La différence majeure réside dans
  l'efficacité.  Le type de données <type>json</type> stocke une copie exacte
  du texte en entrée, que chaque fonction doit analyser à chaque exécution,
  alors que le type de données <type>jsonb</type> est stocké dans un format
  binaire décomposé qui rend l'insertion légèrement plus lente du fait du
  surcoût de la conversion, mais est significativement plus rapide pour traiter
  les données, puisqu'aucune analyse n'est nécessaire.  <type>jsonb</type> gère
  également l'indexation, ce qui peut être un avantage significatif.
 </para>

 <para>
  Puisque le type <type>json</type> stocke une copie exacte du texte en entrée,
  il conservera les espaces sémantiquement non significatifs entre les jetons,
  ainsi que l'ordre des clés au sein de l'objet JSON.  De plus, si un objet
  JSON contient dans sa valeur la même clé plus d'une fois, toutes les paires
  clé/valeur sont conservées (les fonctions de traitement considèrent la
  dernière valeur comme celle significative).  À l'inverse, <type>jsonb</type>
  ne conserve ni les espaces non significatifs, ni l'ordre des clés d'objet, ni
  ne conserve les clés d'objet dupliquées.  Si des clés dupliquées sont
  présentées en entrée, seule la dernière valeur est conservée.
 </para>

 <para>
  En général, la plupart des applications devraient préférer stocker les données
  JSON avec <type>jsonb</type>, à moins qu'il y ait des besoins spécifiques,
  comme la supposition légitime de l'ordre des clés d'objet.
 </para>

 <para>
  La RFC 7159 spécifie que les chaînes JSON devraient être encodées en UTF8.
  Il n'est donc pas possible pour les types JSON de se conformer de manière
  rigoureuse à la spécification JSON, à moins que l'encodage de la base de
  données soit UTF8.  Tenter d'inclure directement des caractères qui ne
  peuvent pas être représentés dans l'encodage de la base de données
  échouera&nbsp;; inversement, des caractères qui peuvent être représentés
  dans l'encodage de la base de données, mais pas en UTF8, seront autorisés.
 </para>

 <para>
  La RFC 7159 autorise les chaînes JSON à contenir des séquences Unicode
  échappées, indiquées avec
  <literal>\u<replaceable>XXXX</replaceable></literal>. Dans la fonction
  d'entrée pour le type <type>json</type>, les échappements Unicode sont
  autorisés quel que soit l'encodage de la base de données, et sont vérifiés
  uniquement pour l'exactitude de la syntaxe (qui est quatre chiffres
  hexadécimaux précédés d'un <literal>\u</literal>).  Toutefois, la fonction
  d'entrée pour <type>jsonb</type> est plus stricte&nbsp;: elle interdit les
  échappements Unicode qui ne peuvent pas être représentés dans l'encodage de
  la base. Le type <type>jsonb</type> rejette aussi <literal>\u0000</literal>
  (parce qu'il ne peut pas être représenté avec le type <type>text</type> de
  <productname>PostgreSQL</productname>), et il insiste pour que chaque
  utilisation de paires de substitution Unicode désignant des caractères en
  dehors du <foreignphrase>Unicode Basic Multilingual Plane</foreignphrase>
  soit correcte. Les échappements Unicode valides sont convertis en leur
  caractère ASCII ou UTF8 équivalent pour du stockage&nbsp;; ceci inclut les
  <quote>folding surrogate pairs</quote> sur un seul caractère.
 </para>

 <note>
  <para>
   De nombreuses fonctions de traitement JSON décrites dans
   <xref linkend="functions-json"/> convertiront les échappements Unicode
   vers des caractères standards, et généreront donc le même type d'erreurs
   décrit juste avant si leur entrée est de type <type>json</type> et non
   <type>jsonb</type>. Le fait que la fonction d'entrée <type>json</type> ne
   fasse pas ces vérifications peut être considéré comme un artefact
   historique, bien qu'elle n'autorise pas un simple stockage (sans
   traitement) d'échappements Unicode JSON dans un encodage de base qui ne supporte pas les caractères représentés.
  </para>
 </note>

 <para>
  Lors de la conversion de données texte JSON vers <type>jsonb</type>, les
  types primitifs décrits par la <acronym>RFC</acronym> 7159 sont transcrits
  efficacement vers des types <productname>PostgreSQL</productname> natifs, comme
  indiqué dans <xref linkend="json-type-mapping-table"/>.  Par conséquent, il y
  a quelques contraintes additionnelles mineures sur ce qui constitue des
  données <type>jsonb</type> valides qui ne s'appliquent ni au type
  <type>json</type>, ni à JSON en définitive, correspondant aux limites de ce
  qui peut être représenté par le type de données sous-jacent. Spécifiquement,
  <type>jsonb</type> rejettera les nombres qui sont en dehors de la portée du
  type de données <type>numeric</type> de <productname>PostgreSQL</productname>,
  alors que <type>json</type> les acceptera. De telles restrictions définies
  par l'implémentation sont permises par la <acronym>RFC</acronym> 7159.
  Cependant, en pratique, de tels problèmes ont beaucoup plus de chances de se
  produire dans d'autres implémentations, puisqu'il est habituel de représenter
  les types primitifs <type>number</type> JSON comme des nombres flottants à
  double précision (IEEE 754 double precision floating point), ce que la
  <acronym>RFC</acronym> 7159 anticipe explicitement et autorise.  Lorsque JSON
  est utilisé comme format d'échange avec de tels systèmes, le risque de perte
  de précision pour les valeurs numériques comparées aux données stockées à
  l'origine par <productname>PostgreSQL</productname> devrait être considéré.
 </para>

 <para>
  À l'inverse, comme indiqué dans le tableau, il y a quelques restrictions
  mineures sur le format d'entrée de types primitifs JSON qui ne s'appliquent
  pas aux types <productname>PostgreSQL</productname> correspondants.
 </para>

 <table id="json-type-mapping-table">
  <title>Types primitifs JSON et types <productname>PostgreSQL</productname> correspondants</title>
  <tgroup cols="3">
   <colspec colname="col1" colwidth="1*"/>
   <colspec colname="col2" colwidth="1*"/>
   <colspec colname="col3" colwidth="2*"/>
   <thead>
    <row>
     <entry>Type primitif JSON</entry>
     <entry>Type <productname>PostgreSQL</productname></entry>
     <entry>Notes</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><type>string</type></entry>
     <entry><type>text</type></entry>
     <entry><literal>\u0000</literal> est interdit, comme le sont les
      échappements Unicode représentant des caractères non disponibles dans
      l'encodage de la base</entry>
    </row>
    <row>
     <entry><type>number</type></entry>
     <entry><type>numeric</type></entry>
     <entry>Les valeurs <literal>NaN</literal> et <literal>infinity</literal> sont interdites</entry>
    </row>
    <row>
     <entry><type>boolean</type></entry>
     <entry><type>boolean</type></entry>
     <entry>Seules les versions en minuscule de <literal>true</literal> et <literal>false</literal> sont acceptées</entry>
    </row>
    <row>
     <entry><type>null</type></entry>
     <entry>(none)</entry>
     <entry><literal>NULL</literal> dans SQL est un concept différent</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <sect2 id="json-keys-elements">
  <title>Syntaxe d'entrée et de sortie JSON</title>
  <para>
   La syntaxe d'entrée/sortie pour les types de données JSON est identique à celle spécifiée
   dans la <acronym>RFC</acronym> 7159.
  </para>
  <para>
   Les exemples suivants sont tous des expressions <type>json</type> (ou <type>jsonb</type>)
   valides&nbsp;:
   <programlisting>
-- Simple valeur scalaire/primitive
-- Les valeurs primitives peuvent être des nombres, chaînes entre guillemets, true, false ou null
SELECT '5'::json;

-- Tableau de zéro ou plus éléments (les éléments doivent être du même type)
SELECT '[1, 2, "foo", null]'::json;

-- Objets contenant des paires de clé et valeurs
-- À noter que les clés d'objets doivent toujours être des chaînes entre guillemets
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- Tableaux et objets peuvent être imbriqués arbitrairement
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
   </programlisting>
  </para>

  <para>
   Comme dit précédemment, quand une valeur JSON est renseignée puis affichée
   sans traitement additionnel, <type>json</type> renvoie le même texte qui
   était fourni en entrée, alors que <type>jsonb</type> ne préserve pas les
   détails sémantiquement non significatifs comme les espaces.
   Par exemple, il faut noter la différence ici&nbsp;:
   <programlisting>
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
   </programlisting>
   un détail sémantiquement non significatif qu'il faut souligner est qu'avec
   <type>jsonb</type>, les nombres seront affichés en fonction du type
   <type>numeric</type> sous-jacent. En pratique, cela signifie que les nombres
   renseignés avec la notation <literal>E</literal> seront affichés sans. Par
   exemple&nbsp;:
   <programlisting>
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
   </programlisting>
   Toutefois, <type>jsonb</type> préservera les zéros en fin de partie
   fractionnaire, comme on peut le voir dans cet exemple, même si ceux-ci
   ne sont pas sémantiquement significatifs, pour des besoins tels que des tests
   d'égalité.
  </para>

  <para>
   Pour la liste de fonctions et opérateurs intégrés disponibles pour construire
   et traiter des valeurs JSON, voir <xref linkend="functions-json"/>.
  </para>
 </sect2>

 <sect2 id="json-doc-design">
  <title>Concevoir des documents JSON efficacement</title>
  <para>
   Représenter des données en JSON peut être considérablement plus flexible que
   le modèle de données relationnel traditionnel, qui est contraignant dans des
   environnements où les exigences sont souples.  Il est tout à fait possible
   que ces deux approches puissent coexister, et qu'elles soient complémentaires
   au sein de la même application. Toutefois, même pour les applications où on
   désire le maximum de flexibilité, il est toujours recommandé que les
   documents JSON aient une structure quelque peu fixée. La structure est
   typiquement non vérifiée (bien que vérifier des règles métier de manière
   déclarative soit possible), mais le fait d'avoir une
   structure prévisible rend plus facile l'écriture de requêtes qui résument
   utilement un ensemble de <quote>documents</quote> (datums) dans une table.
  </para>
  <para>
   Les données JSON sont sujettes aux mêmes considérations de contrôle de
   concurrence que pour n'importe quel autre type de données quand elles sont
   stockées en table. Même si stocker de gros documents est prévisible, il faut
   garder à l'esprit que chaque mise à jour acquiert un verrou de niveau ligne
   sur toute la ligne.  Il faut envisager de limiter les documents JSON à une
   taille gérable pour réduire les contentions sur verrou lors des transactions
   en mise à jour. Idéalement, les documents JSON devraient chacun représenter
   une donnée atomique, que les règles métiers imposent de ne pas pouvoir
   subdiviser en données plus petites qui pourraient être modifiées
   séparément.
  </para>
 </sect2>

 <sect2 id="json-containment">
  <title>Existence et inclusion <type>jsonb</type></title>
  <indexterm>
   <primary>jsonb</primary>
   <secondary>inclusion</secondary>
  </indexterm>
  <indexterm>
   <primary>jsonb</primary>
   <secondary>existence</secondary>
  </indexterm>
  <para>
   Tester l'<firstterm>inclusion</firstterm> est une capacité importante de
   <type>jsonb</type>. Il n'y a pas d'ensemble de fonctionnalités parallèles
   pour le type <type>json</type>.  L'inclusion teste si un des documents
   <type>jsonb</type> est contenu dans un autre.  Ces exemples renvoient vrai,
   sauf note explicite&nbsp;:
  </para>
  <programlisting><![CDATA[
-- Simple valeur scalaire/primitive qui contient une seule valeur identique :
SELECT '"foo"'::jsonb @> '"foo"'::jsonb;

-- Le tableau de droite est contenu dans celui de gauche :
SELECT '[1, 2, 3]'::jsonb @> '[1, 3]'::jsonb;

-- L'ordre des éléments d'un tableau n'est pas significatif, donc ceci est tout
-- aussi vrai :
SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;

-- Les éléments dupliqués d'un tableau n'ont pas plus d'importance :
SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;

-- L'objet avec une seule paire à droite est contenu
-- dans l'objet sur le côté gauche :
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb":true}'::jsonb @> '{"version":9.4}'::jsonb;

-- Le tableau du côté droit n'est <emphasis>pas</emphasis> considéré comme contenu
-- dans le tableau du côté gauche, même si un tableau similaire est imbriqué dedans :
SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb;  -- renvoie faux

-- Mais avec une couche d'imbrication, il est contenu :
SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;

-- De la même manière, l'inclusion n'est pas valable ici :
SELECT '{"foo": {"bar": "baz"}}'::jsonb @> '{"bar": "baz"}'::jsonb;  -- renvoie faux

-- Une clé du niveau racine et un objet vide sont contenus :
SELECT '{"foo": {"bar": "baz"}}'::jsonb @> '{"foo": {}}'::jsonb;
  ]]></programlisting>

  <para>
   Le principe général est que l'objet inclus doit correspondre à l'objet devant
   le contenir à la fois pour la structure et pour les données, peut-être après
   la suppression d'éléments de tableau ou d'objets paires clé/valeur ne
   correspondant pas à l'objet contenant. Mais rappelez-vous que l'ordre des
   éléments dans un tableau n'est pas significatif lors d'une recherche de
   contenance, et que les éléments dupliqués d'un tableau ne sont réellement
   considérés qu'une seule fois.
  </para>

  <para>
   Comme exception qui confirme la règle que les structures doivent
   correspondre, un tableau peut inclure une valeur primitive&nbsp;:
  </para>
  <programlisting><![CDATA[
-- Ce tableau inclut la valeur primitive chaîne :
SELECT '["foo", "bar"]'::jsonb @> '"bar"'::jsonb;

-- Cette exception n'est pas réciproque, la non-inclusion est rapportée ici :
SELECT '"bar"'::jsonb @> '["bar"]'::jsonb;  -- renvoie faux
  ]]></programlisting>

  <para>
   <type>jsonb</type> a également un opérateur d'<firstterm>existence</firstterm>,
   qui est une variation sur le thème de l'inclusion&nbsp;: il teste si une
   chaîne (sous forme de valeur <type>text</type>) apparaît comme une clé
   d'objet ou un élément de tableau au niveau supérieur de la valeur
   <type>jsonb</type>. Ces exemples renvoient vrai; sauf note explicite&nbsp;:
  </para>
  <programlisting>
-- La chaîne existe comme un élément de tableau :
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-- La chaîne existe comme une clé d'objet :
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-- Les valeurs d'objets ne sont pas examinées :
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- renvoie faux

-- Comme pour l'inclusion, l'existence doit correspondre au niveau supérieur :
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- renvoie faux

-- Une chaîne est examinée pour l'existence si elle correspond à une primitive chaîne JSON&nbsp;:
SELECT '"foo"'::jsonb ? 'foo';
  </programlisting>

  <para>
   Les objets JSON sont plus adaptés que les tableaux pour tester l'inclusion ou
   l'existence quand il y a de nombreux éléments ou clés impliqués, car
   contrairement aux tableaux, ils sont optimisés de manière interne pour la
   recherche et n'ont pas besoin d'être parcourus linéairement.
  </para>

  <tip>
   <para>
    Comme les documents JSON sont imbriqués, une requête appropriée peut
    ignorer une sélection explicite de sous-objets. Par exemple, supposons que
    nous ayons une colonne <structfield>doc</structfield> contenant des objets
    au plus haut niveau, avec la plupart des objets contenant les champs
    <literal>tags</literal> qui contiennent eux-mêmes des tableaux de sous-objets. Cette
    requête trouve des entrées dans lesquelles les sous-objets contiennent à
    la fois <literal>"term":"paris"</literal> et
    <literal>"term":"food"</literal>, tout en ignorant ces clés en dehors du
    tableau <literal>tags</literal>&nbsp;:
    <programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';
    </programlisting>
    Cela pourrait s'accomplir aussi ainsi&nbsp;:
    <programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';
    </programlisting>
    mais cette approche est moins flexible, et souvent bien moins efficace.
   </para>

   <para>
    Mais l'opérateur JSON d'existence n'est pas imbriqué&nbsp;: il
    cherchera seulement pour la clé ou l'élément de tableau spécifié à la
    racine de la valeur JSON.
   </para>
  </tip>

  <para>
   Les différents opérateurs d'inclusion d'existence, avec tous les autres
   opérateurs et fonctions JSON, sont documentés dans
   <xref linkend="functions-json"/>.
  </para>
 </sect2>

 <sect2 id="json-indexing">
  <title>Indexation <type>jsonb</type></title>
  <indexterm>
   <primary>jsonb</primary>
   <secondary>index</secondary>
  </indexterm>

  <para>
   Les index GIN peuvent être utilisés pour chercher efficacement des clés ou des
   paires clé/valeur se trouvant parmi un grand nombre de documents (datums)
   <type>jsonb</type>.  Deux <quote>classes d'opérateurs</quote> GIN sont
   fournies, offrant différents compromis entre performances et flexibilité.
  </para>
  <para>
   La classe d'opérateur GIN par défaut pour <type>jsonb</type> supporte les
   requêtes avec des opérateurs de haut niveau clé-existe <literal>?</literal>, <literal>?&amp;</literal>
   et des opérateurs <literal>?|</literal> et l'opérateur path/valeur-existe
   <literal>@&gt;</literal>.
   (Pour des détails sur la sémantique que ces opérateurs implémentent,
   voir <xref linkend="functions-jsonb-op-table"/>.)
   Un exemple de création d'index avec cette classe d'opérateurs est&nbsp;:
   <programlisting>
CREATE INDEX idxgin ON api USING GIN (jdoc);
   </programlisting>
   La classe d'opérateurs GIN qui n'est pas par défaut <literal>jsonb_path_ops
   </literal> supporte l'indexation de l'opérateur <literal>@&gt;</literal>
   seulement.  Un exemple de création d'index avec cette classe d'opérateurs est&nbsp;:
   <programlisting>
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
   </programlisting>
  </para>

  <para>
   En étudiant l'exemple d'une table qui stocke des documents JSON récupérés
   par un service web tiers, avec une définition de schéma documentée, un
   document typique serait&nbsp;:
   <programlisting>
{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}
   </programlisting>
   Ces documents sont stockés dans une table nommée <structname>api</structname>,
   dans une colonne de type <type>jsonb</type> nommée <structfield>jdoc</structfield>.
   Si un index GIN est créé sur cette colonne, des requêtes semblables à
   l'exemple suivant peuvent utiliser cet index&nbsp;:
   <programlisting>
-- Trouver les documents dans lesquels la clé "company" a pour valeur "Magnafone"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';
   </programlisting>
   Toutefois, cet index ne pourrait pas être utilisé pour des requêtes comme
   dans l'exemple suivant, car bien que l'opérateur <literal>?</literal> soit
   indexable, il n'est pas appliqué directement sur la colonne indexée
   <structfield>jdoc</structfield>&nbsp;:
   <programlisting>
-- Trouver les documents dans lesquels la clé "tags" contient une clé ou un élément tableau "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';
   </programlisting>
   Toutefois, avec l'utilisation appropriée d'index sur expression, la requête
   ci-dessus peut utiliser un index.  Si le requêtage d'éléments particuliers
   de la clé <literal>"tags"</literal> est fréquent, définir un index comme
   ceci pourrait être particulièrement bénéfique&nbsp;:
   <programlisting>
-- À noter que l'opérateur "jsonb -&gt; text" ne peut être appelé que sur un
-- objet JSON, donc la conséquence de créer cet index est que le premier niveau de
-- chaque valeur "jdoc" doit être un objet. Ceci est vérifié lors de chaque insertion.
CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));
   </programlisting>
   Dorénavant, la clause <literal>WHERE</literal>
   <literal>jdoc -&gt; 'tags' ? 'qui'</literal> sera reconnue comme une
   application de l'opérateur indexable <literal>?</literal> pour l'expression
   indexée <literal>jdoc -&gt; 'tags'</literal>.
   (Plus d'informations sur les index sur expression peuvent être
   trouvées dans <xref linkend="indexes-expressional"/>.)
  </para>
  <para>
   Les index GIN supportent aussi les opérateurs <literal>@@</literal>
   et <literal>@?</literal> qui réalisent la correspondance avec le
   <literal>jsonpath</literal>.
   <programlisting>
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @@ '$.tags[*] == "qui"';
   </programlisting>
   <programlisting>
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @@ '$.tags[*] ? (@ == "qui")';
   </programlisting>
   L'index GIN extrait les informations de la forme suivante du
   <literal>jsonpath</literal>&nbsp;: <replaceable>chaîne d'accès</replaceable> = <replaceable>const</replaceable>.
   La chaîne d'accès peut être <literal>.key</literal>,
   <literal>[*]</literal> et <literal>[<replaceable>index</replaceable>]</literal>.
   <literal>jsonb_ops</literal> supporte aussi les accesseurs <literal>.*</literal>
   et <literal>.**</literal>.
  </para>
  <para>
   Une autre approche pour le requêtage et l'exploitation de l'inclusion, par exemple&nbsp;:
   <programlisting>
-- Trouver les documents dans lesquels la clé "tags" inclut l'élément tableau "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';
   </programlisting>
   Un simple index GIN sur la colonne <structfield>jdoc</structfield> peut
   répondre à cette requête.  Mais il faut noter qu'un tel index stockera des
   copies de chaque clé et chaque valeur de la colonne
   <structfield>jdoc</structfield>, alors que l'index sur expression de
   l'exemple précédent ne stockera que les données trouvées pour la clé
   <literal>tags</literal>. Alors que l'approche d'index simple est bien plus
   souple (puisqu'elle supporte les requêtes sur n'importe quelle clé), les
   index sur des expressions ciblées ont bien plus de chances d'être plus petits
   et plus rapides pour la recherche qu'un simple index.
  </para>

  <para>
   Bien que la classe d'opérateur <literal>jsonb_path_ops</literal> ne supporte
   que les requêtes avec les opérateurs <literal>@&gt;</literal>, <literal>@@</literal>
   et <literal>@?</literal>, elle a des
   avantages de performances notables par rapport à la classe d'opérateur par
   défaut <literal>jsonb_ops</literal>.  Un index <literal>jsonb_path_ops</literal>
   est généralement bien plus petit qu'un index <literal>jsonb_ops</literal>
   pour les mêmes données, et la spécificité de la recherche est meilleure,
   particulièrement quand les requêtes contiennent des clés qui apparaissent
   fréquemment dans les données. Par conséquent, les opérations de recherche
   sont généralement plus performantes qu'avec la classe d'opérateur par défaut.
  </para>

  <para>
   La différence technique entre des index GIN <literal>jsonb_ops</literal> et
   <literal>jsonb_path_ops</literal> est que le premier crée des éléments
   d'index indépendants pour chaque clé et valeur dans les données, alors
   que le second crée des éléments d'index uniquement pour chaque valeur
   dans les données.
   <footnote>
    <para>
     Dans ce contexte, le terme <quote>valeur</quote> inclut les éléments de
     tableau, bien que la terminologie JSON considère parfois que les éléments
     de tableaux soient distincts des valeurs dans les objets.
    </para>
   </footnote>
   Fondamentalement, chaque élément d'index <literal>jsonb_path_ops</literal>
   est un hachage de la valeur et de la ou des clés y menant&nbsp;; par exemple pour
   indexer <literal>{"foo": {"bar": "baz"}}</literal>, un seul élément dans
   l'index sera créé, incorporant les trois <literal>foo</literal>, <literal>bar</literal>
   et <literal>baz</literal> dans une valeur hachée. Ainsi, une requête
   d'inclusion cherchant cette structure résulterait en une recherche d'index
   extrêmement spécifique, mais il n'y a pas d'autre moyen de savoir si
   <literal>foo</literal> apparaît en tant que clé.  D'un autre côté, un index
   <literal>jsonb_ops</literal> créerait trois éléments d'index représentant
   <literal>foo</literal>, <literal>bar</literal> et <literal>baz</literal>
   séparément&nbsp;; ainsi, pour faire la requête d'inclusion, il faudrait rechercher
   les lignes contenant chacun des trois éléments. Bien que les index GIN
   puissent effectuer de telles recherches et de manière tout à fait efficace,
   cela sera toujours moins spécifique et plus lent que la recherche
   équivalente <literal>jsonb_path_ops</literal>, surtout s'il y a un très
   grand nombre de lignes contenant n'importe lequel des trois éléments d'index.
  </para>

  <para>
   Un désavantage de l'approche <literal>jsonb_path_ops</literal> est qu'elle ne
   produit d'entrées d'index que pour les structures JSON ne contenant aucune
   valeur, comme <literal>{"a": {}}</literal>.  Si une recherche pour des
   documents contenant une telle structure est demandée, elle nécessitera un
   parcours de la totalité de l'index, ce qui peut être assez long.
   <literal>jsonb_path_ops</literal> est donc mal adapté pour des applications
   qui effectuent souvent de telles recherches.
  </para>

  <para>
   <type>jsonb</type> supporte également les index <literal>btree</literal> et
   <literal>hash</literal>. Ceux-ci ne sont généralement utiles que s'il est
   important de vérifier l'égalité de documents JSON entiers.
   Le tri <literal>btree</literal> pour des données <type>jsonb</type> est
   rarement d'un grand intérêt, mais afin d'être exhaustif, il est&nbsp;:
   <synopsis>
<replaceable>Objet</replaceable> > <replaceable>Tableau</replaceable> > <replaceable>Booléen</replaceable> > <replaceable>Nombre</replaceable> > <replaceable>Chaîne</replaceable> > <replaceable>Null</replaceable>

<replaceable>Objet avec n paires</replaceable> > <replaceable>objet avec n - 1 paires</replaceable>

<replaceable>Tableau avec n éléments</replaceable> > <replaceable>tableau avec n - 1 éléments</replaceable>
   </synopsis>
   Les objets avec le même nombre de paires sont comparés dans cet ordre&nbsp;:
   <synopsis>
<replaceable>clé-1</replaceable>, <replaceable>valeur-1</replaceable>, <replaceable>clé-2</replaceable> ...
   </synopsis>
   À noter que les clés d'objet sont comparées dans leur ordre de stockage&nbsp;;
   en particulier, puisque les clés les plus courtes sont stockées avant les
   clés les plus longues, cela peut amener à des résultats contre-intuitifs,
   tels que&nbsp;:
   <programlisting>
{ "aa": 1, "c": 1} > {"b": 1, "d": 1}
   </programlisting>
   De la même manière,  les tableaux avec le même nombre d'éléments sont
   comparés dans l'ordre&nbsp;:
   <synopsis>
<replaceable>élément-1</replaceable>, <replaceable>élément-2</replaceable> ...
   </synopsis>
   Les valeurs JSON primitives sont comparées en utilisant les mêmes règles
   de comparaison que pour les types de données
   <productname>PostgreSQL</productname> sous-jacents. Les chaînes sont
   comparées en utilisant la collation par défaut de la base de données.
  </para>
 </sect2>

 <sect2>
  <title>Transformations</title>

  <para>
   Des extensions supplémentaires sont disponibles pour implémenter des
   transformations pour le type <type>jsonb</type> pour différents langages de
   procédure stockée.
  </para>

  <para>
   Les extensions pour PL/Perl sont appelées <literal>jsonb_plperl</literal>
   et <literal>jsonb_plperlu</literal>. Si vous les utilisez, les valeurs
   <type>jsonb</type> sont transformées en tableaux, hachages et scalaires
   Perl, suivant le cas.
  </para>

  <para>
   Les extensions pour PL/Python sont appelées
   <literal>jsonb_plpythonu</literal>, <literal>jsonb_plpython2u</literal> et
   <literal>jsonb_plpython3u</literal> (voir <xref
   linkend="plpython-python23"/> pour la convention de nommage PL/Python). Si
   vous les utilisez, les valeurs <type>jsonb</type> sont transformées en
   dictionnaires, listes et scalaires Python, suivant le cas.
  </para>

  <para>
   Pour ces extensions, <literal>jsonb_plperl</literal> est considéré de
   confiance (<quote>trusted</quote>), autrement dit il peut être installé par
   des utilisateurs qui n'ont pas l'attribut <literal>SUPERUSER</literal> mais
   qui ont le droit <literal>CREATE</literal> sur la base actuelle. Le reste
   nécessite d'être superutilisateur pour être installé.
  </para>
 </sect2>

 <sect2 id="datatype-jsonpath">
  <title>Type jsonpath</title>

  <indexterm zone="datatype-jsonpath">
   <primary>jsonpath</primary>
  </indexterm>

  <para>
   Le type <type>jsonpath</type> implémente le support du langage
   SQL/JSONpath dans <productname>PostgreSQL</productname> de façon à requêter
   correctement dans les données JSON.
   Cela fournit une représentation binaire de l'expression SQL/JSONpath analysée
   qui spécifie les valeurs qui doivent être récupérées par le moteur de chemin
   depuis les données JSON pour être traités par la suite avec les fonctions
   de requêtage SQL/JSON.
  </para>

  <para>
   La sémantique des prédicats et opérateurs suit généralement celle du SQL.
   Dans le même temps, il propose une manière naturelle de travailler
   avec les données JSON. En effet, la syntaxe SQL/JSONpath utilise certaines
   conventions JavaScript&nbsp;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Le point (<literal>.</literal>) est utilisé pour accéder à une valeur.
    </para>
   </listitem>
   <listitem>
    <para>
     Les crochets (<literal>[]</literal>) sont utilisés pour accéder à un tableau.
    </para>
   </listitem>
   <listitem>
    <para>
     Les tableaux SQL/JSON commencent à partir de 0, contrairement aux tableaux SQL
     classiques qui commencent à 1.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Une expression de chemin SQL/JSON est typiquement écrite dans une requête
   SQL comme une constante chaîne de caractères SQL, donc elle doit être
   entourée par des guillemets simples, et tout guillemet simple souhaité dans
   la valeur doit être doublé (voir <xref linkend="sql-syntax-strings"/>).
   Certaines formes d'expressions de chemin requièrent des constantes de
   chaîne à l'intérieur. Ces constantes de chaînes intégrées suivent les
   conventions JavaScript/ECMAScript&nbsp;: elles doivent être entourées par
   des guillemets doubles et les échappements doivent être utilisées pour
   représenter les caractères difficiles à saisir. En particulier, la façon
   d'écrire un guillemet double dans une constante de type chaîne est
   <literal>\"</literal>, et pour écrire un antislash, vous devez écrire
   <literal>\\</literal>. Les autres séquences spéciales d'échappement
   incluent celles reconnues dans les chaînes JSON&nbsp;:
   <literal>\b</literal>, <literal>\f</literal>, <literal>\n</literal>,
   <literal>\r</literal>, <literal>\t</literal>, <literal>\v</literal> pour
   les différents caractères de contrôle ASCII, et
   <literal>\u<replaceable>NNNN</replaceable></literal> pur un caractère
   Unicode identifié par son code sur 4 chiffres hexadécimaux. La syntaxe
   antislash inclut aussi deux cas non autorisés par JSON&nbsp;:
   <literal>\x<replaceable>NN</replaceable></literal> pour un code caractère
   écrit avec deux chiffres hexadécimaux, et
   <literal>\u{<replaceable>N...</replaceable>}</literal> pour un code
   caractère écrit avec 1 à 6 chiffres hexadécimaux.
  </para>

  <para>
   Une expression path consiste en une séquence d'éléments path, qui peuvent
   être une des suivants&nbsp;:
   <itemizedlist>
    <listitem>
     <para>
      Path litéral de type primitifs JSON&nbsp;:
      texte Unicode, numeric, true, false, ou null.
     </para>
    </listitem>
    <listitem>
     <para>
      Variables Path listées dans <xref linkend="type-jsonpath-variables"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Opérateurs d'accès listés dans <xref linkend="type-jsonpath-accessors"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Opérateurs et méthodes <type>jsonpath</type> listés dans
      <xref linkend="functions-sqljson-path-operators"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Les parenthèses, qui peuvent être utilisées pour filtrer des expressions
      ou définir l'ordre d'évaluation des Path.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Pour plus de détails concernant l'utilisation des expressions <type>jsonpath</type>
   avec des fonctions de requête SQL/JSON, voir <xref linkend="functions-sqljson-path"/>.
  </para>

  <table id="type-jsonpath-variables">
   <title>Variables <type>jsonpath</type></title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Variable</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>$</literal></entry>
      <entry>Une variable qui représente le texte JSON en cours de traitement
       (l'<firstterm>élément de contexte</firstterm>).
      </entry>
     </row>
     <row>
      <entry><literal>$varname</literal></entry>
      <entry>
       Une variable nommée. Le paramètre <parameter>vars</parameter> présent dans
       de nombreuses fonctions de traitement JSON, permet de définir sa valeur.
       Voir <xref linkend="functions-json-processing-table"/>
       pour plus de détails.
       <!-- TODO: describe PASSING clause once implemented !-->
      </entry>
     </row>
     <row>
      <entry><literal>@</literal></entry>
      <entry>Une variable qui représente le résultat de l'évaluation du path dans
       un filtre.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="type-jsonpath-accessors">
   <title>Accesseurs <type>jsonpath</type></title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
     <row>
      <entry>Opérateurs d'accès</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        <literal>.<replaceable>clé</replaceable></literal>
       </para>
       <para>
        <literal>."$<replaceable>nom de variable</replaceable>"</literal>
       </para>
      </entry>
      <entry>
       <para>
        La valeur accédée renvoie un objet avec la clé spécifiée.
        Si le nom de la clé correspond à certaines variables nommées commençant avec
        <literal>$</literal> ou qui n'est pas compatible avec les règles
        JavaScript d'un identifiant, ce nom doit être entouré avec des guillemets
        double comme une chaîne de caractères.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>.*</literal>
       </para>
      </entry>
      <entry>
       <para>
        L'accès joker renvoie les valeurs de tous les membres
        se trouvant au plus haut niveau de l'objet courant.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>.**</literal>
       </para>
      </entry>
      <entry>
       <para>
        L'accès joker récursif traite tous les niveaux de
        l'arborescence JSON de l'objet courant, et retourne toutes
        les valeurs, peu importe leur niveau d'imbrication.
        Ceci est une extension <productname>PostgreSQL</productname>
        du standard SQL/JSON
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>.**{<replaceable>level</replaceable>}</literal>
       </para>
       <para>
        <literal>.**{<replaceable>start_level</replaceable> au
         <replaceable>end_level</replaceable>}</literal>
       </para>
      </entry>
      <entry>
       <para>
        Identique à <literal>.**</literal>, mais sélectionne seulement les
        niveaux indiqués de la hiérarchie JSON. Les niveaux d'imbrication sont
        spécifiés en entier. Le niveau zéro correspond à l'objet courant. Pour
        accèder au dernier niveau d'imbrication, vous pouvez utiliser le mot
        clé <literal>last</literal>. Ceci est une extension
        <productname>PostgreSQL</productname> du standard SQL/JSON.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>[<replaceable>subscript</replaceable>, ...]</literal>
       </para>
      </entry>
      <entry>
       <para>
        Accès aux valeurs d'un tableau.
        <literal><replaceable>subscript</replaceable></literal> peut être
        donné sous deux formes&nbsp;: <literal><replaceable>index</replaceable></literal>
        ou <literal><replaceable>start_index</replaceable> à
         <replaceable>end_index</replaceable></literal>.
        La première forme renvoie une simple valeur du tableau par son index. La
        seconde forme renvoie un morceau de tableau provenant d'un intervalle
        d'index, en incluant les valeurs qui correspondent à celles fournies dans
        <replaceable>start_index</replaceable> et <replaceable>end_index</replaceable>.
       </para>
       <para>
        L'<replaceable>index</replaceable> spécifié peut être un entier, aussi bien
        qu'une expression renvoyant une simple valeur numérique, qui sera automatiquement
        transtypé vers un entier. L'index zéro correspond à la première valeur d'un
        tableau. Vous pouvez aussi utiliser le mot clé <literal>last</literal> pour
        indiquer le dernier élément, ce qui est utile pour manipuler des tableaux
        de longueur inconnue.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>[*]</literal>
       </para>
      </entry>
      <entry>
       <para>
        L'accès joker tableau qui renvoie toutes les valeurs du tableau.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>
</sect1>
