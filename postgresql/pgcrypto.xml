<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="pgcrypto" xreflabel="pgcrypto">
 <title>pgcrypto</title>

 <indexterm zone="pgcrypto">
  <primary>pgcrypto</primary>
 </indexterm>

 <indexterm zone="pgcrypto">
  <primary>chiffrement</primary>
  <secondary>pour des colonnes spécifiques</secondary>
 </indexterm>

 <para>
  Le module <filename>pgcrypto</filename> propose des fonctions de
  cryptographie pour <productname>PostgreSQL</productname>.
 </para>

 <para>
  Ce module est considéré comme <quote>trusted</quote>, ce qui signifie qu'il
  peut être installé par des utilisateurs simples (sans attribut
  <literal>SUPERUSER</literal>) et qui ont l'attribut <literal>CREATE</literal>
  sur la base de données courante.
 </para>

 <sect2>
  <title>Fonctions de hachage généralistes</title>

  <sect3>
   <title><function>digest()</function></title>

   <indexterm>
    <primary>digest</primary>
   </indexterm>

   <synopsis>
    digest(data text, type text) returns bytea
    digest(data bytea, type text) returns bytea
   </synopsis>

   <para>
    Calcule un hachage binaire de <parameter>data</parameter>.
    <parameter>type</parameter> est l'algorithme utilisé. Les algorithmes
    standards sont <literal>md5</literal> et <literal>sha1</literal>. Si
    <filename>pgcrypto</filename> a été construit avec
    <productname>OpenSSL</productname>, d'autres algorithmes sont disponibles
    comme le détaille <xref linkend="pgcrypto-with-without-openssl"/>.
   </para>

   <para>
    Si vous voulez en résultat une chaîne hexadécimale, utilisez
    <function>encode()</function> sur le résultat. Par exemple&nbsp;:
   </para>
   <programlisting>
    CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
      SELECT encode(digest($1, 'sha1'), 'hex')
    $$ LANGUAGE SQL STRICT IMMUTABLE;
   </programlisting>
  </sect3>

  <sect3>
   <title><function>hmac()</function></title>

   <indexterm>
    <primary>hmac</primary>
   </indexterm>

   <synopsis>
    hmac(data text, key text, type text) returns bytea
    hmac(data bytea, key bytea, type text) returns bytea
   </synopsis>

   <para>
    Calcule un MAC haché sur <parameter>data</parameter> avec la clé
    <parameter>key</parameter>.
    <parameter>type</parameter> est identique à <function>digest()</function>.
   </para>

   <para>
    C'est similaire à <function>digest()</function> mais le hachage peut être
    recalculé en connaissant seulement la clé. Ceci évite le scénario où
    quelqu'un modifie les données et le hachage en même temps.
   </para>

   <para>
    Si la clé est plus grosse que le bloc haché, il sera tout d'abord haché
    puis le résultat sera utilisé comme clé.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>Fonctions de hachage de mot de passe</title>

  <para>
   Les fonctions <function>crypt()</function> et
   <function>gen_salt()</function> sont spécialement conçues pour hacher les
   mots de passe.
   <function>crypt()</function> s'occupe du hachage et
   <function>gen_salt()</function> prépare les paramètres de l'algorithme pour
   ça.
  </para>

  <para>
   Les algorithmes de <function>crypt()</function> diffèrent des algorithmes
   de hachage habituels comme MD5 ou SHA1&nbsp;:
  </para>

  <orderedlist>
   <listitem>
    <para>
     Ils sont lents. Comme la quantité de données est petite, c'est le seul
     moyen de rendre difficile la découverte par la force des mots de passe.
    </para>
   </listitem>
   <listitem>
    <para>
     Ils incluent une valeur aléatoire appelée sel (<firstterm>salt</firstterm>
     en anglais) avec le résultat, pour que les utilisateurs qui ont le même mot
     de passer puissent avoir des mots de passe chiffrés différents. C'est
     aussi une défense supplémentaire comme l'inversion de l'algorithme.
    </para>
   </listitem>
   <listitem>
    <para>
     Ils incluent le type de l'algorithme dans le résultat pour que les mots
     de passe hachés avec différents algorithmes puissent co-exister.
    </para>
   </listitem>
   <listitem>
    <para>
     Certains s'adaptent. Cela signifie que, une fois que les ordinateurs
     iront plus vite, vous pourrez configurer l'algorithme pour qu'il soit
     plus lent, ceci sans introduire d'incompatibilité avec les mots de
     passe existant.
    </para>
   </listitem>
  </orderedlist>

  <para>
   <xref linkend="pgcrypto-crypt-algorithms"/> liste les algorithmes
   supportés par la fonction <function>crypt()</function>.
  </para>

  <table id="pgcrypto-crypt-algorithms">
   <title>Algorithmes supportés par <function>crypt()</function></title>
   <tgroup cols="6">
    <thead>
     <row>
      <entry>Algorithme</entry>
      <entry>Longueur maximum du mot de passe</entry>
      <entry>Adaptif&nbsp;?</entry>
      <entry>Bits sel</entry>
      <entry>Longueur de la sortie</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>bf</literal></entry>
      <entry>72</entry>
      <entry>oui</entry>
      <entry>128</entry>
      <entry>60</entry>
      <entry>Basé sur Blowfish, variante 2a</entry>
     </row>
     <row>
      <entry><literal>md5</literal></entry>
      <entry>unlimited</entry>
      <entry>non</entry>
      <entry>48</entry>
      <entry>34</entry>
      <entry>crypt() basé sur MD5</entry>
     </row>
     <row>
      <entry><literal>xdes</literal></entry>
      <entry>8</entry>
      <entry>oui</entry>
      <entry>24</entry>
      <entry>20</entry>
      <entry>DES étendu</entry>
     </row>
     <row>
      <entry><literal>des</literal></entry>
      <entry>8</entry>
      <entry>non</entry>
      <entry>12</entry>
      <entry>13</entry>
      <entry>crypt original UNIX</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
   <title><function>crypt()</function></title>

   <indexterm>
    <primary>crypt</primary>
   </indexterm>

   <synopsis>
    crypt(password text, salt text) returns text
   </synopsis>

   <para>
    Calcule un hachage de mot de passe (<parameter>password</parameter>)
    d'après crypt(3) UN*X. Lors du stockage d'un nouveau mot de passe, vous
    devez utiliser la fonction <function>gen_salt()</function> pour générer
    un nouveau sel (<parameter>salt</parameter>). Lors de la vérification de
    mot de passe, passez la valeur hachée stockée <parameter>salt</parameter>,
    et testez si le résultat correspond à la valeur stockée.
   </para>
   <para>
    Exemple d'ajout d'un nouveau mot de passe&nbsp;:
   </para>
   <programlisting>
    UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
   </programlisting>
   <para>
    Exemple d'authentification&nbsp;:
   </para>
   <programlisting>
    SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;
   </programlisting>
   <para>
    Ceci renvoie <literal>true</literal> si le mot de passe saisi est correct.
   </para>
  </sect3>

  <sect3>
   <title><function>gen_salt()</function></title>

   <indexterm>
    <primary>gen_salt</primary>
   </indexterm>

   <synopsis>
    gen_salt(type text [, iter_count integer ]) returns text
   </synopsis>

   <para>
    Génère une nouvelle valeur aléatoire sel pour son utilisation avec
    <function>crypt()</function>.
    La chaîne sel indique aussi à <function>crypt()</function> l'algorithme à
    utiliser.
   </para>

   <para>
    Le paramètre <parameter>type</parameter> précise l'algorithme de hachage.
    Les types acceptés sont&nbsp;: <literal>des</literal>,
    <literal>xdes</literal>, <literal>md5</literal> et <literal>bf</literal>.
   </para>

   <para>
    Le paramètre <parameter>iter_count</parameter> laisse l'utilisateur
    indiquer le nombre d'itération, pour les algorithmes qui en ont. Plus le
    nombre est important, plus le hachage du mot de passe prendra du temps,
    et du coup plus le craquage du mot de passe prendre du temps. Cela étant
    dit, un nombre trop important rend pratiquement impossible le calcul du
    hachage. Si le paramètre <parameter>iter_count</parameter> est omis,
    le nombre d'itération par défaut est utilisé. Les valeurs autorisées pour
    <parameter>iter_count</parameter> dépendent de l'algorithme et sont
    affichées dans <xref linkend="pgcrypto-icfc-table"/>.
   </para>

   <table id="pgcrypto-icfc-table">
    <title>Nombre d'itération pour <function>crypt()</function></title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Algorithme</entry>
       <entry>Par défaut</entry>
       <entry>Min</entry>
       <entry>Max</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>xdes</literal></entry>
       <entry>725</entry>
       <entry>1</entry>
       <entry>16777215</entry>
      </row>
      <row>
       <entry><literal>bf</literal></entry>
       <entry>6</entry>
       <entry>4</entry>
       <entry>31</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Pour <literal>xdes</literal>, il existe une limite supplémentaire qui fait
    que ce nombre doit être un nombre impair.
   </para>

   <para>
    Pour utiliser un nombre d'itération approprié, pensez que la fonction
    crypt DES original a été conçu pour avoir la vitesse de quatre hachages
    par seconde sur le matériel de l'époque. Plus lent que quatre hachages par
    secondes casserait probablement la facilité d'utilisation. Plus rapide que
    cent hachages à la seconde est probablement trop rapide.
   </para>

   <para>
    <xref linkend="pgcrypto-hash-speed-table"/> donne un aperçu de la lenteur relative de
    différents algorithmes de hachage. La table montre le temps que prendrait
    le calcul de toutes les combinaisons réalisables pour un mot de passe sur
    huit caractères, en supposant que le mot de passe contient soit que des
    lettres minuscules, soit des lettres minuscules et majuscules et des
    chiffres. Dans les entrées <literal>crypt-bf</literal>, le nombre après
    un slash est le paramètre <parameter>iter_count</parameter> de
    <function>gen_salt</function>.
   </para>

   <table id="pgcrypto-hash-speed-table">
    <title>Vitesse de l'algorithm de hachage</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Algorithme</entry>
       <entry>Hachages/sec</entry>
       <entry>Pour <literal>[a-z]</literal></entry>
       <entry>Pour <literal>[A-Za-z0-9]</literal></entry>
       <entry>Durée par rapport à <literal>md5 hash</literal></entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>crypt-bf/8</literal></entry>
       <entry>1792</entry>
       <entry>4 années</entry>
       <entry>3927 années</entry>
       <entry>100k</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/7</literal></entry>
       <entry>3648</entry>
       <entry>2 années</entry>
       <entry>1929 années</entry>
       <entry>50k</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/6</literal></entry>
       <entry>7168</entry>
       <entry>1 année</entry>
       <entry>982 années</entry>
       <entry>25k</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/5</literal></entry>
       <entry>13504</entry>
       <entry>188 années</entry>
       <entry>521 années</entry>
       <entry>12.5k</entry>
      </row>
      <row>
       <entry><literal>crypt-md5</literal></entry>
       <entry>171584</entry>
       <entry>15 jours</entry>
       <entry>41 années</entry>
       <entry>1k</entry>
      </row>
      <row>
       <entry><literal>crypt-des</literal></entry>
       <entry>23221568</entry>
       <entry>157.5 minutes</entry>
       <entry>108 jours</entry>
       <entry>7</entry>
      </row>
      <row>
       <entry><literal>sha1</literal></entry>
       <entry>37774272</entry>
       <entry>90 minutes</entry>
       <entry>68 jours</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><literal>md5</literal> (hash)</entry>
       <entry>150085504</entry>
       <entry>22.5 minutes</entry>
       <entry>17 jours</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Lorsqu'elle est compilée avec <productname>OpenSSL</productname> 3.0.0 ou
    une version ultérieure, le fournisseur hérité doit être activé dans le
    fichier de configuration <filename>openssl.cnf</filename> pour utiliser
    les anciens chiffrements tels que DES or Blowfish.
   </para>

   <para>
    Notes&nbsp;:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      La machine utilisée est un Intel Mobile Core i3.
     </para>
    </listitem>
    <listitem>
     <para>
      Les numéros des algorithmes <literal>crypt-des</literal> et
      <literal>crypt-md5</literal> sont pris de la sortie
      du -test de John the Ripper v1.6.38.
     </para>
    </listitem>
    <listitem>
     <para>
      Les nombres hachés <literal>md5</literal> font partie de mdcrack 1.2.
     </para>
    </listitem>
    <listitem>
     <para>
      Les nombres <literal>sha1</literal> font partie de lcrack-20031130-beta.
     </para>
    </listitem>
    <listitem>
     <para>
      Les nombres <literal>crypt-bf</literal> sont pris en utilisant le
      programme simple qui boucle sur 1000 mots de passe de huit caractères.
      De cette façon, je peux afficher la vitesse avec les différents nombres
      de tours. Pour référence&nbsp;: <literal>john -test</literal> affiche 13506
      tours/sec pour <literal>crypt-bf/5</literal>. (La petite différence dans
      les résultats est dû au fait que l'implémentation de
      <literal>crypt-bf</literal> dans <filename>pgcrypto</filename> est la
      même que celle utilisée dans John the Ripper.)
     </para>
    </listitem>
   </itemizedlist>

   <para>
    Notez que <quote>tenter toutes les combinaisons</quote> n'est pas un
    exercice réaliste. Habituellement, craquer les mots de passe se fait avec
    l'aide de dictionnaires contenant les mots standards et différentes
    variantes. Donc, même des mots de passe qui ressemblent vaguement à des
    mots peuvent être craqués plus rapidement que les nombres ci-dessus le
    suggèrent alors qu'un mot de passe sur six caractères qui ne ressemble pas
    à un mot pourrait ne pas être craqué.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>Fonctions de chiffrement PGP</title>

  <para>
   Les fonctions implémentent la partie chiffrement du standard OpenPGP
   (<ulink url="https://tools.ietf.org/html/rfc4880">RFC 4880</ulink>).
   Les chiffrements à clés symétriques et publiques sont supportés.
  </para>

  <para>
   Un message PGP chiffré consiste en deux parties ou
   <firstterm>paquets</firstterm>&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Un paquet contenant la clé de session &mdash; soit une clé symétrique
     soit une clé publique chiffrée.
    </para>
   </listitem>
   <listitem>
    <para>
     Paquet contenant les données chiffrées avec la clé de session.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Lors du chiffrement avec une clé symétrique (par exemple, un mot de
   passe)&nbsp;:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Le mot de passe est haché en utilisant l'algorithme String2Key (S2K).
     C'est assez similaire à l'algorithme <function>crypt()</function> &mdash;
     lenteur voulue et nombre aléatoire pour le sel &mdash; mais il produit
     une clé binaire de taille complète.
    </para>
   </listitem>
   <listitem>
    <para>
     Si une clé de session séparée est demandée, une nouvelle clé sera générée
     au hasard. Sinon une clé S2K sera utilisée directement en tant que clé de
     session.
    </para>
   </listitem>
   <listitem>
    <para>
     Si une clé S2K est à utiliser directement, alors seuls les paramètres S2K
     sont placés dans le paquet de session. Sinon la clé de session sera
     chiffrée avec la clé S2K et placée dans le paquet de session.
    </para>
   </listitem>
  </orderedlist>

  <para>
   Lors du chiffrement avec une clé publique&nbsp;:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Une nouvelle clé de session est générée au hasard.
    </para>
   </listitem>
   <listitem>
    <para>
     Elle est chiffrée en utilisant la clé public et placée dans
     le paquet de session.
    </para>
   </listitem>
  </orderedlist>

  <para>
   Dans les deux cas, les données à chiffrer sont traitées ainsi&nbsp;:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Manipulation optionnelle des données&nbsp;: compression, conversion vers
     UTF-8, conversion de retours à la ligne.
    </para>
   </listitem>
   <listitem>
    <para>
     Les données sont préfixées avec un bloc d'octets pris au hasard. C'est
     identique à l'utilisation de <foreignphrase>random IV</foreignphrase>.
    </para>
   </listitem>
   <listitem>
    <para>
     Un hachage SHA1 d'un préfixe et de données au hasard est ajouté.
    </para>
   </listitem>
   <listitem>
    <para>
     Tout ceci est chiffré avec la clé de la session et placé dans la paquet
     de données.
    </para>
   </listitem>
  </orderedlist>

  <sect3>
   <title><function>pgp_sym_encrypt()</function></title>

   <indexterm>
    <primary>pgp_sym_encrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_sym_encrypt_bytea</primary>
   </indexterm>

   <synopsis>
    pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
    pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
   </synopsis>
   <para>
    Chiffre <parameter>data</parameter> avec une clé PGP symétrique
    <parameter>psw</parameter>.
    Le paramètre <parameter>options</parameter> peut contenir des options
    décrites ci-dessous.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_sym_decrypt()</function></title>

   <indexterm>
    <primary>pgp_sym_decrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_sym_decrypt_bytea</primary>
   </indexterm>

   <synopsis>
    pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
    pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
   </synopsis>
   <para>
    Déchiffre un message PGP chiffré avec une clé symétrique.
   </para>
   <para>
    Déchiffrer des données <type>bytea</type> avec <function>pgp_sym_decrypt</function>
    est interdit.
    Ceci a pour but d'éviter la sortie de données de type caractère invalides.
    Déchiffrer des données textuelles avec
    <function>pgp_sym_decrypt_bytea</function> ne pose pas de problème.
   </para>
   <para>
    Le paramètre <parameter>options</parameter> peut contenir les paramètres
    décrits ci-dessous.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_pub_encrypt()</function></title>

   <indexterm>
    <primary>pgp_pub_encrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_pub_encrypt_bytea</primary>
   </indexterm>

   <synopsis>
    pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
    pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
   </synopsis>
   <para>
    Chiffre <parameter>data</parameter> avec la clé PGP publique
    <parameter>key</parameter>.
    Avec cette fonction, une clé privée renverra une erreur.
   </para>
   <para>
    Le paramètre <parameter>options</parameter> peut contenir des options
    décrites ci-dessous.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_pub_decrypt()</function></title>

   <indexterm>
    <primary>pgp_pub_decrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_pub_decrypt_bytea</primary>
   </indexterm>

   <synopsis>
    pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
    pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea
   </synopsis>
   <para>
    Déchiffre un message chiffré avec une clé publique.
    <parameter>key</parameter> doit être la clé secrète correspondant à la
    clé publique utilisée pour chiffrer. Si la clé secrète est protégée par
    un mot de passe, vous devez saisir le mot de passe dans
    <parameter>psw</parameter>. S'il n'y a pas de mot de passe mais que vous
    devez indiquer des options, vous devez saisir un mot de passe vide.
   </para>
   <para>
    Déchiffrer des données <type>bytea</type> avec <function>pgp_pub_decrypt</function> est
    interdit. Ceci a pour but d'éviter la sortie de données de type caractère
    invalides. Déchiffrer des données textuelles avec
    <function>pgp_pub_decrypt_bytea</function> ne pose pas de problème.
   </para>
   <para>
    Le paramètre <parameter>options</parameter> peut contenir des options
    décrites ci-dessous.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_key_id()</function></title>

   <indexterm>
    <primary>pgp_key_id</primary>
   </indexterm>

   <synopsis>
    pgp_key_id(bytea) returns text
   </synopsis>
   <para>
    <function>pgp_key_id</function> extrait l'identifiant de la clé pour
    une clé PGP publique ou secrète. Ou il donne l'identifiant de la clé
    utilisé pour chiffrer les données si un message chiffré est fourni.
   </para>
   <para>
    Elle peut renvoyer deux identifiants de clés spéciaux&nbsp;:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>SYMKEY</literal>
     </para>
     <para>
      Le message est chiffré avec une clé symétrique.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>ANYKEY</literal>
     </para>
     <para>
      La donnée est chiffrée avec une clé publique mais l'identifiant de la clé
      est effacé. Cela signifie que vous avez besoin d'essayer toutes les clés
      secrètes pour voir laquelle la déchiffre. <filename>pgcrypto</filename>
      ne réalise pas lui-même de tels messages.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Notez que des clés différentes peuvent avoir le même identifiant. C'est
    rare mais normal. L'application client doit alors essayer de déchiffer avec
    chacune d'elle pour voir laquelle correspond &mdash; ce qui revient à la
    gestion de <literal>ANYKEY</literal>.
   </para>
  </sect3>

  <sect3>
   <title><function>armor()</function>, <function>dearmor()</function></title>

   <indexterm>
    <primary>armor</primary>
   </indexterm>

   <indexterm>
    <primary>dearmor</primary>
   </indexterm>

   <synopsis>
    armor(data bytea [ , keys text[], values text[] ]) returns text
    dearmor(data text) returns bytea
   </synopsis>

   <para>
    Ces fonctions enveloppent les données dans une armure ASCII PGP qui est
    basiquement en Base64 avec CRC et un formatage supplémentaire.
   </para>

   <para>
    Si les tableaux <parameter>keys</parameter> et
    <parameter>values</parameter> sont précisées, un <firstterm>entête
     d'armure</firstterm> est ajouté au format standard pour chaque paire
    clé/valeur. Les deux tableaux doivent avoir une seule dimension, et ils
    doivent avoir la même longueur. Les clés et valeurs ne peuvent pas
    contenir de caractères non ASCII.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_armor_headers</function></title>

   <indexterm>
    <primary>pgp_armor_headers</primary>
   </indexterm>

   <synopsis>
pgp_armor_headers(data text, key out text, value out text) returns setof record
   </synopsis>
   <para>
    <function>pgp_armor_headers()</function> extrait les en-têtes d'armure à
    partir de <parameter>data</parameter>. La valeur de retour est un ensemble
    de lignes avec deux colonnes, une clé et une valeur. Si les clés ou
    valeurs contiennent des caractères non ASCII, ils sont traités avec
    l'encodage UTF-8.
   </para>
  </sect3>

  <sect3>
   <title>Options pour les fonctions PGP</title>

   <para>
    Les options sont nommées de façon similaires à GnuPG. Les valeurs sont
    fournies après un signe d'égalité&nbsp;; les options sont séparées par
    des virgules. Par exemple&nbsp;:
   </para>
   <programlisting>
    pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
   </programlisting>

   <para>
    Toutes les options en dehors de <literal>convert-crlf</literal>
    s'appliquent seulement aux fonctions de chiffrement. Les fonctions de
    déchiffrement obtiennent des paramètres des données PGP.
   </para>

   <para>
    Les options les plus intéressantes sont probablement
    <literal>compression-algo</literal> et <literal>unicode-mode</literal>.
    Le reste doit avoir des valeurs par défaut raisonnables.
   </para>

   <sect4>
    <title>cipher-algo</title>

    <para>
     Quel algorithme de chiffrement à utiliser.
    </para>
    <literallayout>
     Valeurs&nbsp;: bf, aes128, aes192, aes256 (OpenSSL seulement&nbsp;:
     <literal>3des</literal>, <literal>cast5</literal>)
     Par défaut&nbsp;: aes128
     Applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>compress-algo</title>

    <para>
     Algorithme de compression à utiliser. Seulement disponible si
     <productname>PostgreSQL</productname> a été construit avec zlib.
    </para>
    <literallayout>
     Valeurs&nbsp;:
     0 - sans compression
     1 - compression ZIP
     2 -  compression ZLIB [=ZIP plus meta-data and block-CRC's]
     Par défaut&nbsp;: 0
     S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>compress-level</title>

    <para>
     Niveau de compression. Les grands niveaux compressent mieux mais sont plus
     lents. 0 désactive la compression.
    </para>
    <literallayout>
     Valeurs&nbsp;: 0, 1-9
     Par défaut&nbsp;: 6
     S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>convert-crlf</title>

    <para>
     Précise si <literal>\n</literal> doit être converti en
     <literal>\r\n</literal> lors du chiffrement et <literal>\r\n</literal> en
     <literal>\n</literal>  lors du déchiffrement. La <acronym>RFC</acronym>
     4880 spécifie que
     les données texte doivent être stockées en utilisant les retours chariot
     <literal>\r\n</literal>. Utilisez cette option pour obtenir un comportement
     respectant la RFC.
    </para>
    <literallayout>
     Valeurs&nbsp;: 0, 1
     Par défaut&nbsp;: 0
     S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt,
     pgp_pub_decrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>disable-mdc</title>

    <para>
     Ne protège pas les données avec SHA-1. La seule bonne raison pour utiliser
     cette option est d'avoir une compatibilité avec les anciens produits PGP
     précédant l'ajout de paquets protégés SHA-1 dans la <acronym>RFC</acronym>
     4880. Les versions
     récentes des logiciels de gnupg.org et pgp.com le supportent.
    </para>
    <literallayout>
     Valeurs&nbsp;: 0, 1
     Par défaut&nbsp;: 0
     S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>sess-key</title>

    <para>
     Utilise la clé de session séparée. Le chiffrement par clé publique utilise
     toujours une clé de session séparée, c'est pour le chiffrement de clé
     symétrique, qui utilise directement par défaut S2K.
    </para>
    <literallayout>
     Valeurs&nbsp;: 0, 1
     Par défaut&nbsp;: 0
     S'applique à&nbsp;: pgp_sym_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>s2k-mode</title>

    <para>
     Algorithme S2K à utiliser.
    </para>
    <literallayout>
     Valeurs&nbsp;:
     0 - Sans sel. Dangereux&nbsp;!
     1 - Avec sel mais avec un décompte fixe des itérations.
     3 - Décompte variables des itérations.
     Par défaut&nbsp;: 3
     S'applique à&nbsp;: pgp_sym_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>s2k-count</title>

    <para>
     Le nombre d'itérations de l'algorithme S2K à utiliser. La valeur doit être
     comprise entre 1024 et 65011712, valeurs incluses.
    </para>
    <literallayout>
     Par défaut&nbsp;: Une valeur aléatoire entre 65536 et 253952
     S'applique à&nbsp;: pgp_sym_encrypt, seulement avec s2k-mode=3
    </literallayout>
   </sect4>

   <sect4>
    <title>s2k-digest-algo</title>

    <para>
     Algorithme digest à utiliser dans le calcul S2K.
    </para>
    <literallayout>
     Valeurs&nbsp;: md5, sha1
     Par défaut&nbsp;: sha1
     S'applique à&nbsp;: pgp_sym_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>s2k-cipher-algo</title>

    <para>
     Chiffrement à utiliser pour le chiffrage de la clé de session séparée.
    </para>
    <literallayout>
     Valeurs&nbsp;: bf, aes, aes128, aes192, aes256
     Par défaut&nbsp;: use cipher-algo
     S'applique à&nbsp;: pgp_sym_encrypt
    </literallayout>
   </sect4>

   <sect4>
    <title>unicode-mode</title>

    <para>
     Sélection de la conversion des données texte à partir de l'encodage interne
     de la base vers l'UTF-8 et inversement. Si votre base de données est déjà
     en UTF-8, aucune conversion ne sera réalisée, seules les données seront
     marquées comme étant en UTF-8. Sans cette option, cela ne se fera pas.
    </para>
    <literallayout>
     Valeurs&nbsp;: 0, 1
     Par défaut&nbsp;: 0
     S'applique à&nbsp;: pgp_sym_encrypt, pgp_pub_encrypt
    </literallayout>
   </sect4>
  </sect3>

  <sect3>
   <title>Générer des clés PGP avec GnuPG</title>

   <para>
    Pour générer une nouvelle clé&nbsp;:
   </para>
   <programlisting>
   gpg --gen-key
   </programlisting>
   <para>
    Le type de clé préféré est <quote>DSA and Elgamal</quote>.
   </para>
   <para>
    Pour le chiffrement RSA, vous devez créer soit une clé de signature seulement
    DSA ou RSA en tant que maître, puis ajouter la sous-clé de chiffrement RSA
    avec <literal>gpg --edit-key</literal>.
   </para>
   <para>
    Pour lister les clés&nbsp;:
   </para>
   <programlisting>
   gpg --list-secret-keys
   </programlisting>
   <para>
    Pour exporter une clé publique dans un format armure ASCII&nbsp;:
   </para>
   <programlisting>
   gpg -a --export KEYID > public.key
   </programlisting>
   <para>
    Pour exporter une clé secrète dans un format armure ASCII&nbsp;:
   </para>
   <programlisting>
   gpg -a --export-secret-keys KEYID > secret.key
   </programlisting>
   <para>
    Vous avez besoin d'utiliser la fonction <function>dearmor()</function> sur
    ces clés avant de les passer aux fonctions PGP. Ou si vous gérez des données
    binaires, vous pouvez supprimer l'option <literal>-a</literal> pour la
    commande.
   </para>
   <para>
    Pour plus de détails, voir la <literal>page de référence de gpg</literal>,
    le <ulink url="https://www.gnupg.org/gph/en/manual.html">livre « GNU
     Privacy Handbook »</ulink> et d'autres documents sur le
    <ulink url="https://www.gnupg.org/">site gnupg.org</ulink>.
   </para>
  </sect3>

  <sect3>
   <title>Limites du code PGP</title>

   <itemizedlist>
    <listitem>
     <para>
      Pas de support des signatures. Cela signifie aussi qu'on ne peut pas
      vérifier si la sous-clé de chiffrage appartient bien à la clé maître.
     </para>
    </listitem>
    <listitem>
     <para>
      Pas de support de la clé de chiffrement en tant que clé maître. Cela ne
      devrait pas être un problème étant donné que cette pratique n'est pas
      encouragée.
     </para>
    </listitem>
    <listitem>
     <para>
      Pas de support pour plusieurs sous-clés. Ceci peut être un problème car
      c'est une pratique courante. D'un autre côté, vous ne devez pas utiliser
      vos clés GPG/PGP habituelles avec <filename>pgcrypto</filename>, mais en
      créer de nouvelles car l'utilisation est assez différente.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <title>Fonctions de chiffrement brut (Raw)</title>

  <para>
   Ces fonctions exécutent directement un calcul des données&nbsp;; ils n'ont
   pas de fonctionnalités avancées de chiffrement PGP. Du coup, ils ont les
   problèmes majeurs suivant&nbsp;:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Elles utilisent directement la clé de l'utilisateur comme clé de calcul.
    </para>
   </listitem>
   <listitem>
    <para>
     Elles ne fournissent pas une vérification de l'intégrité pour savoir si
     les données chiffrées ont été modifiées.
    </para>
   </listitem>
   <listitem>
    <para>
     Elles s'attendent à ce que les utilisateurs gèrent eux-même tous les
     paramètres du chiffrement, même IV.
    </para>
   </listitem>
   <listitem>
    <para>
     Elles ne gèrent pas le texte.
    </para>
   </listitem>
  </orderedlist>
  <para>
   Donc, avec l'introduction du chiffrement PGP, l'utilisation des fonctions
   de chiffrement brut n'est pas encouragée.
  </para>

  <indexterm>
   <primary>encrypt</primary>
  </indexterm>

  <indexterm>
   <primary>decrypt</primary>
  </indexterm>

  <indexterm>
   <primary>encrypt_iv</primary>
  </indexterm>

  <indexterm>
   <primary>decrypt_iv</primary>
  </indexterm>

  <synopsis>
    encrypt(data bytea, key bytea, type text) returns bytea
    decrypt(data bytea, key bytea, type text) returns bytea

    encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
    decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
  </synopsis>

  <para>
   Chiffrer/déchiffrer les données en utilisant la méthode de calcul spécifiée
   par <parameter>type</parameter>. La syntaxe de la chaîne
   <parameter>type</parameter> est&nbsp;:
  </para>

  <synopsis>
   <replaceable>algorithm</replaceable> <optional> <literal>-</literal> <replaceable>mode</replaceable> </optional> <optional> <literal>/pad:</literal> <replaceable>padding</replaceable> </optional>
  </synopsis>

  <para>
   où <replaceable>algorithm</replaceable> fait partie de&nbsp;:
  </para>
  <itemizedlist>
   <listitem><para><literal>bf</literal> &mdash; Blowfish</para></listitem>
   <listitem><para><literal>aes</literal> &mdash; AES (Rijndael-128, -192 ou -256)</para></listitem>
  </itemizedlist>
  <para>
   et <replaceable>mode</replaceable> fait partie de&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <literal>cbc</literal> &mdash; le bloc suivant dépend du précédent. (par
     défaut)
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ecb</literal> &mdash; chaque bloc est chiffré séparément.
     (seulement pour les tests)
    </para>
   </listitem>
  </itemizedlist>
  <para>
   et <replaceable>padding</replaceable> fait partie de&nbsp;:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <literal>pkcs</literal> &mdash; les données peuvent avoir n'importe quelle
     longueur (par défault)
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>none</literal> &mdash; les données doivent être des multiples de
     la taille du bloc de calcul.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Donc, pour exemple, ces derniers sont équivalents&nbsp;:
  </para>
  <programlisting>
   encrypt(data, 'fooz', 'bf')
   encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
  </programlisting>
  <para>
   Dans <function>encrypt_iv</function> et <function>decrypt_iv</function>, le
   paramètre <parameter>iv</parameter> est la valeur initiale pour le mode
   CBC&nbsp;; elle est ignorée pour ECB. Elle est remplie de zéro pour
   l'alignement si la taille de données ne correspond à un multiple de la
   taille du bloc. Elle a pour valeur par défaut que des zéros dans les
   fonctions sans ce paramètre.
  </para>
 </sect2>

 <sect2>
  <title>Fonctions d'octets au hasard</title>

  <indexterm>
   <primary>gen_random_bytes</primary>
  </indexterm>

  <synopsis>
   gen_random_bytes(count integer) returns bytea
  </synopsis>
  <para>
   Renvoie <parameter>count</parameter>) octets pour un chiffrement fort.
   Il peut y avoir au maximum 1024 octets extrait à un instant t, ceci pour
   éviter de vider le contenu du générateur de nombres aléatoires.
  </para>

  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>

  <synopsis>
gen_random_uuid() returns uuid
  </synopsis>
  <para>
   Retourne un UUID de version 4 (aléatoire). (Obsolète, cette fonction est
   maintenant intégrée nativement à <productname>PostgreSQL</productname>.)
  </para>
 </sect2>

 <sect2>
  <title>Notes</title>

  <sect3>
   <title>Configuration</title>

   <para>
    <filename>pgcrypto</filename> se configure lui-même suivant les
    découvertes du scrip <literal>configure</literal> principal de PostgreSQL.
    Les options qui l'affectent sont <literal>--with-zlib</literal> et
    <literal>--with-ssl=openssl</literal>.
   </para>

   <para>
    Quand il est compilé avec zlib, les fonctions de chiffrement PGP peuvent
    compresser les données avant chiffrement.
   </para>

   <para>
    Quand il est compilé avec <productname>OpenSSL</productname>, plus
    d'algorithmes seront disponibles. De plus, les fonctions de chiffrement à
    clé publique seront plus rapides car <productname>OpenSSL</productname> a
    des fonctions BIGNUM plus optimisées.
   </para>

   <table id="pgcrypto-with-without-openssl">
    <title>Résumé de fonctionnalités avec et sans OpenSSL</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Fonctionnalité</entry>
       <entry>Interne</entry>
       <entry>Avec OpenSSL</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>MD5</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>SHA1</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>SHA224/256/384/512</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>D'autres algorithmes digest</entry>
       <entry>non</entry>
       <entry>oui (Note 1)</entry>
      </row>
      <row>
       <entry>Blowfish</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>AES</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>DES/3DES/CAST5</entry>
       <entry>non</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>Raw encryption</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>PGP Symmetric encryption</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
      <row>
       <entry>PGP Public-Key encryption</entry>
       <entry>oui</entry>
       <entry>oui</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Lorsqu'il est compilé avec la version 3.0.0 ou ultérieure
    d'<productname>OpenSSL</productname>, l'ancien fournisseur doit être
    activé dans le fichier de configuration <filename>openssl.cnf</filename>
    pour utiliser les chiffrements les plus anciens comme DES ou Blowfish.
   </para>

   <para>
    Notes&nbsp;:
   </para>

   <orderedlist>
    <listitem>
     <para>
      Tout algorithme digest qu'<productname>OpenSSL</productname> supporte est
      automatiquement choisi.
      Ce n'est pas possible avec les chiffreurs qui doivent être supportés
      explicitement.
     </para>
    </listitem>
   </orderedlist>
  </sect3>

  <sect3>
   <title>Gestion des NULL</title>

   <para>
    Comme le standard SQL le demande, toutes les fonctions renvoient NULL si
    un des arguments est NULL. Cela peut permettre une faille de sécurité si
    c'est utilisé sans précaution.
   </para>
  </sect3>

  <sect3>
   <title>Limites de la sécurité</title>

   <para>
    Toutes les fonctions de <filename>pgcrypto</filename> sont exécutées au
    sein du serveur de bases de données. Cela signifie que toutes les données
    et les mots de passe sont passés entre <filename>pgcrypto</filename> et
    l'application client en texte clair. Donc, vous devez&nbsp;:
   </para>

   <orderedlist>
    <listitem>
     <para>Vous connecter localement ou utiliser des connexions
      SSL&nbsp;;</para>
    </listitem>
    <listitem>
     <para>Faire confiance à votre administrateur système et de base de
      données.</para>
    </listitem>
   </orderedlist>

   <para>
    Si vous ne le pouvez pas, alors il est préférable de chiffrer directement
    au sein de l'application client.
   </para>

   <para>
    L'implémentation ne résiste pas à des <ulink
    url="https://en.wikipedia.org/wiki/Side-channel_attack">attaques par canal
     auxiliaire</ulink>. Par exemple, le temps requis pour terminer l'exécution
    d'une fonction de déchiffrement de <filename>pgcrypto</filename> varie
    suivant les texts de déchiffrement d'une certaine taille.
   </para>
  </sect3>

  <sect3>
   <title>Lectures intéressantes</title>

   <itemizedlist>
    <listitem>
     <para><ulink url="https://www.gnupg.org/gph/en/manual.html"></ulink></para>
     <para>The GNU Privacy Handbook.</para>
    </listitem>
    <listitem>
     <para><ulink url="https://www.openwall.com/crypt/"></ulink></para>
     <para>Décrit l'algorithme crypt-blowfish.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="https://www.iusmentis.com/security/passphrasefaq/"></ulink>
     </para>
     <para>Comment choisir un bon mot de passe.</para>
    </listitem>
    <listitem>
     <para><ulink url="https://www.usenix.org/legacy/events/usenix99/provos.html"></ulink></para>
     <para>Idée intéressante pour choisir des mots de passe.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html"></ulink>
     </para>
     <para>Décrit la bonne et la mauvaise cryptographie.</para>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <title>Références tecyhniques</title>

   <itemizedlist>
    <listitem>
     <para><ulink url="https://tools.ietf.org/html/rfc4880"></ulink></para>
     <para>Format du message OpenPGP.</para>
    </listitem>
    <listitem>
     <para><ulink url="https://tools.ietf.org/html/rfc1321"></ulink></para>
     <para>Algorithme MD5.</para>
    </listitem>
    <listitem>
     <para><ulink url="https://tools.ietf.org/html/rfc2104"></ulink></para>
     <para>HMAC: Keyed-Hashing for Message Authentication.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.usenix.org/events/usenix99/provos.html"></ulink>
     </para>
     <para>Comparaison des algorithmes crypt-des, crypt-md5 et bcrypt.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="https://en.wikipedia.org/wiki/Fortuna_(PRNG)"></ulink>
     </para>
     <para>Description de Fortuna CSPRNG.</para>
    </listitem>
    <listitem>
     <para><ulink url="https://jlcooke.ca/random/"></ulink></para>
     <para>Jean-Luc Cooke Fortuna-based <filename>/dev/random</filename> driver for Linux.</para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <title>Auteur</title>

  <para>
   Marko Kreen <email>markokr@gmail.com</email>
  </para>

  <para>
   <filename>pgcrypto</filename> utilise du code provenant des sources
   suivantes&nbsp;:
  </para>

  <informaltable>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Algorithme</entry>
      <entry>Auteur</entry>
      <entry>Origine du source</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>DES crypt</entry>
      <entry>David Burren and others</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
     <row>
      <entry>MD5 crypt</entry>
      <entry>Poul-Henning Kamp</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
     <row>
      <entry>Blowfish crypt</entry>
      <entry>Solar Designer</entry>
      <entry>www.openwall.com</entry>
     </row>
     <row>
      <entry>Blowfish cipher</entry>
      <entry>Simon Tatham</entry>
      <entry>PuTTY</entry>
     </row>
     <row>
      <entry>Rijndael cipher</entry>
      <entry>Brian Gladman</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
     <row>
      <entry>Hachage MD5 and SHA1</entry>
      <entry>WIDE Project</entry>
      <entry>KAME kame/sys/crypto</entry>
     </row>
     <row>
      <entry>SHA256/384/512</entry>
      <entry>Aaron D. Gifford</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
     <row>
      <entry>BIGNUM math</entry>
      <entry>Michael J. Fromberger</entry>
      <entry>dartmouth.edu/~sting/sw/imath</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect2>

</sect1>
