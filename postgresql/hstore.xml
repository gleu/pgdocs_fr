<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="hstore">
 <title>hstore</title>

 <indexterm zone="hstore">
  <primary>hstore</primary>
 </indexterm>

 <para>
  Ce module code le type de données <type>hstore</type> pour stocker des
  ensembles de paires clé/valeur à l'intérieur d'une simple valeur
  <productname>PostgreSQL</productname>. Cela peut s'avérer utile dans divers
  cas, comme les lignes à attributs multiples rarement examinées ou les données
  semi-structurées. Keys and values are
  simply text strings.
 </para>

 <sect2>
  <title>Représentation externe de <type>hstore</type></title>

  <para>
   La représentation textuelle d'une valeur <type>hstore</type>, used for input and output, inclut
   zéro ou plusieurs paires <replaceable>clé</replaceable>
   <literal>=&gt;</literal> <replaceable>valeur</replaceable> séparées par
   des virgules. Par exemple&nbsp;:

   <programlisting>
    k =&gt; v
    foo =&gt; bar, baz =&gt; whatever
    "1-a" =&gt; "anything at all"
   </programlisting>

   The order of the pairs is not significant (and may not be reproduced on
   output). Whitespace between pairs or around the <literal>=&gt;</literal> sign is
   ignored. Double-quote keys and values that include whitespace, commas,
   <literal>=</literal>s or <literal>&gt;</literal>s. To include a double quote or a
   backslash in a key or value, escape it with a backslash.
  </para>

  <para>
   Each key in an <type>hstore</type> is unique. If you declare an <type>hstore</type>
   with duplicate keys, only one will be stored in the <type>hstore</type> and
   there is no guarantee as to which will be kept:

   <programlisting>
% select 'a=&gt;1,a=&gt;2'::hstore;
  hstore
----------
 "a"=&gt;"1"
   </programlisting>
  </para>

  <para>
   A value (but not a key) can be an SQL <literal>NULL</literal>. For example:

   <programlisting>
    key =&gt; NULL
   </programlisting>

   The <literal>NULL</literal> keyword is case-insensitive. Double-quote the
   <literal>NULL</literal> to treat it as the ordinary string "NULL".
  </para>

  <note>
  <para>
   Keep in mind that the <type>hstore</type> text format, when used for input,
   applies <emphasis>before</emphasis> any required quoting or escaping. If you are
   passing an <type>hstore</type> literal via a parameter, then no additional
   processing is needed. But if you're passing it as a quoted literal
   constant, then any single-quote characters and (depending on the setting of
   the <varname>standard_conforming_strings</varname> configuration parameter)
   backslash characters need to be escaped correctly. See
   <xref linkend="sql-syntax-strings"/> for more on the handling of string
   constants.
  </para>
  </note>

  <para>
   On output, double quotes always surround keys and values, even when it's
   not strictly necessary.
  </para>

 </sect2>

 <sect2>
  <title>Opérateurs et fonctions <type>hstore</type></title>

  <table id="hstore-op-table">
   <title>Opérateurs<type>hstore</type></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Opérateur</entry>
      <entry>Description</entry>
      <entry>Exemple</entry>
      <entry>Résultat</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><type>hstore</type> <literal>-&gt;</literal> <type>text</type></entry>
      <entry>obtenir la valeur de la clé (<literal>NULL</literal> si inexistante)</entry>
      <entry><literal>'a=&gt;x, b=&gt;y'::hstore -&gt; 'a'</literal></entry>
      <entry><literal>x</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>-&gt;</literal> <type>text[]</type></entry>
      <entry>get values for keys (<literal>NULL</literal> if not present)</entry>
      <entry><literal>'a=&gt;x, b=&gt;y, c=&gt;z'::hstore -&gt; ARRAY['c','a']</literal></entry>
      <entry><literal>{"z","x"}</literal></entry>
     </row>

     <row>
      <entry><type>text</type> <literal>=&gt;</literal> <type>text</type></entry>
      <entry>créer un <type>hstore</type> à un seul élément</entry>
      <entry><literal>'a' =&gt; 'b'</literal></entry>
      <entry><literal>"a"=&gt;"b"</literal></entry>
     </row>

     <row>
      <entry><type>text[]</type> <literal>=&gt;</literal> <type>text[]</type></entry>
      <entry>construct an <type>hstore</type> from separate key and value arrays</entry>
      <entry><literal>ARRAY['a','b'] =&gt; ARRAY['1','2']</literal></entry>
      <entry><literal>"a"=&gt;"1","b"=&gt;"2"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>=&gt;</literal> <type>text[]</type></entry>
      <entry>extract a subset of an <type>hstore</type></entry>
      <entry><literal>'a=&gt;1,b=&gt;2,c=&gt;3'::hstore =&gt; ARRAY['b','c','x']</literal></entry>
      <entry><literal>"b"=&gt;"2", "c"=&gt;"3"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>||</literal> <type>hstore</type></entry>
      <entry>concaténation de <type>hstore</type></entry>
      <entry><literal>'a=&gt;b, c=&gt;d'::hstore || 'c=&gt;x, d=&gt;q'::hstore</literal></entry>
      <entry><literal>"a"=&gt;"b", "c"=&gt;"x", "d"=&gt;"q"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>?</literal> <type>text</type></entry>
      <entry><type>hstore</type> contient-il une clé donnée&nbsp;?</entry>
      <entry><literal>'a=&gt;1'::hstore ? 'a'</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>?&amp;</literal> <type>text[]</type></entry>
      <entry>does <type>hstore</type> contain all specified keys?</entry>
      <entry><literal>'a=&gt;1,b=&gt;2'::hstore ?&amp; ARRAY['a','b']</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>?|</literal> <type>text[]</type></entry>
      <entry>does <type>hstore</type> contain any of the specified keys?</entry>
      <entry><literal>'a=&gt;1,b=&gt;2'::hstore ?| ARRAY['b','c']</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>@&gt;</literal> <type>hstore</type></entry>
      <entry>l'opérande gauche contient-il l'opérande droit&nbsp;?</entry>
      <entry><literal>'a=&gt;b, b=&gt;1, c=&gt;NULL'::hstore @&gt; 'b=&gt;1'</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>&lt;@</literal> <type>hstore</type></entry>
      <entry>l'opérande gauche est-il contenu dans l'opérande
      droit&nbsp;?</entry>
      <entry><literal>'a=&gt;c'::hstore &lt;@ 'a=&gt;b, b=&gt;1, c=&gt;NULL'</literal></entry>
      <entry><literal>f</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>-</literal> <type>text</type></entry>
      <entry>delete key from left operand</entry>
      <entry><literal>'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - 'b'::text</literal></entry>
      <entry><literal>"a"=&gt;"1", "c"=&gt;"3"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>-</literal> <type>text[]</type></entry>
      <entry>delete keys from left operand</entry>
      <entry><literal>'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - ARRAY['a','b']</literal></entry>
      <entry><literal>"c"=&gt;"3"</literal></entry>
     </row>

     <row>
      <entry><type>hstore</type> <literal>-</literal> <type>hstore</type></entry>
      <entry>delete matching pairs from left operand</entry>
      <entry><literal>'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - 'a=&gt;4, b=&gt;2'::hstore</literal></entry>
      <entry><literal>"a"=&gt;"1", "c"=&gt;"3"</literal></entry>
     </row>

     <row>
      <entry><type>record</type> <literal>#=</literal> <type>hstore</type></entry>
      <entry>replace fields in <type>record</type> with matching values from <type>hstore</type></entry>
      <entry>see Examples section</entry>
      <entry></entry>
     </row>

     <row>
      <entry><literal>%%</literal> <type>hstore</type></entry>
      <entry>convert <type>hstore</type> to array of alternating keys and values</entry>
      <entry><literal>%% 'a=&gt;foo, b=&gt;bar'::hstore</literal></entry>
      <entry><literal>{a,foo,b,bar}</literal></entry>
     </row>

     <row>
      <entry><literal>%#</literal> <type>hstore</type></entry>
      <entry>convert <type>hstore</type> to two-dimensional key/value array</entry>
      <entry><literal>%# 'a=&gt;foo, b=&gt;bar'::hstore</literal></entry>
      <entry><literal>{{a,foo},{b,bar}}</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Avant PostgreSQL 8.2, les opérateurs de contenance @&gt; et &lt;@ étaient
   appelés respectivement @ et ~. Ces noms sont toujours disponibles mais sont
   devenus obsolètes et pourraient éventuellement être supprimés.
   Les anciens noms sont inversés par rapport à la convention suivie par les
   types de données géométriques.
  </para>

  <table id="hstore-func-table">
   <title>Fonctions <type>hstore</type></title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Fonction</entry>
      <entry>Type en retour</entry>
      <entry>Description</entry>
      <entry>Exemple</entry>
      <entry>Résultat</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><function>hstore(record)</function></entry>
      <entry><type>hstore</type></entry>
      <entry>construct an <type>hstore</type> from a record or row</entry>
      <entry><literal>hstore(ROW(1,2))</literal></entry>
      <entry><literal>f1=&gt;1,f2=&gt;2</literal></entry>
     </row>

     <row>
      <entry><function>hstore(text[])</function></entry>
      <entry><type>hstore</type></entry>
      <entry>construct an <type>hstore</type> from an array, which may be either
       a key/value array, or a two-dimensional array</entry>
      <entry><literal>hstore(ARRAY['a','1','b','2']) || hstore(ARRAY[['c','3'],['d','4']])</literal></entry>
      <entry><literal>a=&gt;1, b=&gt;2, c=&gt;3, d=&gt;4</literal></entry>
     </row>

     <row>
      <entry><function>akeys(hstore)</function></entry>
      <entry><type>text[]</type></entry>
      <entry>récupérer les clés du <type>hstore</type> dans un tableau</entry>
      <entry><literal>akeys('a=&gt;1,b=&gt;2')</literal></entry>
      <entry><literal>{a,b}</literal></entry>
     </row>

     <row>
      <entry><function>skeys(hstore)</function></entry>
      <entry><type>setof text</type></entry>
      <entry>récupérer les clés du <type>hstore</type> dans un ensemble</entry>
      <entry><literal>skeys('a=&gt;1,b=&gt;2')</literal></entry>
      <entry>
<programlisting>
a
b
</programlisting></entry>
     </row>

     <row>
      <entry><function>avals(hstore)</function></entry>
      <entry><type>text[]</type></entry>
      <entry>récupérer les valeurs du <type>hstore</type> dans un tableau</entry>
      <entry><literal>avals('a=&gt;1,b=&gt;2')</literal></entry>
      <entry><literal>{1,2}</literal></entry>
     </row>

     <row>
      <entry><function>svals(hstore)</function></entry>
      <entry><type>setof text</type></entry>
      <entry>récupérer les valeurs du <type>hstore</type> dans un
      ensemble</entry>
      <entry><literal>svals('a=&gt;1,b=&gt;2')</literal></entry>
      <entry>
<programlisting>
1
2
</programlisting></entry>
     </row>

     <row>
      <entry><function>hstore_to_array(hstore)</function></entry>
      <entry><type>text[]</type></entry>
      <entry>get <type>hstore</type>'s keys and values as an array of alternating
       keys and values</entry>
      <entry><literal>hstore_to_array('a=&gt;1,b=&gt;2')</literal></entry>
      <entry><literal>{a,1,b,2}</literal></entry>
     </row>

     <row>
      <entry><function>hstore_to_matrix(hstore)</function></entry>
      <entry><type>text[]</type></entry>
      <entry>get <type>hstore</type>'s keys and values as a two-dimensional array</entry>
      <entry><literal>hstore_to_matrix('a=&gt;1,b=&gt;2')</literal></entry>
      <entry><literal>{{a,1},{b,2}}</literal></entry>
     </row>

     <row>
      <entry><function>each(hstore)</function></entry>
      <entry><type>setof (key text, value text)</type></entry>
      <entry>récupérer les clés et valeurs du <type>hstore</type> dans un
      ensemble</entry>
      <entry><literal>select * from each('a=&gt;1,b=&gt;2')</literal></entry>
      <entry>
<programlisting>
 key | value
-----+-------
 a   | 1
 b   | 2
</programlisting></entry>
     </row>

     <row>
      <entry><function>exist(hstore,text)</function></entry>
      <entry><type>boolean</type></entry>
      <entry>le <type>hstore</type> contient-il une clé donnée&nbsp;?</entry>
      <entry><literal>exist('a=&gt;1','a')</literal></entry>
      <entry><literal>t</literal></entry>
     </row>

     <row>
      <entry><function>defined(hstore,text)</function></entry>
      <entry><type>boolean</type></entry>
      <entry>le <type>hstore</type> contient-il une valeur non <literal>NULL</literal> pour la
      clé&nbsp;?</entry>
      <entry><literal>defined('a=&gt;NULL','a')</literal></entry>
      <entry><literal>f</literal></entry>
     </row>

     <row>
      <entry><function>delete(hstore,text)</function></entry>
      <entry><type>hstore</type></entry>
      <entry>supprimer toute paire correspondant à une clé donnée</entry>
      <entry><literal>delete('a=&gt;1,b=&gt;2','b')</literal></entry>
      <entry><literal>"a"=>"1"</literal></entry>
     </row>

     <row>
      <entry><function>delete(hstore,text[])</function></entry>
      <entry><type>hstore</type></entry>
      <entry>delete pairs with matching keys</entry>
      <entry><literal>delete('a=&gt;1,b=&gt;2,c=&gt;3',ARRAY['a','b'])</literal></entry>
      <entry><literal>"c"=>"3"</literal></entry>
     </row>

     <row>
      <entry><function>delete(hstore,hstore)</function></entry>
      <entry><type>hstore</type></entry>
      <entry>delete pairs matching those in the second argument</entry>
      <entry><literal>delete('a=&gt;1,b=&gt;2','a=&gt;4,b=&gt;2'::hstore)</literal></entry>
      <entry><literal>"a"=>"1"</literal></entry>
     </row>

     <row>
      <entry><function>populate_record(record,hstore)</function></entry>
      <entry><type>record</type></entry>
      <entry>replace fields in <type>record</type> with matching values from <type>hstore</type></entry>
      <entry>see Examples section</entry>
      <entry></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    The function <function>populate_record</function> is actually declared
    with <type>anyelement</type>, not <type>record</type>, as its first argument,
    but it will reject non-record types with a runtime error.
   </para>
  </note>
 </sect2>

 <sect2>
  <title>Index</title>

  <para>
   <type>hstore</type> has GiST and GIN index support for the <literal>@&gt;</literal>,
   <literal>?</literal>, <literal>?&amp;</literal> and <literal>?|</literal> operators. For example:
  </para>
  <programlisting>
CREATE INDEX hidx ON testhstore USING GIST (h);

CREATE INDEX hidx ON testhstore USING GIN (h);
  </programlisting>

  <para>
   <type>hstore</type> also supports <type>btree</type> or <type>hash</type> indexes for
   the <literal>=</literal> operator. This allows <type>hstore</type> columns to be
   declared <literal>UNIQUE</literal>, or to be used in <literal>GROUP BY</literal>,
   <literal>ORDER BY</literal> or <literal>DISTINCT</literal> expressions. The sort ordering
   for <type>hstore</type> values is not particularly useful, but these indexes
   may be useful for equivalence lookups. Create indexes for <literal>=</literal>
   comparisons as follows:
  </para>
  <programlisting>
CREATE INDEX hidx ON testhstore USING BTREE (h);

CREATE INDEX hidx ON testhstore USING HASH (h);
  </programlisting>
 </sect2>

 <sect2>
  <title>Exemples</title>

  <para>
   Ajouter une clé, ou mettre à jour une clé existante avec une nouvelle
   valeur&nbsp;:
  </para>
  <programlisting>
UPDATE tab SET h = h || ('c' =&gt; '3');
  </programlisting>

  <para>
   Supprimer une clé&nbsp;:
  </para>
  <programlisting>
UPDATE tab SET h = delete(h, 'k1');
  </programlisting>

  <para>
   Convert a <type>record</type> to an <type>hstore</type>:
  </para>
  <programlisting>
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');

SELECT hstore(t) FROM test AS t;
                   hstore                    
---------------------------------------------
 "col1"=&gt;"123", "col2"=&gt;"foo", "col3"=&gt;"bar"
(1 row)
  </programlisting>

  <para>
   Convert an <type>hstore</type> to a predefined <type>record</type> type:
  </para>
  <programlisting>
CREATE TABLE test (col1 integer, col2 text, col3 text);

SELECT * FROM populate_record(null::test,
                              '"col1"=&gt;"456", "col2"=&gt;"zzz"');
 col1 | col2 | col3 
------+------+------
  456 | zzz  | 
(1 row)
  </programlisting>

  <para>
   Modify an existing record using the values from an <type>hstore</type>:
  </para>
  <programlisting>
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');

SELECT (r).* FROM (SELECT t #= '"col3"=&gt;"baz"' AS r FROM test t) s;
 col1 | col2 | col3 
------+------+------
  123 | foo  | baz
(1 row)
  </programlisting>
 </sect2>

 <sect2>
  <title>Statistiques</title>

  <para>
   Le type <type>hstore</type>, du fait de sa libéralité intrinsèque, peut
   contenir beaucoup de clés différentes. C'est à l'application de vérifier
   la validité des clés. Les exemples ci-dessous présentent plusieurs
   techniques pour vérifier les clés et obtenir des statistiques.
  </para>

  <para>
   Exemple simple&nbsp;:
  </para>
  <programlisting>
SELECT * FROM each('aaa=&gt;bq, b=&gt;NULL, ""=&gt;1');
  </programlisting>

  <para>
   En utilisant une table&nbsp;:
  </para>
  <programlisting>
SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;
  </programlisting>

  <para>
   Statistiques en ligne&nbsp;:
  </para>
  <programlisting>
SELECT key, count(*) FROM
  (SELECT (each(h)).key FROM testhstore) AS stat
  GROUP BY key
  ORDER BY count DESC, key;
    key    | count
-----------+-------
 line      |   883
 query     |   207
 pos       |   203
 node      |   202
 space     |   197
 status    |   195
 public    |   194
 title     |   190
 org       |   189
...................
  </programlisting>
 </sect2>

 <sect2>
  <title>Compatibility</title>

  <para>
   <emphasis>When upgrading from older versions, always load the new
   version of this module into the database before restoring a dump.
   Otherwise, many new features will be unavailable.</emphasis>
  </para>

  <para>
   As of PostgreSQL 9.0, <type>hstore</type> uses a different internal
   representation than previous versions. This presents no obstacle for
   dump/restore upgrades since the text representation (used in the dump) is
   unchanged.
  </para>

  <para>
   In the event of a binary upgrade, upward compatibility is maintained by
   having the new code recognize old-format data. This will entail a slight
   performance penalty when processing data that has not yet been modified by
   the new code. It is possible to force an upgrade of all values in a table
   column by doing an <literal>UPDATE</literal> statement as follows:
  </para>
  <programlisting>
UPDATE tablename SET hstorecol = hstorecol || '';
  </programlisting>

  <para>
   Another way to do it is:
  <programlisting>
ALTER TABLE tablename ALTER hstorecol TYPE hstore USING hstorecol || '';
  </programlisting>
   The <command>ALTER TABLE</command> method requires an exclusive lock on the table,
   but does not result in bloating the table with old row versions.
  </para>

 </sect2>

 <sect2>
  <title>Auteurs</title>

  <para>
   Oleg Bartunov <email>oleg@sai.msu.su</email>, Moscou, Université de Moscou,
   Russie
  </para>

  <para>
   Teodor Sigaev <email>teodor@sigaev.ru</email>, Moscou, Delta-Soft Ltd.,
   Russie
  </para>

  <para>
   Additional enhancements by Andrew Gierth <email>andrew@tao11.riddles.org.uk</email>,
   United Kingdom
  </para>
 </sect2>

</sect1>
