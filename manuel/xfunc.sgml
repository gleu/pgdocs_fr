<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/xfunc.sgml,v 1.16 2005/07/15 06:14:30 guillaume Exp $
-->

 <sect1 id="xfunc">
  <title>Fonctions définies par l'utilisateur</title>

  <indexterm zone="xfunc">
   <primary>fonction</primary>
   <secondary>définie par l'utilisateur</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> propose quatre types de
    fonctions&nbsp;:

   <itemizedlist>
    <listitem>
     <para>
      fonctions en langage de requête (fonctions écrites en <acronym>SQL</acronym>, <xref linkend="xfunc-sql">)
     </para>
    </listitem>
    <listitem>
     <para>
      fonctions en langage de procédures (fonctions écrites, par exemple, en
      <application>PL/pgSQL</> ou <application>PL/Tcl</>,
      <xref linkend="xfunc-pl">)
     </para>
    </listitem>
    <listitem>
     <para>
      fonctions internes (<xref linkend="xfunc-internal">)
     </para>
    </listitem>
    <listitem>
     <para>
      fonctions en langage C (<xref linkend="xfunc-c">)
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Chaque type de fonction peut accepter comme arguments (paramètres) des types
   de base, des types composites ou une combinaison de ceux-ci. De plus, chaque
   sorte de fonction peut renvoyer un type de base ou un type composite. Les
   fonctions pourraient aussi être définies pour renvoyer des ensembles de valeurs
   de base ou de valeurs composites.
  </para>

  <para>
   De nombreuses sortes de fonctions peuvent accepter ou renvoyer certains
   pseudo-types (comme les types polymorphes) mais avec des fonctionnalités
   variées.
   Consultez la description de chaque type de fonction pour plus de détails.
  </para>

  <para>
   Il est plus facile de définir des fonctions <acronym>SQL</acronym> aussi
   allons-nous commencer par celles-ci. La plupart des concepts présentés pour
   les fonctions <acronym>SQL</acronym> seront aussi gérés par les autres types
   de fonctions.
  </para>

  <para>
   Lors de  la lecture de ce chapitre, il peut être utile de consulter la page
   de référence de la commande <xref linkend="sql-createfunction"
   endterm="sql-createfunction-title"> pour mieux
   comprendre les exemples. Quelques exemples extraits de ce chapitre peuvent 
   être trouvés dans les fichiers <filename>funcs.sql</filename> et
   <filename>funcs.c</filename> du répertoire du tutoriel de la distribution
   source de <productname>PostgreSQL</productname>.
  </para>

  </sect1>

  <sect1 id="xfunc-sql">
   <title>Fonctions en langage de requêtes (<acronym>SQL</acronym>)</title>

   <indexterm zone="xfunc-sql">
    <primary>fonction</primary>
    <secondary>définie par l'utilisateur</secondary>
    <tertiary>en SQL</tertiary>
   </indexterm>

   <para>
    Les fonctions SQL exécutent une liste arbitraire d'instructions SQL et
    renvoient le résultat de la dernière requête de cette liste. Dans le cas
    d'un résultat simple (pas d'ensemble), la première ligne du résultat de la
    dernière requête sera renvoyée (gardez à l'esprit que <quote>la première
    ligne</quote> d'un résultat multiligne n'est pas bien définie à moins
    d'utiliser <literal>ORDER BY</>). Si la dernière requête de la liste ne
    renvoie aucune ligne, la valeur NULL est renvoyée.
   </para>

   <para>
    <indexterm><primary>SETOF</><seealso>fonction</></>
    Une fonction SQL peut être déclarée de façon à renvoyer un ensemble (set)
    en spécifiant le type renvoyé par la fonction comme <literal>SETOF
    <replaceable>untype</></literal>.<indexterm><primary>SETOF</></> Dans ce
    cas, toutes les lignes de la dernière requête sont renvoyées. Des détails
    supplémentaires sont donnés plus loin dans ce chapitre.
   </para>

   <para>
    Le corps d'une fonction SQL doit être constitué d'une liste d'une ou
    de plusieurs instructions SQL séparées par des points-virgule. Un
    point-virgule après la dernière instruction est optionnel. Sauf si la
    fonction déclare renvoyer <type>void</>, la dernière instruction doit
    être un <command>SELECT</>.
   </para>

   <para>
    Toute collection de commandes dans le langage <acronym>SQL</acronym> peut
    être assemblée et définie comme une fonction. En plus des requêtes
    <command>SELECT</command>, les commandes peuvent inclure des requêtes de
    modification des données (<command>INSERT</command>,
    <command>UPDATE</command> et <command>DELETE</command>) ainsi que
    d'autres commandes SQL (la seule exception est que vous ne pouvez pas
    placer de commandes <command>BEGIN</>, <command>COMMIT</>,
    <command>ROLLBACK</> ou <command>SAVEPOINT</> dans une fonction
    <acronym>SQL</acronym>). Néanmoins, la commande finale doit être un
    <command>SELECT</command> qui renvoie ce qui a été spécifié comme type
    de retour de la fonction. Autrement, si vous voulez définir une fonction
    SQL qui réalise des actions mais n'a pas de valeur utile à renvoyer,
    vous pouvez la définir comme renvoyant <type>void</>. Dans ce cas, le
    corps de la fonction ne doit pas finir avec un
    <command>SELECT</command>. Par exemple, cette fonction supprime les 
    lignes avec des salaires négatifs depuis la table <literal>emp</>&nbsp;:

<screen>
  CREATE FUNCTION nettoie_emp() RETURNS void AS '
  DELETE FROM emp
  WHERE salaire &lt; 0;
  ' LANGUAGE SQL;
  
  SELECT nettoie_emp();
  
  nettoie_emp
  -----------
  
  (1 row)
</screen>
   </para>

   <para>
    La syntaxe de la commande <command>CREATE FUNCTION</command> requiert que
    le corps de la fonction soit écrit comme une constante de type chaîne.
    Il est habituellement plus agréable d'utiliser les guillemets dollar
    (voir la <xref linkend="sql-syntax-dollar-quoting">) pour cette constante.
    Si vous choisissez d'utiliser la syntaxe habituelle avec des guillemets
    simples, vous devez échapper les marques de guillemet simple
    (<literal>'</>) et les antislashs (<literal>\</>) utilisés dans le corps
    de la fonction, typiquement en les doublant (voir la <xref
    linkend="sql-syntax-strings">).
   </para>

   <para>
   Les arguments de la fonction SQL sont référencés dans le corps de la
   fonction en utilisant la syntaxe suivante.
   <literal>$<replaceable>n</></>:<literal>$1</> se réfère au premier argument,
   <literal>$2</> au second et ainsi de suite. Si un argument est de type
   composite, on utilisera la notation par point, par exemple
   <literal>$1.name</literal>, pour accéder aux attributs de l'argument.
   Les arguments peuvent seulement être utilisés comme valeurs des données, pas
   comme des identifieurs. Du coup, par exemple, ceci est correct&nbsp;:
<programlisting>
INSERT INTO matable VALUES ($1);
</programlisting>
   mais ceci ne fonctionnera pas&nbsp;:
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
   </para>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> sur les types de base</title>

    <para>
    La fonction <acronym>SQL</acronym> la plus simple possible n'a pas
    d'argument et retourne un type de base tel que <type>integer</type>&nbsp;:
<screen>
CREATE FUNCTION un() RETURNS integer AS $$
    SELECT 1 AS resultat;
$$ LANGUAGE SQL;

-- Autre syntaxe pour les chaînes littérales :
CREATE FUNCTION un() RETURNS integer AS '
    SELECT 1 AS resultat;
' LANGUAGE SQL;

SELECT un();

 un
----
  1
</screen>
    </para>

    <para>
    Notez que nous avons défini un alias de colonne avec le nom
    <literal>resultat</> dans le corps de la fonction pour se référer au
    résultat de la fonction mais cet alias n'est pas visible hors de la
    fonction. En effet, le résultat est nommé <literal>un</> au lieu de
    <literal>resultat</>.
    </para>

    <para>
    Il est presque aussi facile de définir des fonctions SQL acceptant des types
    de base comme arguments. Dans l'exemple suivant, remarquez comment nous
    faisons référence aux arguments dans le corps de la fonction avec  
    <literal>$1</> et <literal>$2</>. 

<screen>
CREATE FUNCTION ajoute(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT ajoute(1, 2) AS reponse;

 reponse
---------
      3
</screen>
    </para>

    <para>
    Voici une fonction plus utile, qui pourrait être utilisée pour débiter un
    compte bancaire&nbsp;:

<programlisting>
CREATE FUNCTION tf1 (integer, numeric) RETURNS integer AS $$
    UPDATE banque
        SET balance = balance - $2
        WHERE no_compte = $1;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

    Un utilisateur pourrait exécuter cette fonction pour débiter le compte 17 de
    100&nbsp;000&nbsp;euros ainsi&nbsp;:
<programlisting>SELECT tf1(17, 100.000);</programlisting>
    </para>
    
    <para>
    Dans la pratique, on préférera vraisemblablement un résultat plus utile que
    la constante 1. Une définition plus probable est&nbsp;:

<programlisting>
CREATE FUNCTION tf1 (integer, numeric) RETURNS numeric AS $$
    UPDATE banque
        SET balance = balance - $2
        WHERE no_compte = $1;
    SELECT balance FROM banque WHERE no_compte = $1;
$$ LANGUAGE SQL;
</programlisting>

     qui ajuste le solde et renvoie sa nouvelle valeur.
    </para>

   </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> sur les types composites</title>

    <para>
    Quand nous écrivons une fonction avec des arguments de type composite,
    nous devons non seulement spécifier l'argument utilisé (comme nous
    l'avons fait précédemment avec <literal>$1</> et <literal>$2</literal>),
    mais aussi spécifier l'attribut désiré de cet argument (champ). Par exemple,
    supposons que 
    <type>emp</type> soit le nom d'une table contenant des données sur les
    employés et donc également le nom du type composite correspondant à chaque
    ligne de la table. Voici une fonction <function>double_salaire</function>
    qui calcule ce que serait le salaire de quelqu'un s'il était doublé&nbsp;:

<screen>
CREATE TABLE emp (
    nom         text,
    salaire     numeric,
    age         integer,
    cubicle     point
);

CREATE FUNCTION double_salaire(emp) RETURNS numeric AS $$
    SELECT $1.salaire * 2 AS salaire;
$$ LANGUAGE SQL;

SELECT nom, double_salaire(emp.*) AS reve
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | reve
------+-------
 Bill |  8400
</screen>
    </para>

    <para>
     Notez l'utilisation de la syntaxe <literal>$1.salaire</literal> pour
     sélectionner un champ dans la valeur de la ligne argument. Notez également
     comment la commande <command>SELECT</> utilise <literal>*</> pour
     sélectionner la ligne courante entière de la table comme une valeur composite
     (<literal>emp</literal>). La ligne de la table peut aussi être référencée en
     utilisant seulement le nom de la table ainsi&nbsp;:
<screen>
SELECT nom, double_salaire(emp) AS reve
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     mais cette utilisation est obsolète car elle est facilement obscure.
    </para>

    <para>
	 Quelque fois, il est pratique de construire une valeur d'argument
	 composite en direct. Ceci peut se faire avec la construction 
	 <literal>ROW</>. Par exemple, nous pouvons ajuster les données passées
	 à la fonction&nbsp;:
<screen>
SELECT nom, double_salaire(ROW(nom, salaire*1.1, age, cubicle)) AS reve
	FROM emp;
</screen>
    </para>

    <para>
    Il est aussi possible de construire une fonction qui renvoie un type
    composite. Voici un exemple de fonction renvoyant une seule ligne de type
    <type>emp</type>&nbsp;:

<programlisting>
CREATE FUNCTION nouvel_emp() RETURNS emp AS $$
    SELECT text 'Aucun' AS nom,
        1000.0 AS salaire,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

    Dans cet exemple, nous avons spécifié chacun des attributs avec une valeur
    constante, mais un quelconque calcul aurait pu être substitué à ces
    valeurs. 
    </para>

    <para>
    Notez deux aspects importants à propos de la définition de fonction&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
       L'ordre de la liste du select doit être exactement le même que celui dans
       lequel les colonnes apparaissent dans la table associée au type
       composite (donner des noms aux colonnes dans le corps de la fonction,
       comme nous l'avons 
       fait dans l'exemple, n'a aucune interaction avec le système).
       </para>
      </listitem>
      <listitem>
       <para>
	Vous devez transtyper les expressions pour concorder avec la définition
       du type composite ou bien vous aurez l'erreur suivante&nbsp;:
<screen>
<computeroutput>
ERROR:  function declared to return emp returns varchar instead of text at
column 1
</computeroutput>
</screen>
       </para>
      </listitem>
     </itemizedlist>
    </para>     

    <para>
      Un autre façon de définir la même fonction est&nbsp;:

      <programlisting>
        CREATE FUNCTION nouveau_emp() RETURNS emp AS $$
        SELECT ROW('Aucun', 1000.0, 25, '(2,2)')::emp;
        $$ LANGUAGE SQL;
      </programlisting>
      
      Ici, nous écrivons un <command>SELECT</> qui renvoie seulement une
      colonne du bon type composite. Ceci n'est pas vraiment meilleur dans
      cette situation mais c'est une alternative pratique dans certains cas
      &mdash; par exemple, si nous avons besoin de calculer le résultat en
      appelant une autre fonction qui renvoie la valeur composite désirée.
    </para>     

    <para>
      Nous pourrions appeler cette fonction directement de deux façons&nbsp;:
  
  <screen>
    SELECT nouveau_emp();
    
    nouveau_emp
    --------------------------
    (None,1000.0,25,"(2,2)")
    
    SELECT * FROM nouveau_emp();
    
    nom   | salaire | age | cubicle
    ------+---------+-----+---------
    Aucun |  1000.0 |  25 | (2,2)
  </screen>
  
      La deuxième façon est décrite plus complètement dans la <xref
      linkend="xfunc-sql-table-functions">.
  </para>     
  
  <para>
    Quand vous utilisez une fonction qui renvoie un type composite, vous
    pourriez vouloir seulement un champ (attribut) depuis ce résultat. Vous
    pouvez le faire avec cette syntaxe&nbsp;:

<screen>
SELECT (nouveau_emp()).nom;

 nom
------
 None
</screen>

    Les parenthèses supplémentaires sont nécessaires pour éviter une erreur de
    l'analyseur. Si vous essayez de le faire sans, vous obtiendrez quelque chose
    comme ceci&nbsp;:
    <screen>
SELECT nouveau_emp().nom;
ERROR:  syntax error at or near "." at character 17
LINE 1: SELECT nouveau_emp().nom;
                            ^
</screen>
    </para>

    <para>
    Une autre option est d'utiliser la notation fonctionnelle pour extraire un
    attribut. Une manière simple d'expliquer cela est de dire que nous pouvons
    échanger les notations <literal>attribut(table)</> et
    <literal>table.attribut</>.

<screen>
SELECT nom(nouveau_emp());

 name
------
 None
</screen>

<screen>
-- C'est la même chose que
-- SELECT emp.nom AS leplusjeune FROM emp WHERE emp.age &lt; 30;

SELECT nom(emp) AS leplusjeune FROM emp WHERE age(emp) &lt; 30;

 leplusjeune
-------------
 Sam
 Andy
</screen>
    </para>

    <tip>
    <para>
     L'équivalence entre la notation fonctionnelle et la notation d'attribut
     rend possible l'utilisation de fonctions sur des types composites pour
     émuler les <quote>champs calculés</>.
     <indexterm>
      <primary>champ calculé</primary>
     </indexterm>
     <indexterm>
      <primary>field</primary>
      <secondary>computed</secondary>
     </indexterm>
     Par exemple, en utilisant la définition précédente pour
     <literal>double_salaire(emp)</>, nous pouvons écrire
<screen>
SELECT emp.nom, emp.double_salaire FROM emp;
</screen>

     Une application utilisant ceci n'aurait pas besoin d'être consciente
     directement que <literal>double_salaire</> n'est pas une vraie colonne
     de la table. (Vous pouvez aussi émuler les champs calculés avec des
     vues.)
    </para>
    </tip>

    <para>
     Une autre façon d'utiliser une fonction renvoyant un résultat ligne est
     de passer le résultat à une autre fonction qui accepte le bon type
     ligne en entrée&nbsp;:

<screen>
CREATE FUNCTION recupnom(emp) RETURNS text AS $$
    SELECT $1.nom;
$$ LANGUAGE SQL;

SELECT recupnom(nouveau_emp());
 recupnom
----------
 Aucun
(1 row)
</screen>
    </para>

    <para>
    Une autre façon d'utiliser une fonction qui renvoie une type composite est
    de l'appeler comme une fonction de table (décrite ci-dessous).
    </para>
   </sect2>

   <sect2 id="xfunc-sql-table-functions">
    <title>Fonctions <acronym>SQL</acronym> comme sources de table</title>

    <para>
    Toutes les fonctions SQL peuvent être utilisées dans la clause
    <literal>FROM</> d'une requête mais ceci est particulièrement utile pour les
    fonctions renvoyant des types composite. Si la fonction est définie pour
    renvoyer un type de base, la fonction table produit une table d'une seule
    colonne. Si la fonction est définie pour renvoyer un type composite, la
    fonction  table produit une colonne pour chaque attribut du type composite.
   </para>

    <para>
     Voici un exemple&nbsp;:

<screen>
CREATE TABLE foo (fooid int, foosousid int, foonom text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION recupfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(2 rows)
</screen>

    Comme le montre cet exemple, nous pouvons travailler avec les colonnes du
    résultat de la fonction comme s'il s'agissait des colonnes d'une table
    normale.
</para>

    <para>
    Notez que nous n'obtenons qu'une ligne comme résultat de la fonction. Ceci
    parce que nous n'avons pas utilisé l'instruction <literal>SETOF</>. Cette
    instruction est décrite dans la prochaine section.
    </para>
   </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> renvoyant un ensemble </title>

    <para>
     Quand une fonction SQL est déclarée renvoyer un <literal>SETOF
     <replaceable>un_type</></literal>, la requête finale <command>SELECT</> de
     la fonction est complètement exécutée et chaque ligne extraite est renvoyée
     en tant qu'élément de l'ensemble résultat.
    </para>
    
    <para>
     Cette caractéristique est normalement utilisée lors de l'appel d'une
     fonction dans une clause <literal>FROM</>. Dans ce cas, chaque ligne
     renvoyée par la fonction devient une ligne de la table vue par la requête.
     Par exemple, supposons que la table <literal>foo</> ait le même contenu que
     précédemment et écrivons&nbsp;:

<programlisting>
CREATE FUNCTION recupfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM recupfoo(1) AS t1;
</programlisting>

     Alors nous obtenons&nbsp;:
<screen>
 fooid | foosousid | foonom
-------+-----------+--------
     1 |         1 | Joe
     1 |         2 | Ed
(2 rows)
</screen>
    </para>

    <para>
     Actuellement, les fonctions renvoyant des ensembles peuvent aussi être
     appelées dans la liste du select d'une requête. Pour chaque ligne générée
     par la requête, la fonction renvoyant un ensemble est appelée et une ligne
     est générée pour chaque élément de l'ensemble résultat. Notez cependant que
     cette fonctionnalité est déconseillée et pourra être supprimée dans une
     version future. Voici un exemple de fonction renvoyant un ensemble à
     partir de la liste d'un SELECT&nbsp;:

<screen>
CREATE FUNCTION listeenfant(text) RETURNS SETOF text AS $$
    SELECT nom FROM noeuds WHERE parent = $1
$$ LANGUAGE SQL;

SELECT * FROM noeuds;
   nom        | parent
--------------+--------
 Haut         |
 Enfant1      | Haut
 Enfant2      | Haut
 Enfant3      | Haut
 Sous-Enfant1 | Enfant1
 Sous-Enfant2 | Enfant1
(6 rows)

SELECT listeenfant('Haut');
 listeenfant
--------------
 Enfant1
 Enfant2
 Enfant3
(3 rows)

SELECT nom, listeenfant(nom) FROM noeuds;
  nom    | listeenfant
---------+--------------
 Haut    | Enfant1
 Haut    | Enfant2
 Haut    | Enfant3
 Enfant1 | Sous-Enfant1
 Enfant1 | Sous-Enfant2
(5 rows)
</screen>

     Notez, dans le dernier <command>SELECT</command>, qu'aucune ligne n'est
     renvoyée pour <literal>Enfant2</>, <literal>Enfant3</>, etc. C'est parce
     que la fonction <function>listeenfant</function> renvoie un ensemble vide
     pour ces arguments et ainsi aucune ligne n'est générée.
 </para>
    </sect2>

   <sect2>
    <title>Fonctions <acronym>SQL</acronym> polymorphes</title>

    <para>
     Les fonctions <acronym>SQL</acronym> peuvent être déclarées pour accepter
     et renvoyer les types <quote>polymorphe</> <type>anyelement</type> et
     <type>anyarray</type>. Voir la <xref linkend="types-polymorphic"> pour une
     explication plus approfondie. Voici une fonction polymorphe
     <function>cree_tableau</function> qui construit un tableau à partir de
     deux éléments de type arbitraire&nbsp;:

<screen>
CREATE FUNCTION cree_tableau(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;
SELECT cree_tableau(1, 2) AS tableau_entier, cree_tableau('a'::text, 'b') AS
tableau_texte;

 tableau_entier | tableau_texte
----------------+---------------
 {1,2}          | {a,b}
(1 row)
</screen>
    </para>

    <para>
     Notez l'utilisation du transtypage <literal>'a'::text</literal> pour
     spécifier le type <type>text</type> de l'argument. Ceci est nécessaire si
     l'argument est une chaîne de caractères car, autrement, il serait traité
     comme un type  <type>unknown</type>, et un tableau de type
     <type>unknown</type> n'est pas un type valide. Sans le transtypage, vous
     obtiendrez ce genre d'erreur&nbsp;:

<screen>
<computeroutput>
ERROR:  could not determine ANYARRAY/ANYELEMENT type because input is UNKNOWN
</computeroutput>
</screen>
    </para>

    <para>
     Il est permis d'avoir des arguments polymorphes avec un type de renvoi
     fixe, mais non l'inverse. Par exemple&nbsp;:

<screen>
CREATE FUNCTION est_plus_grand(anyelement, anyelement) RETURNS bool AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT est_plus_grand(1, 2);
 est_plus_grand
----------------
 f
(1 row)

CREATE FUNCTION fonction_invalide() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result datatype
DETAIL:  A function returning ANYARRAY or ANYELEMENT must have at least one
argument of either type.
</screen>
    </para>
   </sect2>
  </sect1>

  <sect1 id="xfunc-overload">
    <title>Surcharge des fonctions</title>
    
    <indexterm zone="xfunc-overload">
      <primary>surcharge</primary>
      <secondary>fonctions</secondary>
    </indexterm>
    
    <para>
      Plusieurs fonctions peuvent être définies avec le même nom SQL à condition
      que les arguments soient différents. En d'autres termes, les noms de
      fonction peuvent être <firstterm>surchargés</firstterm>. Quand une
      requête est exécutée, le serveur déterminera la fonction à appeler à
      partir des types de données des arguments et du nombre d'arguments. La
      surcharge peut aussi être utilisée pour simuler des fonctions avec un
      nombre variable d'arguments jusqu'à un nombre maximum fini.
    </para>
    
    <para>
      Lors de la création d'une famille de fonctions surchargées, vous devriez
      être attentif à ne pas créer d'ambiguïtés. Par exemple, avec les
      fonctions
      <programlisting>
        CREATE FUNCTION test(int, real) RETURNS ...
        CREATE FUNCTION test(smallint, double precision) RETURNS ...
      </programlisting>
      Savoir quelle fonction sera appelée avec une entrée triviale comme
      <literal>test(1, 1.5)</literal> n'est pas immédiatement clair. Les
      règles de résolution actuellement implémentées sont décrites dans le
      <xref linkend="typeconv"> mais il est déconseillé de concevoir un
      système qui serait basé subtilement sur ce comportement.
      </para>
      
      <para>
        Une fonction qui prend un seul argument d'un type composite devrait
        généralement ne pas avoir le même nom que tout attribut (champ) de
        ce type. Rappellez-vous que <literal>attribut(table)</literal> est
        considéré comme équivalent à <literal>table.attribut</literal>. Dans
        le cas où il existe une ambiguïté entre une fonction sur un type
        composite et sur un attribut d'un type composite, l'attribut sera
        toujours utilisé. Il est possible de contourner ce choix en
        qualifiant le nom de la fonction avec celui du schéma (c'est-à-dire
        <literal>schema.fonction(table)</literal>) mais il est préférable
        d'éviter le problème en ne choisissant aucun nom conflictuel.
      </para>
      
      <para>
        Lors de la surcharge de fonctions en langage C, il existe une
        contrainte supplémentaire&nbsp;: le nom C de chaque fonction dans la
        famille des fonctions surchargées doit être différent des noms C de
        toutes les autres fonctions, soit internes soit chargées dynamiquement
        Si cette règle est violée, le comportement n'est pas portable. Vous
        pourriez obtenir une erreur de l'éditeur de lien ou une des fonctions
        sera appelée (habituellement l'interne). L'autre forme de clause
        <literal>AS</> pour la commande SQL <command>CREATE
        FUNCTION</command> découple le nom de la fonction SQL à partir du 
        nom de la fonction dans le code source C. Par exemple,
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</>', 'test_1arg'
LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</>', 'test_2arg'
LANGUAGE C;
</programlisting>
        Les noms des fonctions C reflètent ici une des nombreuses conventions
        possibles.
      </para>
  </sect1>

  <sect1 id="xfunc-volatility">
    <title>Catégories de volatibilité des fonctions</title>
  
    <indexterm zone="xfunc-volatility">
      <primary>volatibilité</primary>
      <secondary>fonctions</secondary>
    </indexterm>
    <indexterm zone="xfunc-volatility">
      <primary>VOLATILE</primary>
    </indexterm>
    <indexterm zone="xfunc-volatility">
      <primary>STABLE</primary>
    </indexterm>
    <indexterm zone="xfunc-volatility">
      <primary>IMMUTABLE</primary>
    </indexterm>
  
  <para>
    Chaque fonction a une classification <firstterm>volatility</> comprenant
    <literal>VOLATILE</>, <literal>STABLE</> ou <literal>IMMUTABLE</>.
    <literal>VOLATILE</> est la valeur par défaut si la commande
    <command>CREATE FUNCTION</command> ne spécifie pas de catégorie. La
    catégorie de volatibilité est une promesse à l'optimiseur sur le
    comportement de la fonction&nbsp;:

  <itemizedlist>
    <listitem>
    <para>
      Une fonction <literal>VOLATILE</> peut tout faire, y compris modifier
      la base de données. Elle peut renvoyer différents
      résultats sur des appels successifs avec les mêmes arguments.
      L'optimiseur ne fait aucune supposition sur le comportement de telles
      fonctions. Une requête utilisant une fonction volatile ré-évaluera la
      fonction à chaque ligne où sa valeur est nécessaire.
    </para>
    </listitem>
    <listitem>
    <para>
      Une fonction <literal>STABLE</> ne peut pas modifier la base de
      données et est garantie de renvoyer les mêmes résultats si elle est
      appelée avec les mêmes arguments pour tous les appels à l'intérieur
      d'une même requête. Cette catégorie permet à l'optimiseur d'optimiser
      plusieurs appels de la fonction dans une seule requête. En particulier,
      vous pouvez utiliser en toute sécurité une expression contenant une
      telle fonction dans une condition de parcours d'index (car un parcours
      d'index évaluera la valeur de la comparaison une seule fois, pas une
      fois pour chaque ligne, utiliser une fonction <literal>VOLATILE</> dans
      une condition de parcours d'index n'est pas valide).
    </para>
    </listitem>
    <listitem>
    <para>
      Une fonction <literal>IMMUTABLE</> ne peut pas modifier la base de
      données et est garantie de toujours renvoyer les mêmes résultats si
      elle est appelée avec les mêmes arguments. Cette catégorie permet à 
      l'optimiseur de pré-évaluer la fonction quand une requête l'appelle
      avec des arguments constants. Par exemple, une requête comme
      <literal>SELECT ... WHERE x = 2 + 2</> peut être simplifiée pour
      obtenir <literal>SELECT ... WHERE x = 4</> car la fonction sous-jacente
      de l'opérateur d'addition est indiquée <literal>IMMUTABLE</>.
    </para>
    </listitem>
  </itemizedlist>

  </para>

  <para>
    Pour une meilleure optimisation des résultats, vous devez mettre un label
    sur les fonctions avec la catégorie la plus volatile valide pour elles.
  </para>

  <para>
    Toute fonction avec des effets de bord <emphasis>doit</> être indiquée
    comme <literal>VOLATILE</>, de façon à ce que les appels ne puissent pas
    être optimisés. Même une fonction sans effets de bord doit être indiquée
    comme <literal>VOLATILE</> si sa valeur peut changer à l'intérieur
    d'une seule requête&nbsp;; quelques exemples sont <literal>random()</>,
    <literal>currval()</>, <literal>timeofday()</>.
  </para>

  <para>
    Il y a relativement peu de différences entre les catégories 
    <literal>STABLE</> et <literal>IMMUTABLE</> en considérant les requêtes
    interactives qui sont planifiées et immédiatement exécutées&nbsp;: il 
    importe peu que la fonction soit exécutée une fois lors de la
    planification ou une fois au lancement de l'exécution de la requête mais
    cela fait une grosse différence si le plan est sauvegardé et utilisé plus
    tard. Placer un label <literal>IMMUTABLE</> sur une fonction quand elle
    ne l'est pas vraiment pourrait avoir comme conséquence de la considérer
    prématurément comme une constante lors de la planification et résulterait en une valeur
    erronée lors d'une utilisation ultérieure de ce plan d'exécution. 
    C'est un danger qui arrive lors de l'utilisattion d'instructions préparées
    ou avec l'utilisation de langages de fonctions mettant les plans d'exécutions
    en cache (comme
    <application>PL/pgSQL</>).
  </para>

  <para>
    À cause du comportement à base d'images de MVCC (voir le <xref
    linkend="mvcc">), une fonction contenant seulement des commandes
    <command>SELECT</> peut être indiquée <literal>STABLE</> en toute sécurité
    même s'il sélectionne des données à partir de tables qui pourraient
    avoir subi des modifications entre temps par des requêtes concurrentes.
    <productname>PostgreSQL</productname> exécutera une fonction
    <literal>STABLE</> en utilisant l'image établie par la requête appelante et
    n'aura qu'une vision figée de la base de données au cours de la requête.
    Notez aussi que la famille de fonctions <function>current_timestamp</>
    est qualifiée de stable car leurs valeurs ne changent pas dans une
    transaction.
  </para>

  <para>
    Ce même comportement d'images est utilisé pour les commandes
    <command>SELECT</> à l'intérieur de fonctions <literal>IMMUTABLE</>. Il
    est généralement déconseillé de sélectionner des tables de la base de
    données à l'intérieur de fonctions <literal>IMMUTABLE</> car
    l'immutabilité sera rompue si le contenu de la table change. Néanmoins,
    <productname>PostgreSQL</productname> ne vous force pas à ne pas le faire.
  </para>

  <para>
    Une erreur commune est de placer un label sur une fonction
    <literal>IMMUTABLE</> quand son résultat dépend d'un paramètre de
    configuration. Par exemple, une fonction qui manipule des types date/heure
    pourrait bien avoir des résultats dépendant du paramètre
    <xref linkend="guc-timezone">. Pour être sécurisées, de telles
    fonctions devraient avoir le label <literal>STABLE</> à la place.
  </para>

  <note>
    <para>
      Avant <productname>PostgreSQL</productname> version 8.0, le prérequis
      que les fonctions <literal>STABLE</> et
      <literal>IMMUTABLE</> ne pouvaient pas modifier la base de données
      n'était pas contraint par le système. La version 8.0 le contraint en
      réclamant que les fonctions SQL et les fonctions de langages de
      procédures de ces catégories ne contiennent pas de commandes SQL autre
      que <command>SELECT</> (ceci n'a pas été complètement testé car de
      telles fonctions pourraient toujours appeler des fonctions
      <literal>VOLATILE</> qui modifient la base de données. Si vous le
      faites, vous trouverez que la fonction <literal>STABLE</> ou
      <literal>IMMUTABLE</> n'est pas au courant des modifications
      effectuées sur la base de données par la fonction appelée).
    </para>
  </note>
  </sect1>

  <sect1 id="xfunc-pl">
   <title>Fonctions en langage de procédures</title>

   <para>
    <productname>PostgreSQL</productname> autorise l'écriture de fonctions
    définies par l'utilisateur dans d'autres langages que SQL et C. Ces autres
    langages sont appelés des <firstterm>langages de procédure</firstterm>
    (<acronym>PL</>). Les langages de procédures ne sont pas compilés dans le
    serveur <productname>PostgreSQL</productname>&nbsp;; ils sont fournis comme
    des modules chargeables. Voir le <xref linkend="xplang"> et les chapitres
    suivants pour plus d'informations.
   </para>

   <para>
    Il y a actuellement quatre langages de procédures disponibles dans la
    distribution <productname>PostgreSQL</productname> standard&nbsp;:
     <application>PL/pgSQL</application>, <application>PL/Tcl</application>,
     <application>PL/Perl</application> et <application>PL/Python</application>.
 
    Référez-vous au <xref linkend="xplang"> pour plus d'informations. D'autres
    langages peuvent être définis par les utilisateurs. Les bases du
    développement d'un nouveau langage de procédures sont traitées dans le <xref
    linkend="plhandler">.   
   </para> 
 
 </sect1>
 
 <sect1 id="xfunc-internal">
   <title>Fonctions internes</title>

   <indexterm zone="xfunc-internal"><primary>fonction</><secondary>interne</></>

   <para>
    Les fonctions internes sont des fonctions écrites en C qui ont été liées de
    façon statique dans le serveur <productname>PostgreSQL</productname>. Le
    <quote>corps</quote> de la définition de la fonction spécifie le nom en 
    langage C de la fonction, qui n'est pas obligatoirement le même que le nom
    déclaré pour l'utilisation en SQL (pour des raisons de rétro compatibilité,
    un corps vide est accepté pour signifier que le nom de la fonction en
    langage C est le même que le nom SQL).

   </para>

   <para>
    Normalement, toutes les fonctions internes présentes dans le serveur sont
    déclarées pendant l'initialisation du groupe de base de données
    (<command>initdb</command>) mais un utilisateur peut utiliser la commande  
    <command>CREATE FUNCTION</command> pour créer des noms d'alias
    supplémentaires pour une fonction interne. Les fonctions internes sont
    déclarées dans la commande <command>CREATE FUNCTION</command> avec le nom
    de langage <literal>internal</literal>. Par exemple, pour créer un alias
    de la fonction <function>sqrt</function>&nbsp;:

<programlisting>
CREATE FUNCTION racine_carree(double precision) RETURNS double precision    AS
'dsqrt'    
LANGUAGE internal    STRICT;
</programlisting>

    (la plupart des fonctions internes doivent être déclarées
    <quote>STRICT</quote>)
   </para>

   <note>
    <para>
     Toutes les fonctions <quote>prédéfinies</quote> ne sont pas internes (au
     sens explicité ci-dessus). Quelques fonctions prédéfinies sont écrites en
     SQL.
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-c">
   <title>Fonctions en langage C</title>

   <indexterm zone="xfunc-sql">
    <primary>fonction</primary>
    <secondary>définie par l'utilisateur</secondary>
    <tertiary>en C</tertiary>
   </indexterm>

   <para>
    Les fonctions définies par l'utilisateur peuvent être écrites en C (ou dans
    un langage pouvant être rendu compatible avec C, comme le C++). Ces fonctions
    sont compilées en objets dynamiques chargeables (encore appelés
    bibliothèques partagées) et sont chargées par le serveur à la demande. Cette
    caractéristique de chargement dynamique est ce qui distingue les fonctions
    en <quote>langage C</> des fonctions <quote>internes</> &mdash; les véritables
    conventions de codage sont essentiellement les mêmes pour les deux (c'est
    pourquoi la bibliothèque standard de fonctions internes est une source
    abondante d'exemples de code pour les fonctions C définies par
    l'utilisateur).
  </para>
  
  <para>
    Deux différentes conventions d'appel sont actuellement en usage pour les
    fonctions C. La plus récente, <quote>version 1</quote>,
    est indiquée en écrivant une macro d'appel
    <literal>PG_FUNCTION_INFO_V1()</literal> comme illustré ci-après. L'absence
    d'une telle macro indique une fonction écrite selon l'ancien style
    (<quote>version 0</quote>). Le nom de langage spécifié dans la commande 
    <command>CREATE FUNCTION</command> est <literal>C</literal> dans les deux
    cas. Les fonctions suivant l'ancien style sont maintenant déconseillées en
    raison de problèmes de portabilité et d'un manque de fonctionnalité mais
    elles sont encore supportées pour des raisons de compatibilité.
 </para>  
 
  <sect2 id="xfunc-c-dynload">
   <title>Chargement dynamique</title>

   <indexterm zone="xfunc-c-dynload">
    <primary>dynamic loading</primary>
   </indexterm>
   
   <para>
    La première fois qu'une fonction définie par l'utilisateur dans un fichier
    objet particulier chargeable est appelée dans une session, le chargeur
    dynamique charge ce fichier objet en mémoire de telle sorte que la fonction 
    peut être appelée. La commande <command>CREATE FUNCTION</command> pour une
    fonction en C définie par l'utilisateur doit par conséquent spécifier deux
    éléments d'information pour la fonction&nbsp;: le nom du fichier objet
    chargeable et le nom en C (lien symbolique) de la fonction spécifique à
    appeler à l'intérieur de ce fichier objet. Si le nom en C n'est pas
    explicitement spécifié, il est supposé être le même que le nom de la
    fonction SQL. 
  </para> 
  
  <para>
    L'algorithme suivant, basé sur le nom donné dans la commande
    <command>CREATE FUNCTION</command>, est utilisé pour localiser le fichier
    objet partagé&nbsp;:

    <orderedlist>
     <listitem>
      <para>
       Si le nom est un chemin absolu, le fichier est chargé.
      </para>
     </listitem>

     <listitem>
      <para>
       Si le nom commence par la chaîne <literal>$libdir</literal>, cette chaîne
       est remplacée par le nom du répertoire de la bibliothèque du paquetage
       <productname>PostgreSQL</>, qui est déterminé au moment de la 
       compilation. <indexterm><primary>$libdir</></>
      </para>
     </listitem>

     <listitem>
      <para>
       Si le nom ne contient pas de partie répertoire, le fichier est recherché
       par le chemin spécifié dans la variable de configuration
       <xref linkend="guc-dynamic-library-path">.<indexterm><primary>dynamic_library_path</></>
      </para>
     </listitem>

     <listitem>
      <para>
       Dans les autres cas, (nom de fichier non trouvé dans le chemin ou ne
       contenant pas de partie répertoire non absolu), le chargeur dynamique
       essaiera d'utiliser le nom donné, ce qui échouera très vraisemblablement
       (dépendre du répertoire de travail en cours n'est pas fiable).
      </para>
     </listitem>
    </orderedlist>

    Si cette séquence ne fonctionne pas, l'extension pour les noms de fichier
    des bibliothèques partagées spécifique à la plateforme (souvent
    <filename>.so</filename>) est ajoutée au nom attribué et la séquence est à
    nouveau tentée. En cas de nouvel échec, le chargement échoue. 
 </para>

    <para>
     L'identifiant utilisateur sous lequel fonctionne le serveur
     <productname>PostgreSQL</productname> doit pouvoir suivre le chemin
     jusqu'au fichier que vous essayez de charger. Une erreur fréquente revient
     à définir le fichier ou un répertoire supérieur comme non lisible et/ou
     non exécutable par l'utilisateur <systemitem>postgres</systemitem>.
    </para>

   <para>
    Dans tous les cas, le nom de fichier donné dans la commande <command>CREATE
    FUNCTION</command> est enregistré littéralement dans les catalogues
    systèmes, de sorte que, si le fichier doit être à nouveau chargé, la même 
    procédure sera appliquée.
 </para>

   <note>
    <para>
     <productname>PostgreSQL</productname> ne compilera pas une fonction C
     automatiquement. Le fichier objet doit être compilé avant d'être référencé
     dans une commande <command>CREATE FUNCTION</>. Voir la <xref
    linkend="dfunc"> pour des informations complémentaires. 
   </para>
   </note>

   <para>
    Après avoir été utilisé pour la première fois, un fichier objet chargé
    dynamiquement est conservé en mémoire. Les futurs appels de fonction(s) dans
    ce fichier pendant la même session provoqueront seulement une légère
    surcharge due à la consultation d'une table de symboles. Si vous devez
    forcer le chargement d'un fichier objet, par exemple après une
    recompilation, utilisez la commande <command>LOAD</> ou commencez une
    nouvelle session.  
  </para>

   <para>
    Il est recommandé de localiser les bibliothèques dynamiques soit
    relativement à <literal>$libdir</literal> soit au moyen du chemin des
    bibliothèques dynamiques. Ceci simplifie la mise à jour dans le cas d'une
    nouvelle installation dans un endroit différent. Le répertoire effectif
    représenté par <literal>$libdir</literal> peut être retrouvé avec la
    commande <literal>pg_config --pkglibdir</literal>.  
   </para>

   <para>
    Avant la version 7.2 de <productname>PostgreSQL</productname>, seuls les
    chemins absolus exacts pouvaient être spécifiés dans la commande
    <command>CREATE FUNCTION</>. Cette approche est maintenant déconseillée car
    elle rend la définition de la fonction inutilement non portable. Il vaut
    mieux seulement spécifier le nom de la bibliothèque partagée sans chemin ni
    extension, et laisser le mécanisme de recherche générer cette information. 
   </para> 

  </sect2>

   <sect2 id="xfunc-c-basetype">
    <title>Types de base dans les fonctions en langage C</title>

    <indexterm zone="xfunc-c-basetype">
     <primary>type de données</primary>
     <secondary>organisation interne</secondary>
    </indexterm>

    <para>
     Pour savoir comment écrire des fonctions en langage C, vous devez savoir 
     comment <productname>PostgreSQL</productname> représente en interne les
     types de données de base et comment elles peuvent être passés vers et
     depuis les fonctions. En interne, <productname>PostgreSQL</productname>
     considère un type de base comme un <quote>blob de mémoire</quote>. Les
     fonctions que vous définissez sur un type définissent à leur tour la façon
     que <productname>PostgreSQL</productname> opère sur lui. C'est-à-dire
     que <productname>PostgreSQL</productname> ne fera que conserver et retrouver
     les données sur le disque et utilisera votre fonction pour entrer, traiter
     et restituer les données.
    </para>
    
    <para>
     Les types de base peuvent avoir un des trois formats internes
     suivants&nbsp;:
     <itemizedlist>
      <listitem>
       <para>
	passage par valeur, longueur fixe&nbsp;;
       </para>
      </listitem>
      <listitem>
       <para>
	passage par référence, longueur fixe&nbsp;;
       </para>
      </listitem>
      <listitem>
       <para>
	passage par référence, longueur variable.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Les types par valeur peuvent seulement avoir une longueur de 1, 2 ou 4
     octets (également 8 octets si <literal>sizeof(Datum)</literal> est de huit
     octets sur votre machine). Vous devriez être attentif lors de la
     définition de vos types de sorte à qu'ils aient la même taille sur toutes
     les architectures. Par exemple, le type <literal>long</literal> est
     dangereux car il a une taille de quatre octets sur certaines machines et
     huit octets sur d'autres, alors que le type <type>int</type> est de quatre
     octets sur la plupart des machines Unix. Une implémentation raisonnable du
     type <type>int4</type> sur une machine Unix pourrait être
 
 <programlisting>
/* entier sur quatre octets, passé par valeur */
typedef int int4;
</programlisting>

    </para>

    <para>
     D'autre part, les types à longueur fixe d'une taille quelconque peuvent
     être passés par référence. Par exemple, voici l'implémentation d'un type
     <productname>PostgreSQL</productname>&nbsp;:

<programlisting>
/* structure de 16 octets, passée par référence */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     Seuls des pointeurs vers de tels types peuvent être utilisés en les passant
     dans et hors des fonctions <productname>PostgreSQL</productname>. Pour
     renvoyer une valeur d'un tel type, allouez la quantité appropriée de
     mémoire avec <literal>palloc</literal>, remplissez la mémoire allouée et
     renvoyez un pointeur vers elle. (Vous pouvez aussi renvoyer directement une
     valeur d'entrée qui a le même type que la valeur de retour en renvoyant le
     pointeur vers la valeur d'entrée. Cependant, <emphasis>ne jamais</>
     modifier le contenu d'une valeur d'entrée passée par référence.)
    </para>

    <para>
     Enfin, tous les types à longueur variable doivent aussi être passés par
     référence. Tous les types à longueur variable doivent commencer avec un
     champ d'une longueur d'exactement quatre octets et toutes les données
     devant être stockées dans ce type doivent être localisées dans la mémoire à
     la suite immédiate de ce champ longueur. Le champ longueur contient la
     longueur totale de la structure, c'est-à-dire incluant la longueur du
     champ longueur lui-même.
    </para>

    <para>
     Comme exemple, nous pouvons définir le type <type>text</type> comme
     ceci&nbsp;:

<programlisting>
typedef struct {
    int4 length;
    char data[1];
} text;
</programlisting>

     Il est évident que le champ déclaré ici n'est pas assez long pour contenir
     toutes les chaînes possibles. Comme il est impossible de déclarer une
     structure de taille variable en <acronym>C</acronym>, nous nous appuyons
     sur le fait que le compilateur  <acronym>C</acronym> ne vérifie pas la
     plage des indices de tableau. Nous allouons juste la quantité d'espace
     nécessaire et ensuite nous accédons au tableau comme s'il avait été déclaré
     avec la bonne longueur (c'est une astuce courante que vous pouvez trouver
     dans beaucoup de manuels de C).
    </para>
    
    <para>
     En manipulant les types à longueur variable, nous devons être attentifs à
     allouer la quantité correcte de mémoire et à fixer correctement le champ
     longueur. Par exemple, si nous voulons stocker 40 octets dans une structure
     <structname>text</>, nous devrions utiliser un fragment de code comme
     celui-ci&nbsp;:

<programlisting>
#include "postgres.h"
...
char buffer[40]; /* notre donnée source */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&gt;length = VARHDRSZ + 40;
memcpy(destination-&gt;data, buffer, 40);
...
</programlisting>

     <literal>VARHDRSZ</> est équivalent à <literal>sizeof(int4)</> mais
     est considéré comme une meilleure tournure de référence à la taille de
     l'overhead pour un type à longueur variable.
    </para>

    <para>
     Le <xref linkend="xfunc-c-type-table"> spécifie la correspondance entre
     les types C et les types SQL quand on écrit une fonction en langage C
     utilisant les types internes de <productname>PostgreSQL</>. La colonne
     <quote>Défini dans</quote> donne le fichier d'en-tête devant être inclus
     pour accéder à la définition du type (la définition effective peut se
     trouver dans un fichier différent inclus dans le fichier indiqué. Il
     est recommandé que les utilisateurs s'en tiennent à l'interface définie).
     Notez que vous devriez toujours inclure <filename>postgres.h</filename> en
     premier dans tout fichier source car il déclare un grand nombre d'éléments
     dont vous aurez besoin de toute façon. 
    </para>
    
    <table tocentry="1" id="xfunc-c-type-table">
      <title>Équivalence des types C et des types SQL intégrés</title>
      <tgroup cols="3">
       <thead>
	<row>
	 <entry>
	  Type SQL
	 </entry>
	 <entry>
	  Type C
	 </entry>
	 <entry>
	  Défini dans
	 </entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry><type>abstime</type></entry>
	 <entry><type>AbsoluteTime</type></entry>
	 <entry><filename>utils/nabstime.h</filename></entry>
	</row>
	<row>
	 <entry><type>boolean</type></entry>
	 <entry><type>bool</type></entry>
	 <entry><filename>postgres.h</filename> (intégration au
	  compilateur)</entry>
	</row>
	<row>
	 <entry><type>box</type></entry>
	 <entry><type>BOX*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>bytea</type></entry>
	 <entry><type>bytea*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>"char"</type></entry>
	 <entry><type>char</type></entry>
	 <entry>(intégré au compilateur)</entry>
	</row>
	<row>
	 <entry><type>character</type></entry>
	 <entry><type>BpChar*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>cid</type></entry>
	 <entry><type>CommandId</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>date</type></entry>
	 <entry><type>DateADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>smallint</type> (<type>int2</type>)</entry>
	 <entry><type>int2</type> or <type>int16</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>int2vector</type></entry>
	 <entry><type>int2vector*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>integer</type> (<type>int4</type>)</entry>
	 <entry><type>int4</type> or <type>int32</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>real</type> (<type>float4</type>)</entry>
	 <entry><type>float4*</type></entry>
	<entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>double precision</type> (<type>float8</type>)</entry>
	 <entry><type>float8*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>interval</type></entry>
	 <entry><type>Interval*</type></entry>
	 <entry><filename>utils/timestamp.h</filename></entry>
	</row>
	<row>
	 <entry><type>lseg</type></entry>
	 <entry><type>LSEG*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>name</type></entry>
	 <entry><type>Name</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>oid</type></entry>
	 <entry><type>Oid</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>oidvector</type></entry>
	 <entry><type>oidvector*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>path</type></entry>
	 <entry><type>PATH*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>point</type></entry>
	 <entry><type>POINT*</type></entry>
	 <entry><filename>utils/geo_decls.h</filename></entry>
	</row>
	<row>
	 <entry><type>regproc</type></entry>
	 <entry><type>regproc</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>reltime</type></entry>
	 <entry><type>RelativeTime</type></entry>
	 <entry><filename>utils/nabstime.h</filename></entry>
	</row>
	<row>
	 <entry><type>text</type></entry>
	 <entry><type>text*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>tid</type></entry>
	 <entry><type>ItemPointer</type></entry>
	 <entry><filename>storage/itemptr.h</filename></entry>
	</row>
	<row>
	 <entry><type>time</type></entry>
	 <entry><type>TimeADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>time with time zone</type></entry>
	 <entry><type>TimeTzADT</type></entry>
	 <entry><filename>utils/date.h</filename></entry>
	</row>
	<row>
	 <entry><type>timestamp</type></entry>
	 <entry><type>Timestamp*</type></entry>
	 <entry><filename>utils/timestamp.h</filename></entry>
	</row>
	<row>
	 <entry><type>tinterval</type></entry>
	 <entry><type>TimeInterval</type></entry>
	 <entry><filename>utils/nabstime.h</filename></entry>
	</row>
	<row>
	 <entry><type>varchar</type></entry>
	 <entry><type>VarChar*</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
	<row>
	 <entry><type>xid</type></entry>
	 <entry><type>TransactionId</type></entry>
	 <entry><filename>postgres.h</filename></entry>
	</row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Maintenant que nous avons passé en revue toutes les structures possibles
     pour les types de base, nous pouvons donner quelques exemples de vraies
     fonctions.
 </para>
   </sect2>

   <sect2>
    <title>Conventions d'appel de la version 0 pour les fonctions en langage
     C</title>

    <para>
     Nous présentons l'<quote>ancien style</quote> de convention d'appel en
     premier &mdash; bien que cette approche soit maintenant déconseillée, elle est
     plus facile à maîtriser au début. Dans la méthode version-0, les arguments
     et résultats de la fonction C sont simplement déclarés dans le style C
     normal mais en faisant attention à utiliser la représentation C de chaque
     type de données SQL comme montré ci-dessus.
    </para>

    <para>
     Voici quelques exemples&nbsp;:

<programlisting>
#include "postgres.h"
#include &lt;string.h&gt;

/* par valeur */
         
int
add_one(int arg)
{
    return arg + 1;
}

/* par référence, taille fixe */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;
       
    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;
       
    return new_point;
}

/* par référence, taille variable */

text *
copytext(text *t)
{
    /*
     * VARSIZE est la taille totale de la structure en octets.
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA est un pointeur sur la région de données de la structure.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t)-VARHDRSZ);    /* nombre d'octets */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    return new_text;
}
</programlisting>
    </para>

    <para>
     En supposant que le code ci-dessus ait été écrit dans le fichier
     <filename>funcs.c</filename> et compilé en objet partagé, nous pourrions
     définir les fonctions pour <productname>PostgreSQL</productname> avec des
     commandes comme ceci&nbsp;:
     
<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- notez la surcharge du nom de la fonction SQL "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;
                         
CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text',
     LANGUAGE C STRICT;
</programlisting>
    </para>

    <para>
     Ici, <replaceable>DIRECTORY</replaceable> représente le répertoire
     contenant le fichier de la bibliothèque partagée (par exemple le répertoire
     du tutoriel de <productname>PostgreSQL</productname>, qui contient le code
     des exemples utilisés dans cette section). (Un meilleur style aurait été
     d'écrire seulement <literal>'funcs'</> dans la clause <literal>AS</>, après
     avoir ajouté <replaceable>DIRECTORY</replaceable> au chemin de recherche.
     Dans tous les cas, nous pouvons omettre l'extension spécifique au système
     pour les bibliothèques partagées, communément <literal>.so</literal> ou    
     <literal>.sl</literal>.) 
    </para>

    <para>
     Remarquez que nous avons spécifié la fonction comme <quote>STRICT</quote>, 
     ce qui signifie que le système devra automatiquement supposer un résultat 
     NULL si n'importe quelle valeur d'entrée est NULL. Ainsi, nous évitons
     d'avoir à vérifier l'existence d'entrées NULL dans le code de la fonction.
     Sinon, nous aurions dû contrôler explicitement les valeurs NULL en testant
     un pointeur NULL pour chaque argument passé par référence (pour les
     arguments passés par valeur, nous n'aurions même aucun moyen de contrôle&nbsp;!).
    </para>

    <para>
     Bien que cette convention d'appel soit simple à utiliser, elle n'est pas
     très portable&nbsp;; sur certaines architectures,  il y a des problèmes
     pour passer de cette manière des types de données plus petits
     que <type>int</type>. De plus, il n'y a pas de moyen simple de renvoyer un
     résultat NULL, ni de traiter des arguments NULL autrement qu'en rendant la
     fonction strict. La convention version-1, présentée ci-après, permet de
     surmonter ces objections.
    </para>
    
   </sect2>
   
   <sect2>
    <title>Conventions d'appel de la version 1 pour les fonctions en langage
     C</title>

    <para>
     La convention d'appel version-1 repose sur des macros pour supprimer la
     plus grande partie de la complexité du passage d'arguments et de résultats.
     La déclaration C d'une fonction en version-1 est toujours&nbsp;:

<programlisting>
Datum nom_fonction(PG_FUNCTION_ARGS)
</programlisting>

     De plus, la macro d'appel
<programlisting>
PG_FUNCTION_INFO_V1(nom_fonction);
</programlisting>
     doit apparaître dans le même fichier source (par convention, elle est
     écrite juste avant la fonction elle-même). Cette macro n'est pas nécessaire
     pour les fonctions <literal>internal</> puisque <productname>PostgreSQL</> 
     assume que toutes les fonctions internes utilisent la convention version-1.
     Elle est toutefois requise pour les fonctions chargées dynamiquement.
    </para>

    <para>
     Dans une fonction version-1, chaque argument existant est traité par une
     macro <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> 
     correspondant au type de donnée de l'argument et le résultat est renvoyé
     par une macro
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     correspondant au type renvoyé. 
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     prend comme argument le nombre d'arguments de la fonction à parcourir, le
     compteur commençant à 0.
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function> prend comme
     argument la valeur effective à renvoyer. 
    </para>

    <para>
     Voici la même fonction que précédemment, codée en style version-1
     
<programlisting>
#include "postgres.h"
#include &lt;string.h&gt;
#include "fmgr.h"

/* par valeur */

PG_FUNCTION_INFO_V1(add_one);
         
Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* par référence, longueur fixe */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* La macro pour FLOAT8 cache sa nature de passage par référence. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Ici, la nature de passage par référence de Point n'est pas cachée. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;
       
    PG_RETURN_POINT_P(new_point);
}

/* par référence, longueur variable */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE est la longueur totale de la structure en octets.
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA est un pointeur vers la région de données de la structure.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t)-VARHDRSZ);    /* nombre d'octets */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}
</programlisting>
    </para>

    <para>
     Les commandes <command>CREATE FUNCTION</command> sont les mêmes que pour
     leurs équivalents dans la version-0.
    </para>
        
    <para>
     Au premier coup d'&oelig;il, les conventions de codage de la version-1 peuvent
     sembler inutilement obscures. Pourtant, elles offrent nombre
     d'améliorations car les macros peuvent cacher les détails superflus. Un
     exemple est donné par la fonction  <function>add_one_float8</> où nous
     n'avons plus besoin de prêter attention au fait que le type
     <type>float8</type> est passé par référence. Un autre exemple de
     simplification est donné par les macros pour les types à longueur variable
     <literal>GETARG</> qui permettent un traitement plus efficace des valeurs 
     <quote>toasted</quote> (compressées ou hors-ligne).  
    </para>
    
    <para>
     Une des grandes améliorations dans les fonctions version-1 est le meilleur
     traitement des entrées et des résultats NULL. La macro  
     <function>PG_ARGISNULL(<replaceable>n</>)</function> permet à une fonction
     de tester si chaque entrée est NULL (évidemment, ceci n'est nécessaire que
     pour les fonctions déclarées non <quote>STRICT</>). Comme avec les macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>, les
     arguments en entrée sont comptés à partir de zéro. Notez qu'on doit se
     garder d'exécuter
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> jusqu'à 
     ce qu'on ait vérifié que l'argument n'est pas NULL. Pour renvoyer un
     résultat NULL, exécutez la fonction
     <function>PG_RETURN_NULL()</function>&nbsp;; ceci convient aussi bien dans
     les fonctions STRICT que non STRICT.
    </para>
    
    <para>  
     Les autres options proposées dans l'interface de nouveau style sont deux
     variantes des macros 
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>. La
     première d'entre elles,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,  
     garantit le renvoi d'une copie de l'argument spécifié où nous pouvons
     écrire en toute sécurité (les macros normales peuvent parfois renvoyer 
     un pointeur vers une valeur physiquement mise en mémoire dans une table qui
     ne doit pas être modifiée. En utilisant les macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>, on
     garantit l'écriture du résultat). La seconde variante se compose des macros
     <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
     qui prennent trois arguments. Le premier est le nombre d'arguments de la
     fonction (comme ci-dessus). Le second et le troisième sont le décalage et
     la longueur du segment qui doit être renvoyé. Les décalages sont comptés à
     partir de zéro et une longueur négative demande le renvoi du reste de la
     valeur. Ces macros procurent un accès plus efficace à des parties de
     valeurs à grande dimension dans le cas où elles ont un type de stockage en
     mémoire <quote>external</quote> (le type de stockage d'une colonne peut
     être spécifié en utilisant <literal>ALTER TABLE
     <replaceable>nom_table</replaceable> ALTER COLUMN
     <replaceable>nom_colonne</replaceable> SET STORAGE
     <replaceable>typestockage</replaceable></literal>.
     <replaceable>typestockage</replaceable> est un type parmi
     <literal>plain</>, <literal>external</>, <literal>extended</literal> ou
     <literal>main</>).
    </para>

    <para> 
     Enfin, les conventions d'appels de la version-1 rendent possible le renvoi
     de résultats d'ensemble (<xref linkend="xfunc-c-return-set">),
     l'implémentation de fonctions déclencheurs (<xref
     linkend="triggers">) et d'opérateurs d'appel de langage procédural (<xref
     linkend="plhandler">). Le code version-1 est aussi plus portable que celui
     de version-0 car il ne contrevient pas aux restrictions du protocole
     d'appel de fonction en C standard. Pour plus de détails, voir
     <filename>src/backend/utils/fmgr/README</filename> dans les fichiers 
     sources de la distribution.
    </para>
     
   </sect2>

   <sect2>
    <title>Écriture du code</title>

    <para>
     Avant de nous intéresser à des sujets plus avancés, nous devons discuter de
     quelques règles de codage des fonctions en langage C de
     <productname>PostgreSQL</productname>.  Bien qu'il soit possible de charger
     des fonctions écrites dans des langages autre que le C dans
     <productname>PostgreSQL</productname>, c'est habituellement difficile
     (quand c'est possible) parce que les autres langages comme C++, FORTRAN ou
     Pascal ne suivent pas fréquemment les mêmes conventions de nommage que le
     C. C'est-à-dire que les autres langages ne passent pas les arguments et ne 
     renvoient pas les valeurs entre fonctions de la même manière. Pour cette
     raison, nous supposerons que nos fonctions en langage C sont réellement
     écrites en C.
 </para>
    <para>
     Les règles de base pour l'écriture de fonctions C sont les suivantes&nbsp;:

     <itemizedlist>
      <listitem>
       <para>
        Utilisez <literal>pg_config
        --includedir-server</literal><indexterm><primary>pg_config</><secondary>
        avec des fonctions C définies par l'utilisateur</></> pour découvrir où
        sont installés les fichiers d'en-tête du serveur
        <productname>PostgreSQL</> sur votre système (ou sur le système de vos
        utilisateurs). Cette option est apparue dans <productname>PostgreSQL</>
        version 7.2. Pour <productname>PostgreSQL</> 7.1, vous devez utiliser
        l'option <option>--includedir</option> (la commande
        <command>pg_config</command> terminera avec un statut différent de zéro
        si elle rencontre une option inconnue). Pour les versions antérieures à
        la 7.1, vous devez deviner mais, puisque cela remonte avant
        l'introduction des conventions d'appel actuelles, il y a peu de chance
        que vous vouliez supporter ces versions.
       </para>
      </listitem>

      <listitem>
       <para>
        Quand vous allouez de la mémoire, utilisez les fonctions 
        <productname>PostgreSQL</productname>
        <function>palloc</function><indexterm><primary>palloc</></> et
        <function>pfree</function><indexterm><primary>pfree</></>
        au lieu des fonctions correspondantes <function>malloc</function> et
        <function>free</function> de la bibliothèque C. La mémoire allouée par
        <function>palloc</function> sera libérée automatiquement à la fin de
        chaque transaction, empêchant des débordements de mémoire. 
       </para>
      </listitem>

      <listitem>
       <para>
        Remettez toujours à zéro les octets de vos structures en utilisant
        <function>memset</function>. Sinon, il est difficile de supporter les
        index ou les jointures de découpage car vous devez retenir seulement
        les bits significatifs de votre structure de donnée pour calculer un
        découpage. Même si vous initialisez tous les champs de votre structure,
        il peut y avoir des remplissages d'alignement (trous dans la structure)
        pouvant contenir des valeurs parasites.
       </para>
      </listitem>

      <listitem>
       <para>
        La plupart des types internes <productname>PostgreSQL</productname>
        sont déclarés dans <filename>postgres.h</filename> alors que les
        interfaces de gestion des fonctions
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.) sont dans 
        <filename>fmgr.h</filename>. Du coup, vous aurez besoin d'inclure au
        moins ces deux fichiers. Pour des raisons de portabilité, il vaut
        mieux inclure <filename>postgres.h</filename> <emphasis>en premier</>
        avant tout autre fichier d'en-tête système ou utilisateur. En incluant
        <filename>postgres.h</filename>, il incluera également
        <filename>elog.h</filename> et <filename>palloc.h</filename> pour vous.
       </para>
      </listitem>

      <listitem>
       <para>
        Les noms de symboles définis dans les objets ne doivent pas entrer en
        conflit entre eux ou avec les symboles définis dans les exécutables du
        serveur <productname>PostgreSQL</productname>. Vous aurez à renommer vos
        fonctions ou variables si vous recevez un message d'erreur à cet effet.
       </para>
      </listitem>

      <listitem>
       <para>
        Compiler ou lier votre code pour qu'il soit chargé dynamiquement dans 
        <productname>PostgreSQL</productname> exige toujours des options
        spéciales. Voir la <xref linkend="dfunc"> pour une explication détaillée
        sur la meilleure façon de le faire sur votre système particulier. 
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

&dfunc;

<sect2 id="xfunc-c-pgxs">
  <title>Infrastructure de construction d'extensions</title>

  <indexterm zone="xfunc-c-pgxs">
    <primary>pgxs</primary>
  </indexterm>

  <para>
    Si vous pensez distribuer vos modules d'extension
    <productname>PostgreSQL</>, configurer un système de construction
    portable peut être assez compliqué. Du coup, l'installation de
    <productname>PostgreSQL</> fournit une infrastructure de construction pour
    les extensions, appelée <acronym>PGXS</acronym>, pour que les modules
    d'extension simples puissent être construit simplement avec un serveur
    déjà installé. Notez que cette infrastructure n'a pas pour but d'être un
    ensemble de travail universel pouvant être utilisé pour construire tous
    les logiciels s'interfaçant avec <productname>PostgreSQL</>&nbsp;; il
    automatise simplement les règles de construction communes pour les modules
    simples d'extension du serveur. Pour des paquetages plus complexes, vous
    aurez besoin d'écrire votre propre système de construction.
  </para>

  <para>
    Pour utiliser l'infrastructure de votre extension, vous devez écrire un
    simple fichier makefile. Dans ce fichier, vous devez configurer quelques
    variables et inclure enfin le makefile global <acronym>PGXS</acronym>.
    Voici un exemple qui construit un module d'extension nommé
    <literal>isbn_issn</literal> consistant en une bibliothèque partagée, un
    script SQL et un fichier texte de documentation&nbsp;:
<programlisting>
MODULES = isbn_issn
DATA_built = isbn_issn.sql
DOCS = README.isbn_issn
    
PGXS := $(shell pg_config --pgxs)
include $(PGXS)
</programlisting>
    Les deux dernières lignes devraient toujours être identiques. Plus tôt
    dans le fichier, vous affectez des variables ou ajoutez vos propres règles
    pour <application>make</application>.
  </para>

  <para>
    Les variables suivantes peuvent être configurées&nbsp;:
  
  <variablelist>
    <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
        <para>
          liste des objets partagés à construire à partir du fichier source
          de même base (ne pas inclure le suffixe dans cette liste)
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
        <para>
          files spécifiques à installer dans
          <literal><replaceable>prefix</replaceable>/share/contrib</literal>
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
        <para>
          fichiers spécifiques à installer dans
          <literal><replaceable>prefix</replaceable>/share/contrib</literal>
          qui ont besoin d'être construit au début
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
        <para>
          fichiers spécifiques à installer dans
          <literal><replaceable>prefix</replaceable>/doc/contrib</literal>
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
        <para>
          fichiers script (pas des binaires) à installer dans
          <literal><replaceable>prefix</replaceable>/bin</literal>
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
        <para>
          fichiers script (pas des binaires) à installer dans
          <literal><replaceable>prefix</replaceable>/bin</literal>
          qui ont besoin d'être construit au début
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
        <para>
          liste des cas de tests de regression (sans suffixe)
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
  
    ou au moins un parmi ces deux-là&nbsp;:
  
  <variablelist>
    <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
        <para>
          un programme binaire à construire (liste des fichiers objets dans
          <varname>OBJS</varname>)
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
        <para>
          un objet partagé à construire (liste des fichiers objets dans
          <varname>OBJS</varname>)
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
  
    Ce qui suit peut être configuré&nbsp;:
  
  <variablelist>
    
    <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
        <para>
          fichiers supplémentaires à supprimer dans <literal>make
          clean</literal>
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
        <para>
          sera ajouté à <varname>CPPFLAGS</varname>
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
        <para>
          sera ajouté à la ligne de liens <varname>PROGRAM</varname>
        </para>
      </listitem>
    </varlistentry>
    
    <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
        <para>
          sera ajouté à la ligne de lien <varname>MODULE_big</varname>
        </para>
      </listitem>
    </varlistentry>
  </variablelist>

  </para>

  <para>
    Nommez ce fichier <literal>Makefile</literal> et placez le dans le répertoire
    qui contient votre extension. Ensuite, vous pouvez lancer la compilation
    avec <literal>make</literal>, et plus tard <literal>make
    install</literal> pour installer votre module. L'extension est compilée
    et installée pour l'installation de
    <productname>PostgreSQL</productname> qui correspond à la première
    commande <command>pg_config</command> trouvée dans votre chemin.
  </para>
  
  </sect2>


   <sect2>
    <title>Arguments de type composite dans les fonctions en langage C</title>
    
    <para>
     Les types composites n'ont pas une organisation fixe comme les structures
     en C. Des instances d'un type composite peuvent contenir des champs NULL.
     De plus, les types composites faisant partie d'une hiérarchie d'héritage
     peuvent avoir des champs différents des autres membres de la même
     hiérarchie. En conséquence, <productname>PostgreSQL</productname> propose
     une interface de fonction pour accéder depuis le C aux champs des types 
     composites. 
    </para>

    <para>
     Supposons que nous voulions écrire une fonction pour répondre à la requête
<programlisting>
SELECT nom, c_surpaye(emp, 1500) AS surpaye
    FROM emp
    WHERE nom = 'Bill' OR nom = 'Sam';
</programlisting>

     En utilisant les conventions d'appel de la version 0, nous pouvons définir
     <function>c_surpaye</> comme&nbsp;:
     
<programlisting>
#include "postgres.h"
#include "executor/executor.h"  /* pour GetAttributeByName() */

bool
c_surpaye(HeapTupleHeader *t, /* la ligne courante d'emp */
           int32 limite)
{
    bool isNULL;
    int32 salaire;

    salaire = DatumGetInt32(GetAttributeByName(t, "salaire", &amp;isNULL));
    if (isNULL)
        return false;
    return salaire &gt; limite;
}
</programlisting>

     Dans le codage version-1, le code ci-dessus devient&nbsp;:

<programlisting>
#include "postgres.h"
#include "executor/executor.h"  /* pour GetAttributeByName() */

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  *t = (HeapTupleHeader *) PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limite = PG_GETARG_INT32(1);
    bool isNULL;
    Datum salaire;

    salaire = GetAttributeByName(t, "salaire", &amp;isNULL);
    if (isNULL)
        PG_RETURN_BOOL(false);
    /* Autrement, nous pourrions préférer de lancer PG_RETURN_NULL() pour un
       salaire NULL.
    */

    PG_RETURN_BOOL(DatumGetInt32(salaire) &gt; limite);
}
</programlisting>
    </para>

    <para>
     <function>GetAttributeByName</function> est la fonction système
     <productname>PostgreSQL</productname> qui renvoie les attributs depuis une
     colonne spécifiée. Elle a trois arguments&nbsp;: l'argument de type
     <type>HeapTupleHeader</type> passé à la fonction, le nom de l'attribut
     recherché et un paramètre de retour qui indique si l'attribut est NULL.  
     <function>GetAttributeByName</function> renvoie une valeur de type
     <type>Datum</type> que vous pouvez convertir dans un type voulu en
     utilisant la macro appropriée
     <function>DatumGet<replaceable>XXX</replaceable>()</function>. Notez que
     la valeur de retour est insignifiante si le commutateur NULL est
     positionné&nbsp;; il faut toujours vérifier le commutateur NULL avant de commencer
     à faire quelque chose avec le résultat.
    </para> 
    
    <para>
     Il y a aussi <function>GetAttributeByNum</function>, qui sélectionne
     l'attribut cible par le numéro de colonne au lieu de son nom.
    </para>
    
    <para> 
     La commande suivante déclare la fonction <function>c_surpaye</function>
     en SQL&nbsp;:

<programlisting>
CREATE FUNCTION c_surpaye(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_surpaye'
    LANGUAGE C STRICT;
</programlisting>

     Notez que nous avons utilisé <literal>STRICT</> pour que nous n'ayons pas à
     vérifier si les arguments en entrée sont NULL.
    </para>
   </sect2>

   <sect2>
    <title>Renvoi de lignes (types composites) à partir de fonctions en langage
     C</title>
     
    <para>
     Pour renvoyer une ligne ou une valeur de type composite à partir d'une
     fonction en langage C, vous pouvez utiliser une API spéciale qui fournit
     les macros et les fonctions dissimulant en grande partie la complexité
     liée à la construction de types de données composites. Pour utiliser cette
     API, le fichier source doit inclure&nbsp;:
 <programlisting>
 #include "funcapi.h"
</programlisting>
    </para>

    <para>
	 Il existe deux façons de construire une valeur de données composites 
	 (autrement dit un <quote>tuple</>)&nbsp;: vous pouvez le construire à
	 partir d'un tableau de valeurs Datum ou à partir d'un tableau de
	 chaînes C qui peuvent passer dans les fonctions de conversion des types
	 de données du tuple. Quelque soit le cas, vous avez d'abord besoin
	 d'obtenir et de construire un descripteur <structname>TupleDesc</> pour
	 la structure du tuple. En travaillant avec des Datums, vous passez le
     <structname>TupleDesc</> à <function>BlessTupleDesc</>, puis vous appelez
     <function>heap_formtuple</> pour chaque ligne. En travaillant avec des
     chaînes C, vous passez <structname>TupleDesc</> à
     <function>TupleDescGetAttInMetadata</>, puis vous appelez
     <function>BuildTupleFromCStrings</> pour chaque ligne. Dans le cas d'une
     fonction renvoyant un ensemble de tuple, les étapes de configuration
     peuvent toutes être entreprises une fois lors du premier appel à la
     fonction.
    </para>

    <para>
     Plusieurs fonctions d'aide sont disponibles pour configurer le
     <structname>TupleDesc</> initial. Si vous voulez utiliser un type
     composite nommé, vous pouvez récupérer l'information à partir du
     catalogue système. Utilisez
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
    pour obtenir une <structname>TupleDesc</> pour une relation nommée ou
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     pour obtenir une <structname>TupleDesc</> basée sur l'OID d'un type. Ceci
     peut être utilisé pour obtenir un <structname>TupleDesc</> soit pour un
     type de base, soit pour un type composite. Lorsque vous écrivez une
     fonction qui renvoie <structname>record</>, le <structname>TupleDesc</> 
     attendu doit être passé à l'appelant.
    </para>

    <para>
	 Une fois que vous avez un <structname>TupleDesc</>, appelez
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
     Si vous pensez travailler avec des Datums ou
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     Si vous pensez travailler avec des chaînes C. Si vous écrivez une
     fonction renvoyant un ensemble, vous pouvez sauvegarder les résultats
     de ces fonctions dans la structure dans le
     <structname>FuncCallContext</> &mdash; utilisez le champ
     <structfield>tuple_desc</> ou <structfield>attinmeta</> respectivement.
    </para>

    <para>
	 Lorsque vous fonctionnez avec des Datums, utilisez
<programlisting>
HeapTuple heap_formtuple(TupleDesc tupdesc, Datum *values, char *NULLs)
</programlisting>
	 pour construire une donnée utilisateur <structname>HeapTuple</> indiquée
	 dans le format Datum.
    </para>

    <para>
	 Lorsque vous travaillez avec des chaînes C, utilisez
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
	 pour construire une donnée utilisateur <structname>HeapTuple</> indiquée
	 dans le format des chaînes C. <literal>values</literal> est un tableau de
	 chaîne C, une pour chaque attribut de la ligne renvoyée. Chaque chaîne
	 C doit être de la forme attendue par la fonction d'entrée du type de
	 donnée de l'attribut. Afin de renvoyer une valeur NULL pour un des
	 attributs, le pointeur correspondant dans le tableau de valeurs
	 (<parameter>values</>) doit être fixé à <symbol>NULL</>. Cette fonction
	 demandera à être appelée pour chaque ligne que vous renvoyez.
    </para>

    <para>
     Une fois que vous avez construit un tuple devant être renvoyé par votre
     fonction, vous devez le convertir en type <type>Datum</>. Utilisez
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
     pour convertir un type <type>HeapTuple</> en un Datum valide.
     Ce <type>Datum</> peut être renvoyé directement si vous envisagez de
     renvoyer juste une simple ligne ou bien il peut être utilisé pour renvoyer
     la valeur courante dans une fonction renvoyant un ensemble.
  </para>

    <para>
     Un exemple figure dans la section suivante.
    </para>

   </sect2>

   <sect2 id="xfunc-c-return-set">
    <title>Renvoi d'ensembles depuis les fonctions en langage C</title>

    <para>
     Il existe aussi une API spéciale procurant le moyen de renvoyer des
     ensembles (lignes multiples) depuis une fonction en langage C. Une fonction
     renvoyant un ensemble doit suivre les conventions d'appel de la version-1. 
     Aussi, les fichiers source doivent inclure l'en-tête
     <filename>funcapi.h</filename>, comme ci-dessus.
    </para>

    <para>
     Une fonction renvoyant un ensemble (<acronym>SRF</> : <quote>set
     returning function</quote>) est appelée une fois pour chaque élément
     qu'elle renvoie. La <acronym>SRF</> doit donc sauvegarder suffisamment
     l'état pour se rappeler ce qu'elle était en train de faire et renvoyer le
     prochain élément à chaque appel. La structure
     <structname>FuncCallContext</> est offerte pour assister le contrôle de ce
     processus. À l'intérieur d'une fonction,
     <literal>fcinfo-&gt;flinfo-&gt;fn_extra</> est utilisée pour conserver un
     pointeur vers <structname>FuncCallContext</> au cours des appels
     successifs.

<programlisting>
typedef struct
{
    /*
     * Number of times we've been called before
     * 
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint32 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint32 max_calls;

    /*
     * OPTIONAL pointer to result slot
     * 
     * This is obsolete and only present for backwards compatibility, viz,
     * user-defined SRFs that use the deprecated TupleDescGetSlot().
     */
    TupleTableSlot *slot;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     * 
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     * 
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;
    
    /*
    * OPTIONAL pointer to struct containing tuple description
    *
    * tuple_desc is for use when returning tuples (i.e. composite data types)
    * and is only needed if you are going to build the tuples with
    * heap_formtuple() rather than with BuildTupleFromCStrings().  Note that
    * the TupleDesc pointer stored here should usually have been run through
    * BlessTupleDesc() first.
    */
    TupleDesc tuple_desc;
    
} FuncCallContext;
</programlisting>
    </para>

    <para>
     Une <acronym>SRF</> utilise plusieurs fonctions et macros qui manipulent
     automatiquement la structure <structname>FuncCallContext</> (et s'attendent
     à la trouver via <literal>fn_extra</>). Utilisez
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     pour déterminer si votre fonction est appelée pour la première fois. Au
     premier appel, utilisez
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
     pour initialiser la structure <structname>FuncCallContext</>. À chaque
     appel de fonction, y compris le premier, utilisez 
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     pour une mise à jour correcte en vue de l'utilisation de
     <structname>FuncCallContext</> et pour nettoyer toutes les données
     renvoyées précédemment et conservées depuis le dernier passage de la
     fonction.
    </para>

    <para>
     Si votre fonction a des données à renvoyer, utilisez 
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     pour les renvoyer à l'appelant. (<literal>result</> doit être de type
     <type>Datum</>, soit une valeur simple, soit un tuple préparé comme décrit
     ci-dessus.) Enfin, quand votre fonction a fini de renvoyer des données,
     utilisez
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     pour nettoyer et terminer la <acronym>SRF</>.
    </para>

    <para>
     Lors de l'appel de la <acronym>SRF</>, le contexte mémoire courant est un
     contexte transitoire qui est effacé entre les appels. Cela signifie que
     vous n'avez pas besoin d'appeler <function>pfree</> sur tout ce que vous
     avez alloué en utilisant <function>palloc</>&nbsp;; ce sera supprimé de
     toute façon. Toutefois, si vous voulez allouer des structures de données
     devant persister tout au long des appels, vous avez besoin de les conserver
     quelque part. Le contexte mémoire référencé par
     <structfield>multi_call_memory_ctx</> est un endroit approprié pour toute
     donnée devant survivre jusqu'à l'achèvement de la fonction <acronym>SRF</>.
     Dans la plupart des cas, cela signifie que vous devrez basculer vers
     <structfield>multi_call_memory_ctx</> au moment de la préparation du
     premier appel.
 </para>  
   <para>
     Voici un exemple complet de pseudo-code&nbsp;:
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    MemoryContext     oldcontext;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps
AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items and just need to clean up: */
        <replaceable>user code</replaceable>
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>

    <para>
     Et voici un exemple complet d'une simple <acronym>SRF</> retournant un
     type composite&nbsp;:
     <programlisting>
PG_FUNCTION_INFO_V1(testpassbyval);

Datum
testpassbyval(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

     /* stuff done only on the first call of the function */
     if (SRF_IS_FIRSTCALL())
     {
        MemoryContext	oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx-&gt;max_calls = PG_GETARG_UINT32(0);

        /* Build a tuple description for a __testpassbyval tuple */
        tupdesc = RelationNameGetTupleDesc("__testpassbyval");

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&gt;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&gt;call_cntr;
    max_calls = funcctx-&gt;max_calls;
    attinmeta = funcctx-&gt;attinmeta;
 
    if (call_cntr &lt; max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
	* Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = HeapTupleGetDatum(tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>

     Le code SQL pour déclarer cette fonction est le suivant&nbsp;:
     
<programlisting>
CREATE TYPE __testpassbyval AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION testpassbyval(integer, integer) RETURNS SETOF
__testpassbyval
    AS '<replaceable>filename</>', 'testpassbyval'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
    </para>

    <para>
     Le répertoire <filename>contrib/tablefunc</> situé dans les fichiers source
     de la distribution contient d'autres exemples de fonctions renvoyant des
     ensembles.</para>
   </sect2>

   <sect2>
    <title>Arguments polymorphes et types renvoyés</title>

    <para>
     Les fonctions en langage C peuvent être déclarées pour accepter et renvoyer
     les types <quote>polymorphes</> <type>anyelement</type> et
     <type>anyarray</type>. Voir la <xref linkend="types-polymorphic"> pour une
     explication plus détaillée des fonctions polymorphes. Si les types des
     arguments ou du renvoi de la fonction sont définis comme polymorphes,
     l'auteur de la fonction ne peut pas savoir à l'avance quel type de données
     sera appelé ou bien quel type doit être renvoyé. Il y a deux routines
     offertes par <filename>fmgr.h</>  qui permettent à une fonction en
     version-1 de découvrir les types de données effectifs de ses arguments et
     le type qu'elle doit renvoyer. Ces routines s'appellent 
     <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</> et 
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</>. Elles
     renvoient l'OID du type du résultat ou de l'argument ou InvalidOID si
     l'information n'est pas disponible. L'accès à la structure
     <literal>flinfo</> se fait normalement avec
     <literal>fcinfo-&gt;flinfo</>. Le paramètre <literal>argnum</> est basé à
     partir de zéro.
    </para>
    
    <para>
     Par exemple, supposons que nous voulions écrire une fonction qui accepte un
     argument de n'importe quel type et qui renvoie un tableau uni-dimensionnel
     de ce type&nbsp;:

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element */
    element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval,
&amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>

    <para>
     La commande suivante déclare la fonction <function>make_array</function> en
     SQL&nbsp;:

<programlisting>
CREATE FUNCTION make_array(anyelement) 
    RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE 'C' STRICT;
</programlisting>

     Notez l'utilisation de STRICT&nbsp;; ceci est primordial car le code ne se
     préoccupe pas de tester une entrée NULL.
    </para>
   </sect2>

  </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-guillemet-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->

