<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/maintenance.sgml,v 1.12 2005/09/22 18:34:42 guillaume Exp $ -->

<chapter id="maintenance">
 <title>Planifier les tâches de maintenance</title>

 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>, comme tout SGBD, requiert que certains
   tâches soient réalisées de façon régulière pour atteindre les performances
   optimales. Ces tâches, discutées maintenant, sont <emphasis>requises</emphasis>
   mais elles sont répétitives par nature et peuvent être facilement automatisées
   en utilisant des outils Unix standards comme les scripts
   <application>cron</application> ou le <application>Task Scheduler</application>
   de Windows. La responsabilité de la mise en place de ces
   scripts et du contrôle de leur bon fonctionnement relève de l'administrateur
   de la base.
  </para>

  <para>
   Une opération de maintenance évidente est la sauvegarde régulière des
   données. Sans une sauvegarde récente il est impossible de restaurer après
   un dommage grave (perte d'un disque, incendie, table supprimée par erreur,
   etc.). Les mécanismes de sauvegarde et restauration disponibles dans
   <productname>PostgreSQL</productname> sont détaillés dans le <xref
   linkend="backup"/>.
  </para>

  <para>
   L'autre tâche primordiale est de réaliser périodiquement un <quote>vacuum</quote>,
   c'est à dire <quote>faire le vide</quote> dans la base de données.
   Cette opération est détaillée dans la <xref linkend="routine-vacuuming"/>.
   La mise à jour des statistiques qui seront utilisées par le planificateur de
   requêtes sera discutée dans <xref linkend="vacuum-for-statistics"/>.
  </para>

  <para>
   La gestion du fichier de traces mérite aussi une attention régulière.
   Cela est détaillé dans la <xref linkend="logfile-maintenance"/>.
  </para>

  <para>
   <productname>PostgreSQL</productname> demande peu de maintenance par rapport
   à d'autres SGBD. Néanmoins, un suivi vigilant de ces tâches participera
   beaucoup à rendre le système productif et agréable à utiliser.
  </para>

 <sect1 id="routine-vacuuming">
  <title>Nettoyages réguliers</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   La commande <command>VACUUM</command> de <productname>PostgreSQL</productname>
   <emphasis>doit</emphasis> être exécutée régulièrement pour plusieurs raisons&nbsp;:

    <orderedlist>
     <listitem>
      <simpara>pour récupérer ou ré-utiliser l'espace disque occupé par les lignes supprimées
      ou mises à jour&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour mettre à jour les statistiques utilisées par l'optimiseur de
      <productname>PostgreSQL</productname>&nbsp;;</simpara>
     </listitem>

     <listitem>
      <simpara>pour prévenir la perte des données les plus anciennes à cause
      d'un <firstterm>cycle de l'identifiant de transaction (XID)</firstterm>.</simpara>
     </listitem>
    </orderedlist>

   La fréquence et le périmètre des exécutions de <command>VACUUM</command> variera
   pour chacune des raisons ci-dessus selon les besoins des sites. De plus, les
   administrateurs doivent appréhender chaque cas et développer une stratégie de
   maintenance appropriée. L'objectif de cette section est de décrire
   globalement les problèmes à résoudre&nbsp;; pour la syntaxe et les autres
   détails, voir la page de référence de la commande <xref linkend="sql-vacuum"
   endterm="sql-vacuum-title"/>.
  </para>

  <para>
   La forme standard de <command>VACUUM</command> peut s'exécuter en parallèle
   avec les opérations de production de la base. Les commandes telles que
   SELECT, INSERT, UPDATE et DELETE continueront à fonctionner comme d'habitude
   mais vous ne pourrez pas modifier la définition d'une table avec des commandes
   comme ALTER TABLE ADD COLUMN lorsqu'elle est la cible du VACUUM.
   À partir de la version 8.0 de <productname>PostgreSQL</productname>, certains
   paramètres de configuration peuvent être ajustés pour réduire l'impact du
   vacuum en tâche de fond sur les performances. Voir <xref
   linkend="runtime-config-resource-vacuum-cost"/>.
  </para>

  <para>
   Un mécanisme automatisé de traitement des opérations <command>VACUUM</command>
   nécessaires a été ajouté dans <productname>PostgreSQL</productname> 8.1.
   Voir <xref linkend="autovacuum"/>.
  </para>

  <sect2 id="vacuum-for-space-recovery">
   <title>Récupérer l'espace disque</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>espace disque</primary>
   </indexterm>

   <para>
    Dans son fonctionnement normal, <productname>PostgreSQL</productname> ne
    supprime pas immédiatement les versions périmées des lignes après un
    <command>UPDATE</command> ou un <command>DELETE</command>.  Cette approche est
    nécessaire pour la consistance des accès
    concurrents (voir le <xref linkend="mvcc"/>)&nbsp;: la version de la ligne ne
    doit pas être supprimée tant qu'elle est susceptible d'être lue par une
    autre transaction. Mais finalement, une ligne qui est plus vieille que
    toutes les transactions en cours n'est plus utile du tout. La place qu'elle
    utilise doit être rendu pour être réutilisée par d'autres lignes afin
    d'éviter un accroissement constant du volume occupé sur le disque. Cela est
    réalisé en exécutant <command>VACUUM</command>.
   </para>

   <para>
    Évidemment, une table qui subit beaucoup de mises à jour et suppressions
    nécessitera des nettoyages plus fréquents que les tables rarement modifiées.
    Il peut être pertinent de programmer périodiquement par <application>cron</application>
    des tâches spécifiques qui nettoient uniquement les tables concernées (avec
    <command>VACUUM</command>) et ignorent les tables que l'on sait peu
    modifiées. Ceci ne sera vraiment utile que s'il y a à la fois des tables
    volumineuses intensément modifiées et des tables volumineuses peu modifiées.
    En effet, le coût supplémentaire lié au nettoyage d'une petite table ne
    mérite pas que l'on s'en préoccupe.
   </para>

   <para>
    Il existe deux variantes de la commande <command>VACUUM</command>. La
    première forme, connu en tant que <quote>vacuum fainéant</quote> ou plus
    simplement <command>VACUUM</command>, marque les données expirées dans les
    tables et les index pour une utilisation future&nbsp;; il ne tente
    <emphasis>pas</emphasis> de récupérer l'espace utilisée par
    cette donnée expirée sauf si l'espace est à la fin de la table et qu'un
    verrou exclusif de table puisse être facilement obtenu. L'espace inutilisé
    au début ou au milieu du fichier ne résulte pas en un raccourcissement du
    fichier et de l'espace redonné au système d'exploitation. Cette variante de
    <command>VACUUM</command> peut être lancé en concurrence avec les autres
    opérations normales de la base de données.
   </para>

   <para>
   La seconde forme est la commande <command>VACUUM FULL</command>. Elle utilise
   un algorithme plus agressif pour récupérer l'espace consommé par les versions
   expirées des lignes. Tout espace qui est libéré par <command>VACUUM
   FULL</command> est immédiatement rendu au système d'exploitation.
   Malheureusement,
   cette variante de la commande <command>VACUUM</command> acquiert un verrou
   exclusif sur chaque table avant que <command>VACUUM FULL</command> ne la
   traite. Du coup, utiliser fréquemment <command>VACUUM FULL</command> peut
   avoir un effet extrêmement négatif sur les performances des requêtes
   concurrentes sur la base de données.
   </para>

   <para>
    La forme standard de <command>VACUUM</command> est mieux utilisé dans le but de
    maintenir une utilisation simple de l'espace disque. Donc, vous avez besoin
    de redonner de l'espace disque au système d'exploitation, vous pouvez
    utiliser <command>VACUUM FULL</command> &mdash; mais quel est l'intérêt de redonner
    de l'espace disque qui devra ensuite être de nouveau alloué&nbsp;? Des
    <command>VACUUM</command> standard et d'une fréquence modérée sont une meilleure
    approche que des <command>VACUUM FULL</command>, même non fréquents, pour maintenir
    des tables mises à jour fréquemment.
   </para>

   <para>
    La meilleure stratégie pour la plupart des sites est de planifier un
    <command>VACUUM</command> général sur toute la base une fois par jour, en dehors
    des horaires normaux de production, accompagné si nécessaire de nettoyages
    plus fréquents pour les tables subissant d'intenses modifications.
    (Quelques installations avec un taux extrêmement important de
    modifications de données lancent un <command>VACUUM</command> sur les
    tables très occupées jusqu'à une fois toutes les quelques minutes.) S'il y
    a plusieurs bases de données dans un cluster (groupe de bases de données),
    ne pas oublier de nettoyer chacune d'entre elles&nbsp;; l'exécutable
    <xref linkend="app-vacuumdb" endterm="app-vacuumdb-title"/> peut s'avérer utile.
   </para>

   <para>
    <command>VACUUM FULL</command> est recommandé dans les cas où vous savez que vous
    avez supprimé la majorité des lignes dans une table, de façon à ce que la
    taille de la table soit réduit de façon conséquente avec l'approche plus
    plus agressive de <command>VACUUM FULL</command>. Utilisez le <command>VACUUM</command>
    standard, et non pas <command>VACUUM FULL</command>, pour les nettoyages standards.
   </para>

   <para>
    Si vous avez une table dont le contenu entier est supprimé sur une base périodique,
    considérez de le faire avec <command>TRUNCATE</command> plutôt qu'avec
    <command>DELETE</command> suivi par un <command>VACUUM</command>.
    <command>TRUNCATE</command> supprime le contenu entier de la table
    immédiatement sans nécessiter un <command>VACUUM</command> ou
    <command>VACUUM FULL</command> pour réclamer l'espace disque maintenant
    inutilisé.
</para>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Maintenir les statistiques du planificateur</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>statistiques</primary>
    <secondary>du planificateur</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    L'optimiseur de requêtes de <productname>PostgreSQL</productname> s'appuie
    sur des informations statistiques sur le contenu des tables dans l'optique
    de générer des plans d'exécutions efficaces pour les requêtes. Ces
    statistiques sont collectées par la commande <command>ANALYZE</command>, qui peut
    être invoquée seule ou comme une option de <command>VACUUM</command>. Il est
    important d'avoir des statistiques relativement à jour sans quoi des mauvais
    choix dans les plans d'exécution pourraient pénaliser la performance de la
    base.
   </para>

   <para>
    À l'instar du nettoyage pour récupérer l'espace, les statistiques doivent
    être plus souvent collectées pour les tables intensément modifiées que pour
    celles qui le sont moins. Mais même si la table est très modifiée, il se
    peut que ces collectes soient inutiles si la distribution probabiliste des
    données évolue peu. Une règle simple pour décider est de voir comment
    évoluent les valeurs minimum et maximum des données. Par exemple, une
    colonne de type <type>timestamp</type> qui contient la date de mise à jour
    de la ligne aura une valeur maximum en continuelle croissance au fur et à
    mesure des modifications&nbsp;; une telle colonne nécessitera plus de
    collectes statistiques qu'une colonne qui contient par exemple les URL des
    pages accédées sur un site web. La colonne qui contient les URL peut très
    bien être aussi souvent modifiée mais la distribution probabiliste des
    données changera certainement moins rapidement.
   </para>

   <para>
    Il est possible d'exécuter <command>ANALYZE</command> sur des tables spécifiques,
    voire des colonnes spécifiques&nbsp;; il a donc toute flexibilité pour
    mettre à jour certaines statistiques plus souvent que les autres en
    fonction des besoins de l'application. Quoi qu'il en soit, dans la pratique,
    il est généralement mieux de simplement analyser la base entière car il s'agit
    d'une opération rapide. Elle utilise un système d'échantillonage des lignes d'une
    table, ce qui lui évite de lire chaque ligne.
   </para>

   <tip>
    <para>
     Même si il n'est pas très productif de règler précisément la fréquence de
     <command>ANALYZE</command> pour chaque colonne, il peut être intéressant d'ajuster
     le niveau de détail des statistiques collectées pour chaque colonne. Les
     colonnes très utilisées dans les clauses <literal>WHERE</literal> et dont la
     distribution n'est pas uniforme requièrent des histogrammes plus précis
     que les autres colonnes. Voir <command>ALTER TABLE SET STATISTICS</command>.
    </para>
   </tip>

   <para>
    Pour la plupart des site, la meilleure stratégie est de programmer une
    collecte générale des statistiques sur toute la base, une fois par jour.
    Ceci peut être profitablement couplé avec un <command>VACUUM</command> (la nuit
    par exemple). Quoi qu'il en soit, les administrateurs des bases dont les
    statistiques changent peu pourront juger que cela est exagéré et que des
    exécutions moins fréquentes de <command>ANALYZE</command> sont bien suffisantes.
   </para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Éviter les cycles des identifiants de transactions</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>identifiant de transaction</primary>
    <secondary>cycle</secondary>
   </indexterm>

   <para>
    Le mécanisme de contrôle de concurrence multiversion (<acronym>MVCC</acronym>) de
    <productname>PostgreSQL</productname> s'appuie sur la possibilité de
    comparer des identifiants de transactions (<acronym>XID</acronym>)&nbsp;; c'est un
    nombre croissant&nbsp;: la version d'une ligne dont le XID d'insertion est
    supérieur au XID de la transaction en cours est <quote>dans le futur</quote> et
    ne doit pas être visible de la transaction courante. Comme les identifiants
    ont une taille limitée (32 bits à ce jour), un groupe qui est en activité
    depuis longtemps (plus de 4 milliards de transactions) pourrait connaître un
    cycle des identifiants de transaction&nbsp;: le XID reviendra à 0 et
    soudainement les transactions du passé sembleront appartenir au futur - ce
    qui signifie qu'elles deviennent invisibles. En bref, perte de données
    totale. (En réalité, les données sont toujours là mais c'est un piètre
    réconfort puisqu'elles resteront inaccessibles.) Pour éviter ceci, il est
    <emphasis>nécessaire d'exécuter un VACUUM sur chaque table de chaque base
    au moins une fois à chaque milliard de transactions</emphasis>.
   </para>

   <para>
    Dans la pratique, cette exigence n'est pas onéreuse mais comme son
    manquement aurait pour conséquence une perte totale des données (pas
    seulement de l'espace disque perdu ou des performances moindres), des
    dispositions ont été prises pour aider les administrateurs à éviter le
    désastre. Pour chaque base de données du groupe,
    <productname>PostgreSQL</productname> conserve la trace de l'heure du
    dernier <command>VACUUM</command> sur toute la base. Quand une base approche du
    problème dû au milliard de transactions, le système commence à émettre des
    messages d'avertissement. Si rien n'est fait, il pourra en dernier lieu
    stopper les opérations normales jusqu'à ce qu'une maintenance manuelle ne
    soit effectuée. La suite de cette section en explique les détails.
   </para>

   <para>
    La nouvelle approche pour la comparaison des XID distingue deux XID
    spéciaux, numéros 1 et 2 (<literal>BootstrapXID</literal> et
    <literal>FrozenXID</literal>). Ces deux XID sont toujours considérés comme plus
    vieux que n'importe quel autre. Les XID normaux (ceux qui sont supérieurs à
    deux) sont comparés sur une base modulo-2<superscript>31</superscript>. Cela signifie
    que pour chaque XID normal, il y en a deux milliards qui sont plus vieux et
    deux milliards qui sont plus récents. Une autre manière de le dire est que
    l'ensemble de définition des XID est circulaire et sans limite. De plus,
    une ligne créée avec un XID normal donné, la version de la ligne apparaîtra
    comme appartenant au passé pour les deux milliards de transactions qui
    suivront quelque soit le XID. Si la ligne existe encore après deux milliards
    de transactions, elle apparaîtra soudainement comme appartenant au futur.
    Pour éviter la disparition des données, les versions trop anciennes doivent
    se voir affecter le XID <literal>FrozenXID</literal> avant d'atteindre le seuil
    fatidique des deux milliards de transactions. Une fois qu'elles ont ce XID
    spécifique, elles appartiendront au passé pour toutes les transactions même
    en cas de cycle. Cette affectation est réalisée par <command>VACUUM</command>.
   </para>

   <para>
    La politique normale de <command>VACUUM</command> est d'affecter
    <literal>FrozenXID</literal> à toute les lignes dont le XID se situe à plus de un
    milliard de transactions dans le passé. Elle préserve le XID original tant
    qu'il est utile. (En réalité, la plupart des lignes existeront et
    disparaîtront avant d'être <quote>gelée</quote>. Avec cette méthode, l'intervalle
    de sécurité maximum entre les exécutions de <command>VACUUM</command> pour une
    table est d'exactement un milliard de transactions&nbsp;: en attendant plus
    longtemps, on s'expose à conserver des versions qui n'étaient pas assez
    vielles pour se voir affecter <literal>FrozenXID</literal> lors de la précédente
    exécution et qui apparaissent maintenant dans le futur du fait d'un cycle -
    c'est-à-dire que les données semblent perdues. (Bien sûr, elles
    réapparaîtront après deux nouveaux milliards de transactions mais cela n'a
    pas d'intérêt).
   </para>

   <para>
    Puisque des exécutions périodiques de <command>VACUUM</command> sont nécessaires de
    toutes manières, pour les raisons évoquées ci-dessus, il est très peu
    probable qu'une table ne soit pas nettoyée du tout durant un milliard de
    transactions. Pour aider les administrateurs à assurer que cette exigence
    est remplie, <command>VACUUM</command> conserve des statistiques sur les XID dans
    la table système <literal>pg_database</literal>. Notamment, la table
    <literal>pg_database</literal> contient, pour chaque base, une colonne
    <literal>datfrozenxid</literal> qui est mise à jour après les <command>VACUUM</command> de
    la base (c'est-à-dire <command>VACUUM</command> qui ne spécifie aucune table
    particulière). La valeur qui est stockée est la limite en deçà de laquelle
    cette exécution de <command>VACUUM</command> a marqué la ligne comme
    <quote>gelée</quote>. Tous les XID plus vieux que ce XID limite ont reçu le XID
    <literal>FrozenXID</literal> pour cette base. Pour obtenir cette information, il
    suffit d'exécuter la requête&nbsp;:

<programlisting>SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting>

    La colonne <literal>age</literal> calcule le nombre de transactions effectuées
    entre le XID limite et le XID courant.
   </para>

   <para>
    Avec la méthode standard de gel du XID, La colonne <literal>age</literal> démarre à
    un milliard pour une base fraîchement nettoyée. Si l'<literal>age</literal>
    approche des deux milliards, la base doit de nouveau être nettoyée pour
    éviter les erreurs liées au cycle du XID. Il est recommandé d'exécuter un
    <command>VACUUM</command> une fois tous les demi milliard de transactions pour
    garder une marge de sécurité maximale. Pour aider à remplir cette
    exigence, chaque <command>VACUUM</command> émet un message si n'importe lequel des
    enregistrements de <literal>pg_database</literal> indique un <literal>age</literal> de
    plus de 1,5 milliard de transactions, par exemple&nbsp;:

<programlisting>play=# VACUUM;
WARNING:  database "mabase" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a full-database VACUUM in "mabase".
VACUUM</programlisting>
   </para>

   <para>
    Si les messages d'avertissement émits par <command>VACUUM</command> restent
    ignorés, alors <productname>PostgreSQL</productname> commencera à émettre
    un message d'avertissement comme ci-dessus à chaque lancement d'une
    transaction une fois qu'il reste moins de 10 millions de transactions avant
    le renouveau du cycle. Si ces messages sont aussi ignorés, le système
    s'arrêtera et refusera d'exécuter de nouvelles transactions tant qu'il
    restera moins de un million de transactions jusqu'au prochain cycle&nbsp;:

<programlisting>play=# select 2+2;
ERROR:  database is shut down to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".</programlisting>

    La marge de sécurité de un million de transactions existe pour permettre à
    l'administrateur de récupérer ces données sans perte en exécutant
    manuellement les commandes <command>VACUUM</command> requises. Néanmoins, comme le
    système n'excutera pas de commandes tant qu'il ne sera pas sorti du mode
    d'arrêt par sécurité, la seule façon de le faire est de stopper le
    serveur et d'utiliser un moteur simple utilisateur pour exécuter le
    <command>VACUUM</command>. Le mode d'arrêt n'est pas pris en compte par le moteur
    simple utilisateur. Voir la page de référence de <xref linkend="app-postgres"/> pour
    des détails sur l'utilisation du moteur simple utilisateur.
   </para>

   <para>
    Avec l'option <command>FREEZE</command>, la commande <command>VACUUM</command> a un
    comportement plus poussé&nbsp;: les versions des lignes sont gelées si elles
    sont suffisamment vieilles pour être visibles de toutes les transactions en
    cours. En particulier, sur une base en lecture seulement, <command>VACUUM
    FREEZE</command> aura pour résultat de geler toutes les lignes de la base. Donc,
    tant que la base n'est pas modifiée, aucun nettoyage supplémentaire n'est
    nécessaire pour éviter les problèmes de cycle du XID. Cette technique est
    notamment utilisée par <command>initdb</command> pour préparer la base
    <literal>template0</literal>. Cela pourrait également être utilisé pour préparer
    n'importe quelle base créée par l'administrateur avec
    <literal>datallowconn</literal> = <literal>false</literal> dans <literal>pg_database</literal>,
    puisqu'il n'y a pas moyen d'exécuter <command>VACUUM</command> sur une base
    à laquelle on ne peut pas se connecter.
   </para>

   <warning>
   <para>
     Une base de données marquée <literal>datallowconn</literal> = <literal>false</literal>
     dans <literal>pg_database</literal> est supposée être proprement gelé&nbsp;; les
     messages automatique et l'arrêt de protection contre les cycles ne sont pas
     pris en compte pour ces bases de données. Du coup, c'est à vous de vous
     assurer que vous avez correctement gelé une base de données avant de la
     marquer avec <literal>datallowconn</literal> = <literal>false</literal>.
   </para>
   </warning>

  </sect2>

  <sect2 id="autovacuum">
   <title id="autovacuum-title">Le démon auto-vacuum</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>information générale</secondary>
   </indexterm>
   <para>
    À partir de <productname>PostgreSQL </productname> 8.1, il existe un
    processus serveur optionnel et séparé appelé le <firstterm>démon
    autovacuum</firstterm>, dont le but est d'automatiser l'exécution des
    commandes <command>VACUUM</command> et <command>ANALYZE </command>. Une
    fois activé, le démon autovacuum s'exécute périodiquement et vérifie les
    tables ayant un grand nombre de lignes insérées, mises à jour ou
    supprimées. Ces vérifications utilisent la fonctionnalité de récupération
    de statistiques au niveau ligne&nbsp;; du coup, le démon autovacuum ne peut
    pas être utilisé sauf si <xref linkend="guc-stats-start-collector"/> et <xref
    linkend="guc-stats-row-level"/> sont configurés à <literal>true</literal>.
    De plus, il est important d'autoriser un emplacement pour le processus
    autovacuum lors du choix de la valeur de <xref
    linkend="guc-superuser-reserved-connections"/>.
   </para>

   <para>
    Une fois activé, le démon autovacuum s'exécute toutes les <xref
    linkend="guc-autovacuum-naptime"/> secondes et détermine quelle base de
    données traitée. Toute base de données proche de la réinitialisation de
    l'identifiant de transaction est immédiatement traitée. Dans ce cas,
    autovacuum exécute un <command>VACUUM</command> sur la base complète ou un
    <command>VACUUM FREEZE</command> s'il s'agit d'une base de données modèle.
    Puis, il quitte. Si aucune base de données ne remplit ce critère, celle qui
    a été traitée le moins récemment par autovacuum est choisie. Dans
    ce cas, chaque table de la base de données sélectionnée est vérifiée et des
    commandes <command>VACUUM</command> ou <command>ANALYZE</command> individuelles
    sont exécutées lorsque cela est nécessaire.
   </para>

   <para>
    Pour chaque table, deux conditions sont utilisées pour déterminer quel
    opération appliquer. Si le nombre de lignes obsolètes depuis le dernier
    <command>VACUUM</command> dépasse une <quote>limite de vacuum</quote>, la
    table bénéficie d'un VACUUM. La limite est définie
    ainsi&nbsp;:
<programlisting>limite du vacuum = limite de base du vacuum + facteur d'échelle du vacuum * nombre de lignes</programlisting>
    où la limite de base du vacuum est
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    le facteur d'échelle du vacuum est
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
    et le nombre de lignes est
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    Le nombre de lignes obsolètes est obtenu à partir du récupérateur de
    statistiques&nbsp;; c'est un nombre à peu près précis, mis à jour après
    chaque instruction <command>UPDATE</command> et <command>DELETE</command>
    (il est seulement à peu près précis car certaines informations pourraient
    être perdues en cas de grosse charge). Pour ANALYZE, une condition similaire
    est utilisée&nbsp;: la limite, définie comme
<programlisting>limite du analyze = limite de base du analyze + facteur d'échelle du analyze * nombre de lignes</programlisting>
    est comparée au nombre de lignes insérées, mises à jour ou supprimées depuis
    le dernier <command>ANALYZE</command>.
   </para>

   <para>
    Les limites et facteurs d'échelle par défaut sont pris dans
    <filename>postgresql.conf</filename> mais il est possible de les surcharger
    table par table avec des entrées dans le catalogue système <link
    linkend="catalog-pg-autovacuum"><structname>pg_autovacuum</structname></link>.
    Si une ligne <structname>pg_autovacuum</structname> existe pour une table
    particulière, les paramètres qu'il spécifie sont appliqués&nbsp;; sinon les
    paramètres globaux sont utilisés. Voir <xref linkend="runtime-config-autovacuum"/>
    pour plus de détails sur les paramètres globaux.
   </para>

   <para>
    En plus des valeurs de la limite de base et des facteurs d'échelle, il
    existe trois autres paramètres pouvant être configurés pour chaque table
    dans <structname>pg_autovacuum</structname>. Le premier,
    <structname>pg_autovacuum</structname>.<structfield>enabled</structfield>,
    peut être configuré à <literal>false</literal> pour instruire le démon
    autovacuum de laisser cette table particulière. Dans ce cas, autovacuum
    touchera seulement la table quand il lancera un VACUUM sur la base de données
    complète pour prévenir la réinitialisation de l'ID de transaction. Les deux
    autres paramètres, le délai du coût du VACUUM
    (<structname>pg_autovacuum</structname>.<structfield>vac_cost_delay</structfield>)
    et la limite du coût du VACUUM
    (<structname>pg_autovacuum</structname>.<structfield>vac_cost_limit</structfield>),
    sont utilisés pour configurer des valeurs spécifiques aux tables pour
    la fonctionnalité <xref linkend="runtime-config-resource-vacuum-cost"
    endterm="runtime-config-resource-vacuum-cost-title"/>.
   </para>

   <para>
    Si une des valeurs dans <structname>pg_autovacuum</structname> est négative
    ou si aucune ligne n'est présente dans <structname>pg_autovacuum</structname>
    quelque soit la table, les valeurs correspondantes de
    <filename>postgresql.conf</filename> sont utilisées.
   </para>

   <para>
    Il n'y a pas de support pour créer des entrées dans
    <structname>pg_autovacuum</structname>, sauf en réalisant soi-même des
    insertions manuelles dans le catalogue. Cette fonctionnalité sera améliorée
    dans les prochaines versions et il est vraisemblable que la définition du
    catalogue changera.
   </para>

   <caution>
    <para>
     Le contenu du catalogue système <structname>pg_autovacuum</structname>
     n'est actuellement pas pris en compte dans les sauvegardes de bases de
     données créées par les outils <command>pg_dump</command> et
     <command>pg_dumpall</command>. Si vous voulez les préserver après
     un cycle sauvegarde/restauration, assurez-vous que vous avez sauvegardé
     manuellement le catalogue.
    </para>
   </caution>

  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Ré-indexation régulière</title>

  <indexterm zone="routine-reindex">
   <primary>ré-indexation</primary>
  </indexterm>

  <para>
   Dans certains cas, reconstruire périodiquement les index par la commande
   <xref linkend="sql-reindex" endterm="sql-reindex-title"/> vaut la peine.
  </para>

  <para>
   Dans les versions <productname>PostgreSQL</productname> antérieures à la 7.4, la
   réindexation périodique était fréquemment nécessaire pour éviter
   l'<quote>inflation des index</quote>, à cause d'un manque de récupération de
   l'espace interne dans les index B-tree. Toutes les situations dans lesquelles
   l'échelle des clés d'index change dans le temps &mdash; par exemple, un index
   sur l'horodatage dans une table où les anciennes entrées sont finalement
   supprimées &mdash; pourraient résulter en une inflation car les pages d'index
   des portions inutilisées de cet ensemble n'étaient pas réclamées pour être
   ré-utilisées. Au bout d'un certain temps, la taille de l'index pouvait
   devenir indéfiniment plus large que les données utiles qu'elle contient.
  </para>

  <para>
   Dans les versions 7.4 et ultérieures de <productname>PostgreSQL</productname>, les pages
   d'index pages qui sont devenues complètement vides sont récupérées pour être
   réutilisées. Il existe toujours une possibilité d'une utilisation inefficace
   de l'espace&nbsp;: si pratiquement toutes les clés d'index d'une page ont été
   supprimées, la page reste allouée. Donc, le cas d'une utilisation où la
   majorité des clés de l'index d'une page est supprimée est un cas où l'espace
   sera mal utilisé. La possibilité d'inflation n'est pas indéfinie &mdash; au
   pire, il reste une clé par page &mdash; mais il serait toujours utile de
   planifier une réindexation périodique pour les index ayant un tel usage.
  </para>

  <para>
   Le potentiel d'inflation des index qui ne sont pas des index B-tree n'a pas
   été particulièrement analysé. Garder un &oelig;il sur la taille physique de
   ces index est une bonne idée.
  </para>

  <para>
   De plus, pour les index B-tree, un index tout juste construit est quelque peu
   plus rapide qu'un index qui a été mis à jour plusieurs fois parce que
   les pages adjacentes logiquement sont habituellement aussi physiquement
   adjacentes dans un index nouvellement créé (cette considération ne s'applique
   pas aux index non B-tree). Il pourrait être intéressant de ré-indexer
   périodiquement simplement pour améliorer la vitesse d'accès.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Maintenance du fichier de traces</title>

  <indexterm zone="logfile-maintenance">
   <primary>traces serveur</primary>
   <secondary>maintenance du fichier de traces</secondary>
  </indexterm>

  <para>
   Sauvegarder les journaux de trace du serveur de bases de données dans un
   fichier plutôt que dans <filename>/dev/NULL</filename> est une bonne idée. Les
   journaux sont d'une utilité incomparable lorsqu'arrive le moment où des
   problèmes surviennent. Néanmoins, les journaux ont tendance à être
   volumineux (tout spécialement à des niveaux de débogage importants) et vous
   ne voulez pas les sauvegarder indéfiniment. Vous avez besoin de faire une
   <quote>rotation</quote> des journaux pour que les nouveaux journaux sont
   commencés et que les anciens soient supprimés après une période de temps
   raisonnable.
  </para>

  <para>
   Si vous redirigez simplement <systemitem>stderr</systemitem> du
   <command>postgres</command> dans un fichier, vous aurez un journal des
   traces mais la seule façon de le tronquer sera d'arrêter et de relancer
   le serveur. Ceci peut convenir si vous utilisez
   <productname>PostgreSQL</productname> dans un environnement de développement
   mais peu de serveurs de production trouveraient ce comportement acceptable.
  </para>

  <para>
   Une meilleure approche est d'envoyer la sortie <systemitem>stderr</systemitem>
   du serveur dans un programme de rotation de journaux. Il
   existe un programme interne de rotation que vous pouvez utiliser en
   configurant le paramètre <literal>redirect_stderr</literal> à
   <literal>true</literal> dans <filename>postgresql.conf</filename>. Les paramètres de
   contrôle pour ce programme sont décrits dans <xref
   linkend="runtime-config-logging-where"/>.
  </para>

  <para>
   Sinon, vous pourriez préférer utiliser un programme externe de rotation de
   journaux si vous en utilisez déjà un avec d'autres serveurs. Par exemple,
   l'outil <application>rotatelogs</application> inclus dans la distribution
   <productname>Apache</productname> peut être utilisé avec
   <productname>PostgreSQL</productname>. Pour cela, envoyez via un tube la
   sortie <systemitem>stderr</systemitem> du serveur dans le programme
   désiré. Si vous lancez le serveur avec <command>pg_ctl</command>, alors
   <systemitem>stderr</systemitem> est déjà directement renvoyé dans
   <systemitem>stdout</systemitem>, donc vous avez juste besoin d'ajouter la commande via
   un tube, par exemple&nbsp;:

<programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting>
</para>

  <para>
   Une autre approche de production pour la gestion des journaux de trace est
   de les envoyer à <application>syslog</application> et de laisser <application>syslog</application>
   gérer la rotation des fichiers. Pour cela, initialisez le paramètre de
   configuration <literal>log_destination</literal> à <literal>syslog</literal> (pour tracer
   uniquement via <application>syslog</application>) dans <filename>postgresql.conf</filename>.
   Ensuite, vous pouvez envoyer un signal <literal>SIGHUP</literal> au démon
   <application>syslog</application> quand vous voulez le forcer à écrire dans un nouveau
   fichier. Si vous voulez automatiser la rotation des journaux, le programme
   <application>logrotate</application> peut être configuré pour fonctionner
   avec les journaux de traces provenant de <application>syslog</application>.
  </para>

  <para>
   Néanmoins, sur beaucoup de systèmes, <application>syslog</application> n'est pas très
   fiable, particulièrement avec les messages très gros&nbsp;; il pourrait
   tronquer ou supprimer des messages au moment où vous en aurez le plus besoin.
   De plus, sur <productname>Linux</productname>, <application>syslog</application> synchronisera tout
   message sur disque, amenant des performances assez pauvres. (Vous pouvez
   utiliser un <literal>-</literal> au début du nom de fichier dans le fichier de
   configuration <application>syslog</application> pour désactiver ce comportement.)
  </para>

  <para>
   Notez que toutes les solutions décrites ci-dessus font attention à lancer de
   nouveaux journaux de traces à des intervalles configurables mais ils ne
   gèrent pas la suppression des vieux fichiers de traces, qui ne sont
   probablement plus très intéressants. Vous voudrez probablement configurer
   un script pour supprimer périodiquement les anciens journaux. Une autre
   possibilité est de configurer le programme de rotation pour que les anciens
   journaux de traces soient écrasés de façon cyclique.
  </para>
 </sect1>
</chapter>
