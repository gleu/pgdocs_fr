<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Header: /var/lib/cvs/pgsql-fr/sgml/backup.sgml,v 1.17 2005/09/15 07:03:14 guillaume Exp $ -->
<chapter id="backup">
 <title>Sauvegardes et restaurations</title>

 <indexterm zone="backup"><primary>backup</primary></indexterm>

 <para>
  Comme avec tout ce qui contient des données importantes, les bases de données
  <productname>PostgreSQL</productname> doivent être sauvegardées régulièrement.
  Bien que la procédure soit plutôt simple, il est important de comprendre les
  techniques sous-jacentes ainsi que les hypothèses prises.
 </para>

 <para>
  Il y a trois approches fondamentalement différentes pour sauvegarder les 
  données de <productname>PostgreSQL</productname>&nbsp;:
  <itemizedlist>
   <listitem><para><acronym>La sauvegarde SQL&nbsp;;</acronym></para></listitem>
   <listitem><para>La sauvegarde de niveau système de
    fichiers&nbsp;;</para></listitem>
   <listitem><para>L'archivage continue.</para></listitem>
  </itemizedlist>
  Chacune a ses avantages et inconvénients.
 </para>

 <sect1 id="backup-dump">
  <title>Sauvegarde <acronym>SQL</acronym></title>

  <para>
   Le principe est de générer un fichier texte de commandes SQL (appelé 
   <quote>fichier dump</quote>), qui, si on le renvoie au serveur, recrée une
   base de données identique à celle sauvegardée.
   <productname>PostgreSQL</productname> propose pour cela le programme utilitaire
   <xref linkend="app-pgdump"/>. L'usage basique est&nbsp;:
<synopsis>pg_dump <replaceable class="parameter">base_de_donnees</replaceable> &gt; <replaceable class="parameter">fichier_de_sortie</replaceable></synopsis>
   Comme vous le voyez, <application>pg_dump</application> écrit son résultat sur la
   sortie standard. Nous verrons plus loin que cela peut être pratique.
  </para>

  <para>
   <application>pg_dump</application> est un programme client <productname>PostgreSQL</productname>
   classique (mais plutôt intelligent). Ceci veut dire que vous pouvez 
   faire une sauvegarde depuis n'importe quel ordinateur ayant accès à la base.
   Mais rappelez-vous que <application>pg_dump</application> n'a pas de droits spéciaux.
   En particulier, il doit avoir accès en lecture à toutes les tables que 
   vous voulez sauvegarder, si bien qu'il doit être lancé pratiquement
   toujours en tant que super-utilisateur de la base.
  </para>

  <para>
   Pour préciser quel serveur de bases de données <application>pg_dump</application> doit
   contacter, utilisez les options de ligne de commande <option>-h
   <replaceable>serveur</replaceable></option> et <option>-p <replaceable>port</replaceable></option>.
   Le serveur par défaut est le serveur local, ou bien celui spécifié par la 
   variable d'environnement <envar>PGHOST</envar>.
   De la même façon, le port par défaut est indiqué par la variable d'environnement
   <envar>PGPORT</envar> ou, en son absence, par la valeur par défaut précisée 
   à la compilation. Heureusement, la serveur a normalement la même valeur par
   défaut à la compilation.
  </para>

  <para>
   Comme tout programme client <productname>PostgreSQL</productname>, <application>pg_dump</application>
   se connecte par défaut avec l'utilisateur de base de données de même nom que 
   l'utilisateur système courant. Pour passer outre, précisez l'option 
   <option>-U</option> ou donnez une valeur à la variable d'environnement
   <envar>PGUSER</envar>. Rappelez-vous que les connexions de
   <application>pg_dump</application> sont soumises aux mécanismes normaux
   d'authentification des programmes clients (qui sont décrits dans le <xref
   linkend="client-authentication"/>).
  </para>

  <para>
   Les sauvegardes créées par <application>pg_dump</application> sont cohérentes, ce
   qui veut dire que les modifications effectuées alors que <application>pg_dump</application>
   est en cours de fonctionnement ne sont pas dans le fichier de résultat.
   <application>pg_dump</application> ne bloque pas les autres opérations sur la base 
   lorsqu'il fonctionne (sauf celles qui ont besoin d'un verrou exclusif, comme 
   <command>VACUUM FULL</command>.)
  </para>

  <important>
   <para>
    Si votre base de données dépend des OID (par exemple en tant que clés 
    étrangères), vous devez indiquer à <application>pg_dump</application> de sauvegarder
    aussi les OID. Pour cela, utilisez l'option <option>-o</option> sur la ligne
    de commande.
   </para>
  </important>

  <sect2 id="backup-dump-restore">
   <title>Restaurer la sauvegarde</title>

   <para>
    Les fichiers texte créés par <application>pg_dump</application> sont prévus pour être 
    lus par le programme <application>psql</application>. La syntaxe générale 
    d'une commande de restauration est
<synopsis>psql <replaceable class="parameter">base_de_donnees</replaceable> &lt; <replaceable class="parameter">fichier_d_entree</replaceable></synopsis>
    où <replaceable class="parameter">fichier_d_entree</replaceable> est ce que 
    vous avez précisé comme <replaceable class="parameter">fichier_de_sortie</replaceable>
    à la commande <application>pg_dump</application>. La base de données 
    <replaceable class="parameter">base_de_donnees</replaceable> n'est pas créée par cette 
    commande. Vous devez la créer vous-même à partir de <literal>template0</literal>
    avant d'exécuter <application>psql</application> (par exemple avec <literal>createdb -T
    template0 <replaceable class="parameter">base_de_donnees</replaceable></literal>).
    <application>psql</application> propose des options similaires à celles de
    <application>pg_dump</application> pour spécifier le serveur de bases de
    données sur lequel se connecter et le nom d'utilisateur à utiliser. Voyez la
    page de référence de <xref linkend="app-psql"/> pour plus d'informations.
    </para>

   <para>
    Before restoring a SQL dump, all the users who own objects or were
    granted permissions on objects in the dumped database must already
    exist. S'ils n'existent pas, la
    restauration échouera pour la création des objets dont ils sont
    propriétaires ou pour lesquels ils ont des droits (quelque fois, cela
    correspond à ce que vous souhaitez mais ce n'est pas le cas habituellement).
   </para>

   <para>
    By default, the <application>psql</application> script will continue to
    execute after an SQL error is encountered. You may wish to use the
    following command at the top of the script to alter that
    behaviour and have <application>psql</application> exit with an
    exit status of 3 if an SQL error occurs:
<programlisting>
\set ON_ERROR_STOP
</programlisting>
    Either way, you will only have a partially restored
    dump. Alternatively, you can specify that the whole dump should be
    restored as a single transaction, so the restore is either fully
    completed or fully rolled back. This mode can be specified by
    passing the <option>-1</option> or <option>--single-transaction</option>
    command-line options to <application>psql</application>. When using this
    mode, be aware that even the smallest of errors can rollback a
    restore that has already run for many hours. However, that may
    still be preferable to manually cleaning up a complex database
    after a partially restored dump.
   </para>

   <para>
    La capacité de <application>pg_dump</application> et <application>psql</application> à écrire
    et à lire dans des tubes permet de sauvegarder une base de données 
    directement d'un serveur sur un autre. Par exemple&nbsp;:
<programlisting>pg_dump -h <replaceable>serveur1</replaceable> <replaceable>base_de_donnees</replaceable> | psql -h <replaceable>serveur2</replaceable> <replaceable>base_de_donnees</replaceable></programlisting>
   </para>

   <important>
    <para>
     Les fichiers de sauvegarde produits par <application>pg_dump</application> sont
     relatifs à <literal>template0</literal>. Cela signifie que chaque langage,
     procédure, etc. ajoutés à <literal>template1</literal> seront aussi sauvegardés
     par <application>pg_dump</application>. En conséquence, si vous utilisez une base
     <literal>template1</literal> modifiée, vous devez créer la base vide à partir de
     <literal>template0</literal>, comme dans l'exemple précédent.
    </para>
   </important>

   <para>
    After restoring a backup, it is wise to run <xref
    linkend="sql-analyze" endterm="sql-analyze-title"> on each
    database so the query optimizer has useful statistics. An easy way
    to do this is to run <command>vacuumdb -a -z</command>; this is
    equivalent to running <command>VACUUM ANALYZE</command> on each database
    manually.
    Pour plus de conseils sur le chargement efficace de grosses quantités de
    données dans <productname>PostgreSQL</productname>, référez-vous à la <xref
    linkend="populate"/>.
   </para>
   
  </sect2>

  <sect2 id="backup-dump-all">
   <title>Utilisation de <application>pg_dumpall</application></title>

   <para>
    Le mécanisme précédent est peu pratique pour sauvegarder un serveur de bases
    de données complet. <xref linkend="app-pg-dumpall"/> est prévu pour cela.
    <application>pg_dumpall</application> sauvegarde toutes les bases de données d'un
    groupe de bases de données <productname>PostgreSQL</productname> (appelé cluster) et
    préserve les données communes au groupe de bases comme les utilisateurs et
    les groupes. L'utilisation basique de cette commande est&nbsp;:
<synopsis>pg_dumpall &gt; <replaceable>fichier_de_sortie</replaceable></synopsis>
    Le fichier de sauvegarde résultant peut être restauré avec <application>psql</application>&nbsp;:
<synopsis>psql -f <replaceable class="parameter">fichier_d_entree</replaceable> postgres</synopsis>
    (Vous pouvez utiliser n'importe quelle base de données pour vous 
    connecter mais si vous êtes en train de recharger un serveur vide, 
    <literal>postgres</literal> devrait habituellement être utilisée.)
    Il faut obligatoirement être le super-utilisateur de la base pour restaurer
    une sauvegarde faite avec <application>pg_dumpall</application>, pour pouvoir restaurer
    les informations sur les utilisateurs et les groupes.
   </para>
  </sect2>

  <sect2 id="backup-dump-large">
   <title>Gérer les grosses bases de données</title>

   <para>
    Comme <productname>PostgreSQL</productname> permet que des tables soient plus
    grandes que la taille maximale d'un fichier sur votre système de fichiers,
    sauvegarder une telle table en fichier peut poser des problèmes. 
    Comme <application>pg_dump</application> peut écrire sur la sortie standard, vous pouvez
    utiliser des outils standard d'Unix pour contourner ce problème éventuel.
   </para>

   <formalpara>
    <title>Compresser le fichier de sauvegarde</title>
    <para>
     Vous pouvez utiliser votre programme de compression habituel. Par exemple
     <application>gzip</application>.

<programlisting>pg_dump <replaceable class="parameter">base_de_donnees</replaceable> | gzip &gt; <replaceable class="parameter">nom_fichier</replaceable>.gz</programlisting>

     Pour restaurer&nbsp;:

<programlisting>createdb <replaceable class="parameter">base_de_donnees</replaceable>
gunzip -c <replaceable class="parameter">nom_fichier</replaceable>.gz | psql <replaceable class="parameter">base_de_donnees</replaceable></programlisting>

     ou

<programlisting>cat <replaceable class="parameter">nom_fichier</replaceable>.gz | gunzip | psql <replaceable class="parameter">base_de_donnees</replaceable></programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title>Couper le fichier avec <command>split</command></title>
    <para>
     La commande <command>split</command> vous permet de découper le fichier en
     morceaux d'une taille acceptable pour le système de fichiers sous-jacent.
     Par exemple, pour faire des morceaux de 1&nbsp;Mo&nbsp;:
 
<programlisting>pg_dump <replaceable class="parameter">base_de_donnees</replaceable> | split -b 1m - <replaceable class="parameter">nom_fichier</replaceable></programlisting>

     Pour restaurer&nbsp;:

<programlisting>createdb <replaceable class="parameter">base_de_donnees</replaceable>
cat <replaceable class="parameter">nom_fichier</replaceable>* | psql <replaceable class="parameter">base_de_donnees</replaceable></programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title>Utilisation du format de sauvegarde spécial</title>
    <para>
     Si <productname>PostgreSQL</productname> est installé sur un système où la 
     bibliothèque de compression <application>zlib</application> est disponible, ce format
     de sauvegarde spécial peut être utilisé. Pour les grandes bases de données,
     cela produira un fichier de sauvegarde d'une taille comparable à celle de
     <command>gzip</command>, avec l'avantage supplémentaire de permettre de
     restaurer des tables sélectivement. La commande qui suit sauvegarde une
     base de données en utilisant le format de sauvegarde spécial&nbsp;:
 
<programlisting>pg_dump -Fc <replaceable class="parameter">base_de_donnees</replaceable> &gt; <replaceable class="parameter">nom_fichier</replaceable></programlisting>

     Un format personnalisé de la sauvegarde n'est pas un script pour
     <application>psql</application> mais doit, à la place, être restauré avec
     <application>pg_restore</application>. Voir les pages de référence de <xref
     linkend="app-pgdump"/> et <xref linkend="app-pgrestore"/> pour quelques
     détails.
    </para>
   </formalpara>

  </sect2>
 </sect1>

 <sect1 id="backup-file">
  <title>Sauvegarde de niveau système de fichiers</title>

  <para>
   Une autre stratégie de sauvegarde est de copier les fichiers
   utilisés par <productname>PostgreSQL</productname> pour enregistrer les données.
   Dans la <xref linkend="creating-cluster"/>, l'emplacement de ces
   fichiers sont donnés mais vous les avez probablement déjà trouvés si vous
   vous intéressez à cette méthode. Vous pouvez utiliser n'importe quelle
   méthode de sauvegarde, par exemple&nbsp;:
 
<programlisting>tar -cf sauvegarde.tar /usr/local/pgsql/data</programlisting>
  </para>

  <para>
   Cependant, il y a deux restrictions qui rendent cette méthode inutilisable
   ou en tout cas inférieure à la méthode <application>pg_dump</application>.
 
   <orderedlist>
    <listitem>
     <para>
      Le serveur de base de données <emphasis>doit</emphasis> être arrêté pour obtenir
      une sauvegarde utilisable. Toutes les demi-mesures, comme supprimer
      toutes les connexions, ne fonctionneront <emphasis>pas</emphasis>
      (principalement parce que <command>tar</command> et les outils similaires
      ne font pas une image atomique de l'état du système de fichiers à un
      moment spécifique). Vous trouverez des informations sur la façon d'arrêter
      le serveur <productname>PostgreSQL</productname> dans la <xref
      linkend="server-shutdown"/>.
    </para>

     <para>
      Il va sans dire que vous devez aussi éteindre le serveur avant de 
      restaurer les données.
      </para>
    </listitem>

    <listitem>
     <para>
      Si vous vous êtes aventurés dans les détails de l'organisation de la 
      base de données, vous pouvez être tentés de ne sauvegarder et 
      de ne restaurer que certaines tables ou bases de données particulières. 
      Ceci ne fonctionnera <emphasis>pas</emphasis> parce que les informations
      contenues dans ces fichiers ne sont qu'à moitié vraies. L'autre moitié
      est dans les fichiers journaux de validation
      <filename>pg_clog/*</filename>, qui 
      contiennent l'état de la validation de chaque transaction. Un fichier de 
      table n'est utilisable qu'avec cette information. Bien entendu, il est 
      impossible de ne restaurer qu'une table et les données <filename>pg_clog</filename>
      associées car cela rendrait toutes les autres tables du serveur 
      inutilisables. Donc, les sauvegardes du système de fichiers fonctionnent
      seulement pour les restaurations complètes d'un groupe entier de bases de
      données.
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   Une autre approche à la sauvegarde du système de fichiers est de réaliser
   une <quote>image cohérente</quote> du répertoire des données si le système
   de fichiers supporte cette fonctionnalité (et que vous avez confiance
   en sa bonne implémentation). La procédure typique est de faire une
   <quote>image gelée</quote> du volume contenant la base de données, et enfin de
   copier le répertoire data complètement (pas seulement quelques parties,
   voir ci-dessus) de l'image sur un périphérique de sauvegarde, puis de
   libérer l'image gelé. Ceci fonctionnera même si le serveur de la base de
   données est en cours d'exécution. Néanmoins, une sauvegarde créée de cette
   façon sauvegarde les fichiers de la base de données dans un état où le
   serveur n'était pas correctement arrêté&nbsp;; du coup, au lancement du
   serveur à partir des données sauvegardées, PostgreSQL pensera que le
   serveur s'est stoppé brutalement et rejouera les journaux WAL. Ceci n'est
   pas un problème, soyez-en juste conscient (et assurez-vous d'inclure les
   fichiers WAL dans votre sauvegarde).
  </para>

  <para>
   Si votre base de données est répartie sur plusieurs systèmes de fichiers,
   il pourrait ne pas y avoir de moyens pour obtenir des images gelées
   exactement simultanément de tous les disques. Par exemple, si vos fichiers
   de données et vos journaux WAL sont sur des disques différents ou si les
   espaces logiques sont sur des systèmes de fichiers différents, il pourrait
   ne pas être possible d'utiliser une sauvegarde par image parce que ces
   dernières doivent être simultanées.
   Lisez la documentation de votre système
   de fichiers avec attention avant de faire confiance à la technique d'images
   cohérentes dans de telles situations. L'approche la plus sûre est d'arrêter
   le serveur de bases de données assez longtemps pour créer toutes les images
   gelées.
  </para>

  <para>
   Une autre option est d'utiliser <application>rsync</application> pour réaliser une
   sauvegarde du système de fichiers. Ceci se fait tout d'abord en lançant
   <application>rsync</application> alors que le serveur de bases de données est en cours
   d'exécution, puis en arrêtant le serveur juste assez longtemps pour lancer
   <application>rsync</application> une deuxième fois. Le deuxième
   <application>rsync</application> sera beaucoup plus rapide que le premier car il aura
   relativement peu de données à transférer et le résultat final sera cohérent
   parce que le serveur était arrêté. Cette méthode permet de réaliser une
   sauvegarde du système de fichiers avec un arrêt minimal.
  </para>

  <para>
   Notez aussi qu'une sauvegarde des fichiers de données ne sera pas forcément 
   moins grosse qu'une sauvegarde SQL. Au contraire, elle sera très certainement
   plus  grande (<application>pg_dump</application> ne sauvegarde pas le 
   contenu des index, mais la commande pour les recréer).
  </para>

 </sect1>

 <sect1 id="continuous-archiving">
  <title>Archivage en continue et récupération à un instant (PITR)</title>

  <indexterm zone="backup">
   <primary>archivage en continue</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>récupération à un instant</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>

  <para>
   En permanence, <productname>PostgreSQL</productname> maintient des journaux WAL
   (<firstterm>write ahead log</firstterm>) dans le sous-répertoire
   <filename>pg_xlog/</filename> du répertoire des données du groupe. Ces journaux
   décrivent chaque modification effectuée sur les fichiers de données des
   bases. Ils existent principalement pour des raisons de sécurité suite à un
   arrêt brutal&nbsp;: si le système s'arrête brutalement, la base de données
   peut être restaurée pour avoir une cohérence des données en
   <quote>rejouant</quote> les entrées des journaux enregistrées depuis le dernier
   point de vérification. Néanmoins, l'existence de ces journaux rend possible
   l'utilisation d'une troisième stratégie pour la sauvegarde des bases de
   données&nbsp;: nous pouvons combiner une sauvegarde au niveau système de
   fichiers avec la sauvegarde des fichiers WAL. Si la récupération est
   nécessaire, nous restaurons la sauvegarde, puis rejouons à partir des
   fichiers WAL sauvegardés pour amener la sauvegarde jusqu'à la date
   actuelle. Cette approche est plus complexe à administrer que toutes les
   autres approches mais elle apporte des bénéfices significatifs&nbsp;:
  <itemizedlist>
   <listitem>
    <para>
     Nous n'avons pas besoin de faire une sauvegarde parfaitement cohérente
     comme point de départ. Toute incohérence dans la sauvegarde sera corrigée
     par la ré-exécution des journaux (ceci n'est pas significativement
     différent de ce qu'il se passe lors d'une récupération après un arrêt
     brutal). Donc, nous n'avons pas besoin d'une fonctionnalité d'image
     système du système de fichiers, simplement <application>tar</application> ou un
     autre outil d'archivage.
    </para>
   </listitem>
   <listitem>
    <para>
     Comme nous pouvons assembler une longue séquence de fichiers à WAL pour
     les rejouer, la sauvegarde continue est possible en continuant
     simplement d'archiver les fichiers WAL. Ceci est particulièrement
     intéressant pour les grosses bases de données où il pourrait ne pas
     être facile de réaliser une sauvegarde complète fréquemment.
    </para>
   </listitem>
   <listitem>
    <para>
     Rien ne dit que nous devons rejouer les entrées WAL jusqu'à la fin. Nous
     pouvons stopper la ré-exécution à un certain point et avoir une image
     cohérente de la base de données à ce moment-là. Du coup, cette technique
     supporte la <firstterm>récupération à un instant t</firstterm> (PITR)&nbsp;: il est
     possible de restaurer la base de données à n'importe quel point dans le
     temps depuis la dernière sauvegarde de base.
    </para>
   </listitem>
   <listitem>
    <para>
     Si nous remplissons en continue la série de fichiers WAL dans une autre
     machine qui a été chargée avec le même fichier de sauvegarde de base,
     nous avons un système <quote>à jour en permanence</quote>&nbsp;: à tout
     moment, nous pouvons monter la deuxième machine et avoir une copie quasi
     complète de la base de données.
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <para>
   Comme avec la technique de sauvegarde standard du système de fichiers,
   cette méthode supporte la restauration d'un groupe de bases de données
   complet, pas un sous-ensemble. De plus, il requiert beaucoup d'espace
   d'archivage&nbsp;: la sauvegarde de base peut être légère mais un système
   très utilisé générera beaucoup de mégaoctets de trafic WAL qui seront à
   archiver. Malgré tout, c'est la technique de sauvegarde préférée dans
   beaucoup de situations où la haute fiabilité est nécessaire.
  </para>

  <para>
   Pour récupérer avec succès suite à l'utilisation de l'archivage continu
   (aussi appelé sauvegarde à chaud par certains vendeurs de SGBD),
   vous avez besoin d'une séquence continue de fichiers WAL archivés qui
   s'étendent au moins jusqu'au point de départ de votre sauvegarde. Pour
   commencer, vous devriez configurer et tester votre procédure d'archivage
   des journaux WAL <emphasis>avant</emphasis> de faire votre première sauvegarde de
   base. Il nous faut donc commencer par vous présenter les mécanismes
   d'archivage des fichiers WAL.
  </para>

  <sect2 id="backup-archiving-wal">
   <title>Configurer l'archivage WAL</title>

   <para>
    Dans un sens abstrait, un système <productname>PostgreSQL</productname> fonctionnel
    produit une séquence indéfiniment longue d'enregistrements WAL. Le système
    divise physiquement cette séquence en <firstterm>fichiers segment</firstterm>
    WAL, qui font normalement 16&nbsp;Mo chaque (bien que la taille puisse
    être modifiée lors de la construction de <productname>PostgreSQL</productname>). Les
    fichiers segment se voient donnés des noms numériques pour refléter leur
    position dans la séquence abstraite des WAL. Lorsque le système n'utilise
    pas l'archivage des WAL, il crée seulement quelques fichiers segment, puis
    les <quote>recycle</quote> en renommant les fichiers segment devenus inutiles.
    Il est supposé qu'un fichier segment dont le contenu précède le
    dernier point de vérification n'a plus d'intérêt et peut être recyclé.
   </para>

   <para>
    Lors de l'archivage des données WAL, nous voulons capturer le contenu de
    chaque fichier segment une fois qu'il est rempli et sauvegarder les
    données quelque part avant que le fichier segment ne soit recyclé pour
    être réutilisé. Suivant l'application et le matériel disponible, 
    <quote>sauvegarder les données quelque part</quote> peut se faire de plusieurs
    façons&nbsp;: nous pouvons copier les fichiers segment dans un répertoire
    NFS monté sur une autre machine, les écrire sur une cartouche (en vous
    assurant que vous avez un moyen de restaurer le fichier avec son nom
    d'origine) ou le grouper pour les graver sur un CD, ou encore autre chose.
    Pour fournir autant de flexibilité que possible à l'administrateur de la
    base de données, <productname>PostgreSQL</productname> essaie de ne faire aucune
    supposition sur la façon dont l'archivage est réalisé. À la place,
    <productname>PostgreSQL</productname> vous laisse spécifier une commande
    shell à exécuter pour copier le fichier segment rempli là où vous le
    souhaitez. La commande pourrait être aussi simple qu'un
    <literal>cp</literal> ou il pourrait impliquer un shell complexe &mdash;
    à vous de voir.
   </para>

   <para>
    La commande shell à utiliser est spécifiée par le paramètre de
    configuration <xref linkend="guc-archive-command"/> qui, en pratique, sera
    toujours placé dans le fichier <filename>postgresql.conf</filename>. Dans
    cette chaîne, tout <literal>%p</literal> est remplacé par le chemin absolu de
    l'archive alors que tout <literal>%f</literal> est remplacé seulement par le
    nom du fichier. Écrivez <literal>%%</literal> si vous avez besoin d'écrire le
    vrai caractère <literal>%</literal> dans la commande. La commande utile la plus
    simple est quelque chose comme
<programlisting>archive_command = 'cp -i %p /mnt/serveur/repertoire_archive/%f &lt;/dev/null'</programlisting>
    qui copiera les segments WAL archivables dans le répertoire
    <filename>/mnt/serveur/repertoire_archive</filename>. (Ceci est un exemple, pas
    une recommandation, et pourrait ne pas fonctionner sur toutes les
    plateformes.)
   </para>

   <para>
    La commande d'archivage sera exécutée en tant qu'utilisateur 
    propriétaire du serveur <productname>PostgreSQL</productname>. Comme la série de
    fichiers WAL en cours d'archivage contient réellement tout ce qui se
    trouve dans votre base de données, vous vous assurerez que les
    données archivées sont protégées des autres utilisateurs&nbsp;; par
    exemple, si les archives sont stockées dans un répertoire où se trouvent
    des droits de lecture pour le groupe ou pour les autres.
   </para>

   <para>
    Il est important que la commande d'archivage renvoie le code de sortie
    zéro si et seulement si l'exécution a réussi. En obtenant un résultat
    zéro, <productname>PostgreSQL</productname> supposera que le fichier segment WAL a
    été archivé avec succès et qu'il peut le supprimer ou le recycler.
    Néanmoins, un statut différent de zéro indique à  
    <productname>PostgreSQL</productname> que le fichier n'a pas été archivé&nbsp;; il
    essaiera périodiquement jusqu'à ce qu'il y arrive.
   </para>

   <para>
    La commande d'archivage devrait être généralement conçue pour refuser
    d'écraser tout fichier archive déjà existant. Ceci est une fonctionnalité
    de sécurité importante pour préserver l'intégrité de votre archive dans le
    cas d'une erreur de l'administrateur (comme l'envoi de la sortie de deux
    serveurs différents dans le même répertoire d'archivage). Il est
    conseillé de tester votre commande d'archivage proposée pour vous
    assurer qu'en effet il n'écrase pas un fichier existant <emphasis>et qu'il
    renvoie un statut différent de zéro dans ce cas</emphasis>. Nous avons découvert
    que <literal>cp -i</literal> travaille correctement sur certaines plateformes,
    mais pas sur toutes. Si la commande choisie ne gère pas elle-même ce
    cas, vous pouvez ajouter une commande pour tester l'existence du fichier
    d'archivage. Par exemple, quelque chose comme
<programlisting>archive_command = 'test ! -f .../%f &amp;&amp; cp %p .../%f'</programlisting>
    fonctionne correctement sur la plupart des variantes Unix.
   </para>

   <para>
    Lors de la conception de votre configuration d'archivage, considérez ce
    qui se passerait si la commande d'archivage échouait de façon répétée parce
    que certains aspects demanderaient une intervention de l'opérateur ou
    à cause d'un manque d'espace dans le répertoire d'archivage. Par exemple,
    ceci pourrait arriver si vous écrivez sur une cartouche sans changeur 
    automatique&nbsp;; quand la cartouche est remplie, rien ne peut être
    archivé tant que la cassette n'est pas changée. Vous devez vous assurer
    que toute erreur ou requête à un opérateur humain est rapportée de façon
    approprié pour que la situation puisse être résolue relativement
    rapidement. Le répertoire <filename>pg_xlog/</filename> continuera à se remplir
    de fichiers segment WAL jusqu'à la résolution de la situation.
   </para>

   <para>
    La vitesse de la commande d'archivage n'est pas importante, tant qu'elle
    est au même rythme que la génération de données WAL du serveur. Les
    opérations normales continuent même si le processus d'archivage est un peu
    plus lent. Si l'archivage est significativement plus lent, alors la
    quantité de données qui pourrait être perdue va croître. Cela signifie
    aussi que le répertoire <filename>pg_xlog/</filename> contiendra un grand nombre
    de fichiers segment non archivés, qui finiront éventuellement par
    dépasser l'espace disque disponible. Il vous est conseillé de surveiller
    le processus d'archivage pour vous assurer que tout fonctionne
    normalement.
   </para>

   <para>
    En écrivant votre commande d'archivage, vous devez vous assurer que les
    noms de fichier à archiver auront 64 caractères maximum et peuvent
    contenir toute combinaison de lettres ASCII, de chiffres et de points.
    Il n'est pas nécessaire de rappeler le chemin complet original
    (<literal>%p</literal>) mais il est nécessaire de rappeler le nom du fichier
    (<literal>%f</literal>).
   </para>

   <para>
    Notez que, bien que l'archivage WAL vous autorisera à restaurer toute
    modification réalisée sur les données de votre base 
    <productname>PostgreSQL</productname>, il ne restaurera pas les modifications
    effectuées sur les fichiers de configuration (c'est-à-dire
    <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> et
    <filename>pg_ident.conf</filename>) car ceux-ci sont édités manuellement plutôt
    qu'au travers d'opérations SQL. Vous pourriez souhaiter conserver les
    fichiers de configuration à un endroit où ils seront sauvegardés avec vos
    procédures standards de sauvegarde du système de fichiers. Voir la
    <xref linkend="runtime-config-file-locations"/> pour savoir comment
    modifier l'emplacement des fichiers de configuration.
   </para>

   <para>
    The archive command is only invoked on completed WAL segments.  Hence,
    if your server generates only little WAL traffic (or has slack periods 
    where it does so), there could be a long delay between the completion
    of a transaction and its safe recording in archive storage.  To put
    a limit on how old unarchived data can be, you can set
    <xref linkend="guc-archive-timeout"> to force the server to switch
    to a new WAL segment file at least that often.  Note that archived
    files that are ended early due to a forced switch are still the same
    length as completely full files.  It is therefore unwise to set a very
    short <varname>archive_timeout</varname> &mdash; it will bloat your archive
    storage.  <varname>archive_timeout</varname> settings of a minute or so are
    usually reasonable.
   </para>

   <para>
    Also, you can force a segment switch manually with
    <function>pg_switch_xlog</function>, if you want to ensure that a
    just-finished transaction is archived immediately.  Other utility
    functions related to WAL management are listed in <xref
    linkend="functions-admin-backup-table">.
   </para>
  </sect2>

  <sect2 id="backup-base-backup">
   <title>Réaliser une sauvegarde de base</title>

   <para>
    La procédure pour réaliser une sauvegarde de base est relativement
    simple&nbsp;:
  <orderedlist>
   <listitem>
    <para>
     Assurez-vous que l'archivage WAL est activée et fonctionnelle.
    </para>
   </listitem>
   <listitem>
    <para>
     Connectez-vous à la base de données en tant que superutilisateur et
     lancez la commande
<programlisting>SELECT pg_start_backup('label');</programlisting>
     où <literal>label</literal> est toute chaîne que vous voulez utiliser pour
     identifier de façon unique l'opération de sauvegarde (une bonne pratique
     est d'utiliser le chemin complet où vous avez l'intention de placer le
     fichier de sauvegarde). <function>pg_start_backup</function> crée un fichier
     <firstterm>label de sauvegarde</firstterm> nommé <filename>backup_label</filename> dans
     le répertoire du groupe avec des informations sur votre sauvegarde.
    </para>

    <para>
     Peu importe la base de données à laquelle vous vous connectez pour lancer
     cette commande. Vous pouvez ignorer le résultat renvoyé par la
     fonction mais, si elle rapporte une erreur, gérez-la avant de
     continuer.
    </para>
   </listitem>
   <listitem>
    <para>
     Lancez la sauvegarde en utilisant n'importe quel outil de sauvegarde du
     système de fichiers comme <application>tar</application> ou <application>cpio</application>. Il
     n'est ni nécessaire ni désirable de stopper les opérations normales de
     la base de données lorsque vous faites cela.
    </para>
   </listitem>
   <listitem>
    <para>
     Connectez-vous de nouveau sur la base de données en tant que
     superutilisateur et lancez la commande
<programlisting>SELECT pg_stop_backup();</programlisting>
     Elle devrait réussir. however, the backup is not yet fully
     valid.  An automatic switch to the next WAL segment occurs, so all
     WAL segment files that relate to the backup will now be marked ready for
     archiving.
    </para>
   </listitem>
   <listitem>
    <para>
     Une fois que les fichiers des segments WAL utilisées lors de la sauvegarde
     sont archivées, vous avez terminé. The file identified by <function>pg_stop_backup</function>'s result is
     the last segment that needs to be archived to complete the backup.  
     Archival of these files will happen automatically, since you have
     already configured <varname>archive_command</varname>. In many cases, this
     happens fairly quickly, but you are advised to monitor your archival
     system to ensure this has taken place so that you can be certain you
     have a valid backup.
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
    Certains outils de sauvegarde que vous souhaiteriez utiliser émettent des
    messages d'avertissements ou d'erreurs si les fichiers qu'ils essaient de
    copier changent lors de la copie. Cette situation est normale, ce n'est pas
    une erreur, lors de la création de la sauvegarde de base d'une base de
    données active&nbsp;; vous devez donc vous assurer que vous pouvez
    distinguer les messages de cette sorte des autres messages. Par exemple,
    certaines versions de <application>rsync</application> renvoient un code de sortie
    séparé pour des <quote>fichiers source disparus</quote>, et vous pouvez écrire
    un script qui accepte ce code de sortie comme un cas normal. De plus,
    certaines versions de GNU <application>tar</application> considèrent que la modification
    d'un fichier lors de sa copie par <application>tar</application> est une erreur. Il
    ne semble pas exister de moyen simple pour distinguer cette erreur des autres
    types d'erreurs, autrement qu'en inspectant manuellement les messages de
    <application>tar</application>. Du coup, GNU <application>tar</application> n'est pas le meilleur
    outil pour réaliser des sauvegardes de base.
   </para>

   <para>
    Il n'est pas nécessaire d'être très concerné sur le temps passé entre
    <function>pg_start_backup</function> et le début réel de la sauvegarde, pas plus
    qu'entre la fin de la sauvegarde et <function>pg_stop_backup</function>&nbsp;; un
    délai de quelques minutes ne posera pas de problème. However, if you normally run the
    server with <varname>full_page_writes</varname> disabled, you may notice a drop
    in performance between <function>pg_start_backup</function> and 
    <function>pg_stop_backup</function>.  You must ensure that these backup operations
    are carried out in sequence without any possible overlap, or you will
    invalidate the backup.
   </para>

   <para>
    Assurez-vous que votre sauvegarde inclut tous les fichiers du répertoire
    du groupe de bases de données (c'est-à-dire
    <filename>/usr/local/pgsql/data</filename>). Si vous utilisez des espaces logiques
    qui ne se trouvent pas dans ce répertoire, faites attention à bien les
    inclure (et assurez-vous que votre sauvegarde archive les liens
    symboliques comme des liens, sinon la restauration posera problème pour
    les espaces logiques).
   </para>

   <para>
    Néanmoins, vous devriez omettre de sauvegarder les fichiers du
    sous-répertoire <filename>pg_xlog/</filename> contenu dans le répertoire du
    groupe. Cette petite complication est intéressante parce qu'elle réduit le
    risque d'erreurs lors de la restauration. Ceci est facile à arranger si
    <filename>pg_xlog/</filename> est un lien symbolique pointant quelque part à
    l'extérieur du répertoire du groupe, ce qui est une configuration commune
    pour des raisons de performance.
   </para>

   <para>
    Pour utiliser cette sauvegarde, vous aurez besoin de conserver les
    fichiers segments WAL générés pendant ou après le lancement de la
    sauvegarde. Pour vous aider dans ce travail, la fonction 
    <function>pg_stop_backup</function> crée un <firstterm>fichier historique de la
    sauvegarde</firstterm> qui est immédiatement stocké dans l'aire des archives WAL.
    Ce fichier est nommé d'après le nom du premier fichier segment WAL dont
    vous avez besoin pour utiliser la sauvegarde. Par exemple, si le fichier
    WAL du début est <literal>0000000100001234000055CD</literal>, le fichier
    historique sera nommé quelque chose comme
    <literal>0000000100001234000055CD.007C9330.backup</literal> (le deuxième nombre
    dans le nom de ce fichier contient la position exacte à l'intérieur du fichier
    WAL et peut être habituellement ignorée). Une fois que vous avez archivé de
    façon sûre la sauvegarde du système de fichiers et les segments WAL utilisés
    pendant la sauvegarde (comme spécifié dans le fichier d'historique des
    sauvegardes), tous les segments WAL archivés avec des noms numériquement plus
    petits ne sont plus nécessaires pour la récupération de la sauvegarde du
    système de fichiers et pourraient être supprimés. Néanmoins, vous devriez
    penser à conserver plusieurs ensembles de sauvegarde pour être absolument
    certain de pouvoir récupérer vos données.
   </para>

   <para>
    Le fichier d'historique de la sauvegarde est un simple fichier texte. Il
    contient le label que vous avez donné à <function>pg_start_backup</function>,
    ainsi que l'heure de début et de fin, et les segments WAL de la sauvegarde.
    Si vous utilisez le label pour identifier où le fichier de sauvegarde associé
    est conservé, alors le fichier historique archivé est suffisant pour vous
    dire quel fichier de sauvegarde restaurer, si vous en avez besoin.
   </para>

   <para>
    Comme vous devez conserver tous les fichiers WAL archivés depuis votre
    dernière sauvegarde de base, l'intervalle entre les sauvegardes de base
    devrait habituellement être choisie suivant la quantité de stockage que
    vous voulez consommer en fichiers archives WAL. Vous devriez aussi
    considérer combien de temps vous êtes prêt à dépenser pendant la
    récupération, si celle-ci est nécessaire &mdash; le système devra rejouer
    tous les segments WAL et ceci peut prendre beaucoup de temps si la
    dernière sauvegarde de base est ancienne.
   </para>

   <para>
    Il est aussi important de noter que la fonction
    <function>pg_start_backup</function> crée un fichier nommé 
    <filename>backup_label</filename> dans le répertoire du groupe de bases de données
    qui est ensuite supprimé de nouveau par <function>pg_stop_backup</function>. Ce
    fichier sera bien sûr archivé comme faisant parti du fichier de
    sauvegarde. Le fichier label de la sauvegarde inclut la chaîne label que
    vous avez donné à <function>pg_start_backup</function>, ainsi que l'heure à
    laquelle <function>pg_start_backup</function> a été exécuté et le nom du fichier
    WAL du début. En cas de confusion, il sera du coup possible de regarder
    dans le fichier sauvegarde et de déterminer exactement de quelle session
    de sauvegarde provient ce fichier.
   </para>

   <para>
    Il est aussi possible de faire une sauvegarde alors que le serveur est
    arrêté. Dans ce cas, vous ne pouvez évidemment pas utiliser
    <function>pg_start_backup</function> ou <function>pg_stop_backup</function> et vous serez
    donc contraint à garder trace vous-même des fichiers de sauvegarde et de
    jusqu'où vont les fichiers WAL associés. Il est généralement mieux de
    suivre la procédure d'archivage continu ci-dessus.
   </para>
  </sect2>

  <sect2 id="backup-pitr-recovery">
   <title>Récupérer à partir d'une sauvegarde de l'archivage continu</title>

   <para>
    OK, le pire est arrivé et vous avez besoin de récupérer votre sauvegarde.
    Voici la procédure&nbsp;:
  <orderedlist>
   <listitem>
    <para>
     Arrêtez le serveur s'il est en cours d'exécution.
    </para>
   </listitem>
   <listitem>
    <para>
     Si vous avez de la place pour le faire, copiez le répertoire entier des
     données du groupe et tout espace logique dans un emplacement temporaire
     au cas où vous en auriez besoin plus tard. Notez que cette précaution
     demandera que vous ayez assez de place libre sur votre système pour
     contenir deux copies de votre base de données existante. Si vous n'avez
     pas assez de place, vous devez au moins copier le contenu du
     sous-répertoire <filename>pg_xlog</filename> du répertoire des données car il
     pourrait contenir des journaux qui n'ont pas été archivés avant l'arrêt
     du serveur.
    </para>
   </listitem>
   <listitem>
    <para>
     Effacez tous les fichier et sous-répertoires existants sous le
     répertoire des données du groupe et sous les répertoires racines des
     espaces logiques que vous utilisez.
    </para>
   </listitem>
   <listitem>
    <para>
     Restaurez les fichiers de la base de données à partir de votre
     sauvegarde. Faites attention à ce qu'ils soient restaurés avec le bon
     propriétaire (l'utilisateur système de la base de données, et non pas
     root&nbsp;!) et avec les bons droits. Si vous utilisez les espaces
     logiques, vous vérifirez que les liens symboliques dans
     <filename>pg_tblspc/</filename> ont été correctement restaurés.
    </para>
   </listitem>
   <listitem>
    <para>
     Supprimez tout fichier présent dans <filename>pg_xlog/</filename>&nbsp;; ils
     proviennent de la sauvegarde et sont du coup probablement obsolètes.
     Si vous n'avez pas archivé <filename>pg_xlog/</filename> du tout, alors
     re-créez ce répertoire ainsi que le sous-répertoire
     <filename>pg_xlog/archive_status/</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     Si vous aviez des fichiers segments WAL non archivés que vous avez
     sauvegardé dans l'étape 2, copiez-les dans <filename>pg_xlog/</filename> (il
     est mieux de les copier, pas de les déplacer, car vous aurez toujours les
     fichiers non modifiés si un problème survient et que vous devez
     recommencer).
    </para>
   </listitem>
   <listitem>
    <para>
     Créez un fichier de commandes de récupération 
     <filename>recovery.conf</filename> dans le répertoire des données du groupe
     (voir <xref linkend="recovery-config-settings"/>). De plus, vous pourriez
     vouloir modifier temporairement <filename>pg_hba.conf</filename> pour empêcher
     les utilisateurs ordinaires de se connecter tant que vous n'êtes pas
     certain que la récupération a réussi.
    </para>
   </listitem>
   <listitem>
    <para>
     Lancez le serveur. Le serveur se trouvera en mode récupération et
     commencera la lecture des fichiers WAL archivés dont il a besoin. Should the
     recovery be terminated because of an external error, the server can
     simply be restarted and it will continue recovery. À la
     fin du processus de récupération, le serveur renommera
     <filename>recovery.conf</filename> en <filename>recovery.done</filename> (pour empêcher
     de retourner accidentellement en mode de récupération dans le cas d'un
     arrêt brutal un peu plus tard), puis commencera les opérations normales
     de la base de données.
    </para>
   </listitem>
   <listitem>
    <para>
     Inspectez le contenu de la base de données pour vous assurer que vous
     avez récupéré ce que vous vouliez. Sinon, retournez à l'étape 1. Si
     tout va bien, laissez vos utilisateurs venir en restaurant le fichier
     <filename>pg_hba.conf</filename> à son état normal.
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
    La partie clé de tout ceci est de configurer le fichier de commandes de
    récupération. Il décrit comment vous voulez récupérer et à quel point la
    récupération doit fonctionner. Vous pouvez utiliser 
    <filename>recovery.conf.sample</filename> (normalement présent dans le
    répertoire d'installation <filename>share/</filename>) comme prototype. La seule
    chose que vous devez absolument spécifier dans
    <filename>recovery.conf</filename> est <varname>restore_command</varname> indiquant à
    <productname>PostgreSQL</productname> comment récupérer les fichiers segments WAL
    archivés. Comme <varname>archive_command</varname>, ceci est une chaîne contenant
    le nom de la commande. Elle pourrait contenir <literal>%f</literal>, qui est
    remplacé par le nom du journal souhaité, et <literal>%p</literal>, qui est
    remplacé par le chemin absolu où copier le journal. Écrivez 
    <literal>%%</literal> si vous avez besoin d'embarquer un vrai caractère
    <literal>%</literal> dans la commande. La commande utile la plus simple est
    quelque chose comme
<programlisting>restore_command = 'cp /mnt/serveur/répertoire_archive/%f %p'</programlisting>
    qui copiera les segments WAL précédemment archivés à partir du répertoire
    <filename>/mnt/serveur/répertoire_archive</filename>.  Vous pourriez bien sûr
    utiliser quelque chose de plus compliqué, peut-être même un script shell
    qui demandera à l'utilisateur de monter la cassette appropriée.
   </para>

   <para>
    Il est important que la commande renvoie un code de sortie différent de
    zéro en cas d'échec. La commande <emphasis>se verra demander</emphasis> les
    journaux absents de l'archive&nbsp;; il doit renvoyer autre chose que
    zéro dans ce cas. Ceci n'est pas une condition d'erreur. Soyez conscient
    que le nom de base du chemin <literal>%p</literal> sera différent de
    <literal>%f</literal>&nbsp;; ne vous attendez pas à ce qu'ils soient
    interchangeables.
   </para>

   <para>
    Les segments WAL qui n'ont pas pu être trouvés dans l'archive seront
    recherchés dans <filename>pg_xlog/</filename>&nbsp;; cela autorise l'utilisation
    des segments non archivés. Néanmoins, les segments disponibles à partir de
    l'archive seront utilisés de préférence par rapport aux fichiers dans
    <filename>pg_xlog/</filename>. Le système ne surchargera pas le contenu existant
    de <filename>pg_xlog/</filename> lors de la récupération des fichiers archivés.
   </para>

   <para>
    Normalement, la récupération traitera tous les segments WAL disponibles,
    restaurant du coup la base de données à cet instant (ou aussi proche que
    nous le pouvons suivant les segments WAL disponibles). Mais, si vous
    voulez récupérer à un instant particulier (disons, juste avant que
    l'administrateur junior ait supprimé votre table principale de
    transaction), spécifiez simplement le point d'arrêt requis dans
    <filename>recovery.conf</filename>. Vous pouvez spécifier le point d'arrêt, connu
    sous le nom de <quote>cible de récupération</quote>, soit par la date/heure
    soit par l'ID de la dernière transaction. Au moment où nous écrivons ceci,
    seule l'option date/heure est tout à fait utilisable car il n'existe pas
    d'outils pour vous aider à identifier avec une certaine précision l'ID de
    transaction à utiliser.
   </para>

   <note>
     <para>
      Le point d'arrêt doit se situer après l'heure de fin de la sauvegarde
      de base (le moment de <function>pg_stop_backup</function>). Vous ne pouvez pas
      utiliser une sauvegarde de base pour récupérer à un tel instant où la
      sauvegarde était encore en cours (pour récupérer jusqu'à cet instant,
      vous devez récupérer votre sauvegarde de base précédente et recommencer
      à partir de là).
     </para>
    </note>

   <para>
    If recovery finds a corruption in the WAL data then recovery will
    complete at that point and the server will not start. The recovery 
    process could be re-run from the beginning, specifying a 
    <quote>recovery target</quote> so that recovery can complete normally.
    If recovery fails for an external reason, such as a system crash or
    the WAL archive has become inaccessible, then the recovery can be
    simply restarted and it will restart almost from where it failed.
    Restartable recovery works by writing a restartpoint record to the control
    file at the first safely usable checkpoint record found after 
    <varname>checkpoint_timeout</varname> seconds. 
   </para>

    <sect3 id="recovery-config-settings" xreflabel="Configuration de la récupération">
     <title>Configuration de la récupération</title>

     <para>
      Ces configurations peuvent seulement être placées dans le fichier
      <filename>recovery.conf</filename> et s'appliquent seulement pour la durée de la
      récupération. Ils doivent être réinitialisés pour toute récupération
      ultérieure que vous souhaitez réaliser. Ils ne peuvent pas être modifiés
      une fois que la récupération a commencé.
     </para>

     <variablelist>

     <varlistentry id="restore-command" xreflabel="restore_command">
      <term><varname>restore_command</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        La commande shell à exécuter pour récupérer un segment archivé de la
        série de fichiers WAL. Ce paramètre est requis. Tout <literal>%f</literal>
        dans la chaîne est remplacé par le nom du fichier à récupérer à
        partir de l'archive et tout <literal>%p</literal> est remplacé par le chemin
        absolu pour le copier sur le serveur. Écrivez <literal>%%</literal> pour
        embarquer un vrai caractère <literal>%</literal> dans la commande 
       </para>
       <para>
        Il est important que la commande renvoie un code de sortie zéro si et
        seulement si elle a réussi. La commande <emphasis>se verra
        demander</emphasis> les noms des fichiers absents dans l'archive&nbsp;; elle
        doit renvoyer une valeur différente de zéro dans ce cas.
        Exemples&nbsp;:
<programlisting>restore_command = 'cp /mnt/server/archivedir/%f "%p"'
restore_command = 'copy /mnt/server/archivedir/%f "%p"'  # Windows</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="recovery-target-time" xreflabel="recovery_target_time">
      <term><varname>recovery_target_time</varname> 
           (<type>timestamp</type>)
      </term>
      <listitem>
       <para>
        Ce paramètre spécifie le temps à partir duquel le serveur doit
        arrêter la récupération. Au plus un entre
        <varname>recovery_target_time</varname> et <xref
        linkend="recovery-target-xid"/> peut être spécifié. Par défaut, la
        récupération se passe jusqu'à la fin du journal WAL. Le point
        d'arrêt précis est aussi influencé par <xref
        linkend="recovery-target-inclusive"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="recovery-target-xid" xreflabel="recovery_target_xid">
      <term><varname>recovery_target_xid</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Ce paramètre spécifie l'ID de transaction où arrêter la récupération.
        Gardez en tête qu'alors que les ID de transactions sont affectés
        séquentiellement au début de la transaction, les transactions peuvent
        se terminer dans un ordre numérique différent. Les transactions qui
        seront récupérées sont celles qui ont été validées avant celle
        spécifiée (et quelque fois en l'incluant). Au plus un entre
        <varname>recovery_target_xid</varname> et <xref
        linkend="recovery-target-time"/> peut être spécifié. La valeur par
        défaut est de récupérer jusqu'à la fin du journal WAL. Le point
        d'arrêt précis est aussi influencé par
        <xref linkend="recovery-target-inclusive"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="recovery-target-inclusive" 
                   xreflabel="recovery_target_inclusive">
      <term><varname>recovery_target_inclusive</varname> 
        (<type>boolean</type>)
      </term>
      <listitem>
       <para>
        Spécifie si nous stoppons tout de suite après la cible de
        récupération spécifiée (<literal>true</literal>) ou tout juste avant
        (<literal>false</literal>). S'applique à <xref
        linkend="recovery-target-time"/> et <xref
        linkend="recovery-target-xid"/>, quelque soit celui qui est spécifié
        pour cette récupération. Ceci indique si les transactions ayant
        exactement l'instant de validation cible ou l'ID, respectivement,
        seront inclus dans la récupération. La valeur par défaut est
        <literal>true</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="recovery-target-timeline" 
                   xreflabel="recovery_target_timeline">
      <term><varname>recovery_target_timeline</varname> 
        (<type>string</type>)
      </term>
      <listitem>
       <para>
        Spécifie la récupération à un timeline particulier. La valeur par
        défaut est de récupérer suivant le timeline en cours au moment où la
        sauvegarde de base a été effectuée. Vous aurez seulement besoin de
        configurer ce paramètre dans les situations complexes de récupération
        où le besoin de retourner à un état qui a été atteint après une
        récupération à un temps donné. Voir la <xref
        linkend="backup-timelines"/> pour des informations.
       </para>
      </listitem>
     </varlistentry>

   </variablelist>

   </sect3>

  </sect2>

  <sect2 id="backup-timelines">
   <title>Timelines</title>

  <indexterm zone="backup">
   <primary>timelines</primary>
  </indexterm>

   <para>
    La possibilité de restaurer la base de données à un instant précédent
    crée une complexité qui sont la base des histoires de science-fiction sur
    le voyage dans le temps et les univers parallèles. Dans l'historique
    original de la base de données, vous avez peut-être supprimé une table
    critique à 17h15 mardi soir. Imperturbable, vous récupérez votre
    sauvegarde, la restaurez jusqu'à 17h14 mardi soir et êtes de nouveau
    fonctionnel. Dans <emphasis>cette</emphasis> histoire de l'univers de la base de
    données, vous n'avez jamais supprimé la table. Mais, supposez que vous
    réalisez plus tard qu'après tout, ce n'était pas une si grande idée et
    que vous voudriez revenir à un point plus lointain dans l'historique
    original. Vous ne serez plus capable de le faire si, une fois que votre
    base de donnée était de nouveau fonctionnelle, elle a écrit par dessus
    certaines des séquences de fichiers segments WAL qui vous aurait permis
    de récupérer à cet instant. Donc, vous voulez réellement distinguer les
    séries d'enregistrements WAL générées après la récupération à un instant
    donné de celles générées dans l'historique originale de la base de
    données.
   </para>

   <para>
    Pour gérer ces problèmes, <productname>PostgreSQL</productname> comprends la notion
    de <firstterm>timelines</firstterm>. Chaque fois que vous récupérez à un certain
    instant précédant la fin de la séquence WAL, un nouveau timeline est
    créé pour identifier les séries d'enregistrements WAL générées après la
    récupération (néanmoins, si la récupération continue jusqu'à la fin des
    WAL, nous ne commençons pas une nouvelle timeline&nbsp;: nous étendons
    celle qui existe). Le numéro d'identifiant de la timeline fait partie 
    des noms des fichiers segment WAL et, du coup, une nouvelle timeline
    ne réécrit pas sur les données générées par des timelines précédentes.
    En fait, il est possible d'archiver plusieurs timelines différentes.
    Bien que cela semble être une fonctionnalité inutile, parfois, cela vous
    sauve la vie. Considérez la situation où vous n'êtes plus sûr de l'instant
    jusqu'où récupérer. Du coup, vous devez tester des récupérations à
    différents instants jusqu'à trouver le meilleur moment dans l'ancien
    historique. Sans les timelines, ce processus génèrerait un incroyable
    bazar. Avec les timelines, vous pouvez récupérer à <emphasis>n'importe
    quel</emphasis> état précédent, ceci incluant les états dans les branches de
    timelines que vous abandonnerez plus tard.
   </para>

   <para>
    Chaque fois qu'une nouvelle timeline est créée,
    <productname>PostgreSQL</productname> crée un fichier d'<quote>historique des
    timeline</quote> qui montre les timelines, leur branchement et le moment
    auquel c'est arrivé. Ces fichiers historiques sont requis pour permettre
    au système de récupérer les bons fichiers segment WAL lors de la
    récupération à partir d'une archive contenant plusieurs timelines. Du
    coup, elles sont archivées dans l'aire des WAL comme tous les fichiers
    segment WAL. Les fichiers historiques sont de simples fichiers texte,
    donc il est peu coûteux et approprié de les conserver indéfiniment
    (contrairement aux fichiers segments qui sont gros). Vous pouvez, si
    vous le souhaitez, ajouter des commentaires au fichier historique pour
    ajouter vos propres notes sur comment et pourquoi cette timeline
    est particulièrement intéressante. De tels commentaires seront
    particulièrement utiles quand vous avez un ticket des différentes
    timelines comme résultat de l'expérimentation.
   </para>

   <para>
    Le comportement par défaut de la récupération est de récupérer parmi la
    timeline en cours au moment où la sauvegarde de base a été effectuée. Si
    vous voulez récupérer à une timeline enfant (c'est-à-dire si vous voulez
    retourner à un état qui a été enregistré après la tentative de
    récupération), vous avez besoin de spécifier l'ID cible de la timeline
    dans <filename>recovery.conf</filename>. Vous ne pouvez pas récupérer des
    timelines qui ont effectué leur branchement plus tôt que le moment où
    a été effectuée la sauvegarde de base.
   </para>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
   <title>Avertissements</title>

   <para>
    Au moment où nous écrivons ces lignes, il existe plusieurs limitations
    sur la technique de l'achivage continu. Elles seront probablement
    corrigées dans une prochaine version&nbsp;:

  <itemizedlist>
   <listitem>
    <para>
     Les opérations sur des index hachés
     ne sont pas tracées actuellement dans les WAL, donc ces index
     ne seront pas mis à jour. Le contournement recommandé est de
     <command>REINDEX</command>er manuellement chacun de ces index après avoir
     terminé une opération de récupération.
    </para>
   </listitem>

   <listitem>
    <para>
     Si une commande <command>CREATE DATABASE</command> est exécutée alors qu'une
     sauvegarde est en cours, alors la base de données modèle que l'instruction
     <command>CREATE DATABASE</command> a copié est modifiée alors que la sauvegarde
     de la base est toujours en cours, il est possible que la récupération
     sera la cause de la propagation des modifications dans la base de données
     créée. Pour éviter ce risque, il est préférable de ne pas modifier les
     bases de données modèles lors d'une sauvegarde de base.
    </para>
   </listitem>

   <listitem>
    <para>
     Les commandes <command>CREATE TABLESPACE</command> sont tracées dans WAL avec le
     chemin absolu littéral et seront donc rejouées en tant que créations
     d'espaces logiques avec le même chemin absolu. Ceci pourrait être
     indésirable si la trace est rejouée sur la même machine mais dans un
     nouveau répertoire de données&nbsp;: la ré-exécution surchargera toujours
     le contenu de l'espace logique original. Pour éviter des problèmes
     potentiels de cette sorte, la meilleure pratique est de prendre une
     nouvelle sauvegarde de base après la création ou la suppression d'espaces
     logiques.
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <para>
    De plus, il devrait être noté que le format actuel des <acronym>WAL</acronym>
    est extrêmement difficile à gérer car il inclut de nombreuses images des
    pages disques. Ces images de page sont conçues pour supporter la
    récupération après un arrêt brutal car nous pouvons avoir besoin de
    corriger des pages disque partiellement écrites. Suivant le matériel et
    le logiciel de votre système, le risque d'écriture partielle pourrait être
    assez faible pour être ignoré, auquel cas vous pouvez réduire
    significativement le volume total des traces archivées en désactivat les
    images de page grâce au paramètre <xref linkend="guc-full-page-writes"/>
    (lire les notes et avertissements dans <xref linkend="wal"/> avant
    de le faire). Désactiver les images de page n'empêche pas l'utilisation des
    traces pour les opérations PITR. Un développement possible serait de
    compresser les données des WAL archivées en supprimant les copies
    inutiles de pages même si <varname>full_page_writes</varname> est actif. Entre
    temps, les administrateurs pourraient souhaiter réduire le nombre
    d'images de pages inclus dans WAL en augmentant autant que possible les
    paramètres d'intervalle des points de vérification.
   </para>
  </sect2>
 </sect1>

 <sect1 id="warm-standby">
  <title>Warm Standby Servers for High Availability</title>

  <indexterm zone="backup">
   <primary>Warm Standby</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>PITR Standby</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>Standby Server</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>Log Shipping</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>Witness Server</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>STONITH</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>High Availability</primary>
  </indexterm>

  <para>
   Continuous Archiving can be used to create a High Availability (HA)
   cluster configuration with one or more Standby Servers ready to take
   over operations in the case that the Primary Server fails. This
   capability is more widely known as Warm Standby Log Shipping.
  </para>

  <para>
   The Primary and Standby Server work together to provide this capability,
   though the servers are only loosely coupled. The Primary Server operates
   in Continuous Archiving mode, while the Standby Server operates in a
   continuous Recovery mode, reading the WAL files from the Primary. No
   changes to the database tables are required to enable this capability,
   so it offers a low administration overhead in comparison with other
   replication approaches. This configuration also has a very low
   performance impact on the Primary server.
  </para>

  <para>
   Directly moving WAL or "log" records from one database server to another
   is typically described as Log Shipping. PostgreSQL implements file-based
   Log Shipping, meaning WAL records are batched one file at a time. WAL
   files can be shipped easily and cheaply over any distance, whether it be
   to an adjacent system, another system on the same site or another system
   on the far side of the globe. The bandwidth required for this technique
   varies according to the transaction rate of the Primary Server.
   Record-based Log Shipping is also possible with custom-developed
   procedures, discussed in a later section. Future developments are likely
   to include options for synchronous and/or integrated record-based log
   shipping.
  </para>

  <para>
   It should be noted that the log shipping is asynchronous, i.e. the WAL
   records are shipped after transaction commit. As a result there can be a
   small window of data loss, should the Primary Server suffer a
   catastrophic failure. The window of data loss is minimised by the use of
   the archive_timeout parameter, which can be set as low as a few seconds
   if required. A very low setting can increase the bandwidth requirements
   for file shipping.
  </para>

  <para>
   The Standby server is not available for access, since it is continually
   performing recovery processing. Recovery performance is sufficiently
   good that the Standby will typically be only minutes away from full
   availability once it has been activated. As a result, we refer to this
   capability as a Warm Standby configuration that offers High
   Availability. Restoring a server from an archived base backup and
   rollforward can take considerably longer and so that technique only
   really offers a solution for Disaster Recovery, not HA.
  </para>

  <para>
   Other mechanisms for High Availability replication are available, both
   commercially and as open-source software.  
  </para>

  <para>
   In general, log shipping between servers running different release
   levels will not be possible. It is the policy of the PostgreSQL Worldwide
   Development Group not to make changes to disk formats during minor release
   upgrades, so it is likely that running different minor release levels 
   on Primary and Standby servers will work successfully. However, no
   formal support for that is offered and you are advised not to allow this
   to occur over long periods.
  </para>

  <sect2 id="warm-standby-planning">
   <title>Planning</title>

   <para>
    On the Standby server all tablespaces and paths will refer to similarly
    named mount points, so it is important to create the Primary and Standby
    servers so that they are as similar as possible, at least from the
    perspective of the database server. Furthermore, any CREATE TABLESPACE
    commands will be passed across as-is, so any new mount points must be
    created on both servers before they are used on the Primary. Hardware
    need not be the same, but experience shows that maintaining two
    identical systems is easier than maintaining two dissimilar ones over
    the whole lifetime of the application and system.
   </para>

   <para>
    There is no special mode required to enable a Standby server. The
    operations that occur on both Primary and Standby servers are entirely
    normal continuous archiving and recovery tasks. The primary point of
    contact between the two database servers is the archive of WAL files
    that both share: Primary writing to the archive, Standby reading from
    the archive. Care must be taken to ensure that WAL archives for separate
    servers do not become mixed together or confused.
   </para>

   <para>
    The magic that makes the two loosely coupled servers work together is
    simply a restore_command that waits for the next WAL file to be archived
    from the Primary. The restore_command is specified in the recovery.conf
    file on the Standby Server. Normal recovery processing would request a
    file from the WAL archive, causing an error if the file was unavailable.
    For Standby processing it is normal for the next file to be unavailable,
    so we must be patient and wait for it to appear. A waiting
    restore_command can be written as a custom script that loops after
    polling for the existence of the next WAL file. There must also be some
    way to trigger failover, which should interrupt the restore_command,
    break the loop and return a file not found error to the Standby Server.
    This then ends recovery and the Standby will then come up as a normal
    server.
   </para>

   <para>
    Sample code for the C version of the restore_command would be be:
<programlisting>
triggered = false;
while (!NextWALFileReady() && !triggered)
{
    sleep(100000L);         // wait for ~0.1 sec
    if (CheckForExternalTrigger())
        triggered = true;
}
if (!triggered)
        CopyWALFileForRecovery();
</programlisting>
   </para>

   <para>
    PostgreSQL does not provide the system software required to identify a
    failure on the Primary and notify the Standby system and then the
    Standby database server. Many such tools exist and are well integrated
    with other aspects of a system failover, such as ip address migration.
   </para>

   <para>
    Triggering failover is an important part of planning and design. The
    restore_command is executed in full once for each WAL file. The process
    running the restore_command is therefore created and dies for each file,
    so there is no daemon or server process and so we cannot use signals and
    a signal handler. A more permanent notification is required to trigger
    the failover. It is possible to use a simple timeout facility,
    especially if used in conjunction with a known archive_timeout setting
    on the Primary. This is somewhat error prone since a network or busy
    Primary server might be sufficient to initiate failover. A notification
    mechanism such as the explicit creation of a trigger file is less error
    prone, if this can be arranged.
   </para>
  </sect2>

  <sect2 id="warm-standby-config">
   <title>Implementation</title>

   <para>
    The short procedure for configuring a Standby Server is as follows. For
    full details of each step, refer to previous sections as noted.
    <orderedlist>
     <listitem>
      <para>
       Set up Primary and Standby systems as near identically as possible,
       including two identical copies of PostgreSQL at same release level.
      </para>
     </listitem>
     <listitem>
      <para>
       Set up Continuous Archiving from the Primary to a WAL archive located
       in a directory on the Standby Server. Ensure that both <xref
       linkend="guc-archive-command"> and <xref linkend="guc-archive-timeout">
       are set. (See <xref linkend="backup-archiving-wal">)
      </para>
     </listitem>
     <listitem>
      <para>
       Make a Base Backup of the Primary Server. (See <xref
       linkend="backup-base-backup">)
      </para>
     </listitem>
     <listitem>
      <para>
       Begin recovery on the Standby Server from the local WAL archive,
       using a recovery.conf that specifies a restore_command that waits as
       described previously. (See <xref linkend="backup-pitr-recovery">)
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    Recovery treats the WAL Archive as read-only, so once a WAL file has
    been copied to the Standby system it can be copied to tape at the same
    time as it is being used by the Standby database server to recover.
    Thus, running a Standby Server for High Availability can be performed at
    the same time as files are stored for longer term Disaster Recovery
    purposes. 
   </para>

   <para>
    For testing purposes, it is possible to run both Primary and Standby
    servers on the same system. This does not provide any worthwhile
    improvement on server robustness, nor would it be described as HA.
   </para>
  </sect2>

  <sect2 id="warm-standby-failover">
   <title>Failover</title>

   <para>
    If the Primary Server fails then the Standby Server should begin
    failover procedures.
   </para>

   <para>
    If the Standby Server fails then no failover need take place. If the
    Standby Server can be restarted, even some time later, then the recovery
    process can also be immediately restarted, taking advantage of 
    Restartable Recovery. If the Standby Server cannot be restarted, then a
    full new Standby Server should be created.
   </para>

   <para>
    If the Primary Server fails and then immediately restarts, you must have
    a mechanism for informing it that it is no longer the Primary. This is
    sometimes known as STONITH (Shoot the Other Node In The Head), which is
    necessary to avoid situations where both systems think they are the
    Primary, which can lead to confusion and ultimately data loss.
   </para>

   <para>
    Many failover systems use just two systems, the Primary and the Standby,
    connected by some kind of heartbeat mechanism to continually verify the
    connectivity between the two and the viability of the Primary. It is
    also possible to use a third system, known as a Witness Server to avoid
    some problems of inappropriate failover, but the additional complexity
    may not be worthwhile unless it is set-up with sufficient care and
    rigorous testing.
   </para>

   <para>
    At the instant that failover takes place to the Standby, we have only a
    single server in operation. This is known as a degenerate state.
    The former Standby is now the Primary, but the former Primary is down 
    and may stay down. We must now fully re-create a Standby server, 
    either on the former Primary system when it comes up, or on a third, 
    possibly new, system. Once complete the Primary and Standby can be 
    considered to have switched roles. Some people choose to use a third 
    server to provide additional protection across the failover interval, 
    though clearly this complicates the system configuration and 
    operational processes (and this can also act as a Witness Server).
   </para>

   <para>
    So, switching from Primary to Standby Server can be fast but requires
    some time to re-prepare the failover cluster. Regular switching from
    Primary to Standby is encouraged, since it allows the regular downtime
    that each system requires to maintain HA. This also acts as a test of the
    failover mechanism so that it definitely works when you really need it. 
    Written administration procedures are advised.
   </para>
  </sect2>

  <sect2 id="warm-standby-record">
   <title>Implementing Record-based Log Shipping</title>

   <para>
    The main features for Log Shipping in this release are based
    around the file-based Log Shipping described above. It is also
    possible to implement record-based Log Shipping using the
    <function>pg_xlogfile_name_offset</function> function (see <xref
    linkend="functions-admin">), though this requires custom
    development.
   </para>

   <para>
    An external program can call pg_xlogfile_name_offset() to find out the
    filename and the exact byte offset within it of the latest WAL pointer.
    If the external program regularly polls the server it can find out how
    far forward the pointer has moved. It can then access the WAL file
    directly and copy those bytes across to a less up-to-date copy on a
    Standby Server.
   </para>
  </sect2>
 </sect1>

 <sect1 id="migration">
  <title>Migration entre les différentes versions</title>

  <indexterm zone="migration">
   <primary>mise à jour</primary>
  </indexterm>

  <indexterm zone="migration">
   <primary>version</primary>
   <secondary>compatibilité</secondary>
  </indexterm>

  <para>
   Cette section discute de la façon de migrer vos données de la base à partir
   d'une version de <productname>PostgreSQL</productname> vers une autre, plus récente. La
   procédure d'installation du logiciel <foreignphrase>per se</foreignphrase> n'est pas le
   sujet de cette section&nbsp;; ces détails sont dans le <xref
   linkend="installation"/>.
  </para>

  <para>
   En règle générale, le format interne des données est modifié entre les 
   différentes versions de <productname>PostgreSQL</productname> (quand le nombre après le
   deuxième point change). Ceci ne s'applique pas entre les différentes sorties
   mineures ayant le même numéro de version majeur (quand le nombre après le
   deuxième point change)&nbsp;; elles ont toujours un format de stockage
   compatible.
   Par exemple, les versions 7.2.1, 7.3.2 et 7.4 ne sont pas compatibles, alors
   que les versions 7.2.1 et 7.2.2 le sont. Lorsque vous mettez à jour entre 
   des versions compatibles, vous pouvez simplement remplacer les exécutables et
   ré-utiliser le répertoire des données sur le disque. Sinon, vous avez besoin
   de sauvegarder vos données et de les restaurer sur le nouveau serveur. Ceci
   doit se faire en utilisant <application>pg_dump</application>&nbsp;; les méthodes de
   sauvegarde au niveau système de fichiers ne fonctionneront évidemment pas. Il
   existe des vérifications en place pour vous empêcher d'utiliser un répertoire
   de données d'une version incompatible version de
   <productname>PostgreSQL</productname>, donc aucun mal ne sera fait si vous
   essayez de lancer un serveur d'une mauvaise version dans un répertoire de
   données.
  </para>

  <para>
   Il est recommandé d'utiliser les programmes <application>pg_dump</application> et
   <application>pg_dumpall</application> à partir de la nouvelle version de
   <productname>PostgreSQL</productname>, pour utiliser les avantages de toutes
   améliorations effectuées sur ces programmes. Les versions actuelles des
   programmes de sauvegarde peuvent lire des données à partir des serveurs
   d'anciennes versions, jusqu'à la 7.0.
  </para>

  <para>
   Vous minimiserez la durée d'indisponibilité en installant le nouveau serveur
   dans un répertoire différent et en lançant l'ancien et le nouveau serveur en 
   parallèle sur des ports différents, puis en utilisant des commandes comme
 
<programlisting>pg_dumpall -p 5432 | psql -d postgres -p 6543</programlisting>

   pour transférer les données. Ou utilisez un fichier intermédiaire si vous
   voulez. Vous pouvez alors éteindre le nouveau serveur et démarrer le nouveau
   sur le port que l'ancien utilisait. Vous devez vous assurer que l'ancienne
   base de données n'est pas modifiée après que vous ayez lancé 
   <application>pg_dumpall</application>, sans quoi ces modifications seraient évidemment 
   perdues. Référez vous au <xref linkend="client-authentication"/> pour savoir 
   comment interdire l'accès.
  </para>
  
  <para>
   En pratique, vous voudrez certainement tester votre application sur le
   nouveau serveur avant de basculer définitivement. C'est une autre raison
   pour configurer des installations concurrentes avec l'ancienne et la nouvelle
   version.
  </para>

  <para>
   Si vous ne pouvez pas ou ne voulez pas lancer les deux serveurs en 
   parallèle, vous pouvez faire l'étape de sauvegarde avant d'installer la 
   nouvelle version, éteindre le serveur, déplacer l'ancienne version à un autre
   endroit, installer la nouvelle, la démarrer et enfin restaurer les données. Par
   exemple&nbsp;:
   
<programlisting>pg_dumpall &gt; sauvegarde.sql
pg_ctl stop
mv /usr/local/pgsql /usr/local/pgsql.old
cd ~/postgresql-&version;
gmake install
initdb -D /usr/local/pgsql/data
postgres -D /usr/local/pgsql/data
psql -f sauvegarde.sql postgres</programlisting>

   Vous trouverez les méthodes pour arrêter et démarrer les serveurs, ainsi que 
   d'autres détails dans le <xref linkend="runtime"/>.
   Les instructions d'installation vous donneront des conseils sur les endroits 
   stratégiques pour réaliser ces opérations.
  </para>

  <note>
   <para>
    Quand vous <quote>déplacez l'ancienne version à un autre endroit</quote>, 
    l'ancienne installation pourrait ne plus être tout à fait utilisable.
    Certains des exécutables contiennent les chemins absolus vers les
    différents programmes et fichiers de données installés. Ceci n'est
    habituellement pas un gros problème mais si vous planifiez d'utiliser deux
    installations en parallèle pendant un moment, vous devez leur affecter des
    répertoires d'installation différents au moment de la construction. (Ce
    problème est rectifié pour <productname>PostgreSQL</productname> 8.0 et ultérieurs mais
    vous devez faire bien attention à déplacer les anciennes installations.)
   </para>
  </note>
 </sect1>
</chapter>
