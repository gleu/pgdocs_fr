<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/explain.sgml,v 1.7.2.1 2005/03/14 06:03:02 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="SQL-EXPLAIN">
 <refmeta>
  <refentrytitle id="SQL-EXPLAIN-TITLE">EXPLAIN</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>EXPLAIN</refname>
  <refpurpose>affiche le plan d'exécution d'une instruction</refpurpose>
 </refnamediv>

 <indexterm zone="sql-explain">
  <primary>EXPLAIN</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
EXPLAIN [ ANALYZE ] [ VERBOSE ] <replaceable
class="parameter">instruction</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   Cette commande affiche le plan d'exécution que le planificateur
   <productname>PostgreSQL</productname> génère pour l'instruction fournie. Le
   plan d'exécution affiche comment le(s) table(s) référencée(s) par
   l'instruction seront parcourue(s) --- parcours séquentiel, parcours d'index,
   etc. --- et si plusieurs tables sont référencées, quels algorithmes de
   jointure seront utilisés pour amener la ligne requise à partir de chaque
   table en entrée.
  </para>

  <para>
   La partie la plus critique de l'affichage est le coût d'exécution estimé de
   l'instruction, qui est l'impression que le planificateur a sur la durée que
   prendra l'exécution de l'instruction (mesuré en unité de récupération de
   pages disque). En fait, deux nombres sont affichés&nbsp;: le temps en
   exécution avant que la première ligne ne soit renvoyée et le temps total pour
   renvoyer toutes les lignes. Pour la plupart des requêtes, le temps total est
   ce qui importe mais dans des contextes telles qu'une sous-requête dans
   <literal>EXISTS</literal>, le planificateur choisira le plus petit temps de
   lancement plutôt que le plus petit temps total (car, de toute façon,
   l'exécuteur s'arrêtera après avoir récupéré une ligne). De même, si vous
   limitez le nombre de lignes à renvoyer avec une clause
   <literal>LIMIT</literal>, le planificateur fera une interpolation appropriée
   entre les coûts aux points finaux pour estimer le plan le moins cher.
  </para>

  <para>
   L'option <literal>ANALYZE</literal> fait que l'instruction sera réellement 
   exécutée, pas uniquement planifiée. Le temps total passé sur chaque
   n&oelig;ud du plan (en millisecondes) et le nombre total de lignes renvoyées
   sont ajoutés à l'affichage. Ceci est utile pour voir si les estimations du
   planificateur sont proches de la réalité.
  </para>

  <important>
   <para>
    Gardez en tête que l'instruction est réellement exécutée quand
    <literal>ANALYZE</literal> est utilisé. Bien que <command>EXPLAIN</command>
    annulera tout affichage qu'un <command>SELECT</command> renverrait, les
    autres effets immédiats de l'instruction auront lieu. Si vous souhaitez
    utiliser <command>EXPLAIN ANALYZE</command> sur une instruction
    <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command> ou <command>EXECUTE</command> sans que la commande
    n'affecte vos données, utilisez cette approche&nbsp;:
<programlisting>
BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;
</programlisting>
   </para>
  </important>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><literal>ANALYZE</literal></term>
    <listitem>
     <para>
      Exécute la commande et affiche les temps d'exécution réels.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <para>
      Affiche la représentation interne complète du plan plutôt qu'un simple
      résumé. Utiliser cette option est seulement utile pour déboguer
      <productname>PostgreSQL</productname>. La sortie
      <literal>VERBOSE</literal> peut être joliment affichée, suivant le
      paramètre de configuration <varname>explain_pretty_print</varname>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">instruction</replaceable></term>
    <listitem>
     <para>
      Toute instruction <command>SELECT</>, <command>INSERT</>,
      <command>UPDATE</>, <command>DELETE</>, <command>EXECUTE</> ou
      <command>DECLARE</> dont vous souhaitez voir le plan d'exécution.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   La documentation sur l'utilisation de l'optimiseur des informations de coût
   est assez spartiate dans <productname>PostgreSQL</productname>. Référez-vous
   à <xref linkend="using-explain"> pour plus d'informations.
  </para>

  <para>
   Pour permettre au planificateur de requêtes de
   <productname>PostgreSQL</productname> de prendre des décisions
   raisonnables lors de l'optimisation de requêtes, l'instruction
   <command>ANALYZE</command> devrait être exécutée pour enregistrer les
   statistiques sur la distribution des données à l'intérieur de la table. Si
   vous n'avez pas fait ceci (ou si la distribution statistique des données dans
   la table a changé significativement depuis la dernière exécution
   d'<command>ANALYZE</command>), les coûts estimés ne seront pas conformes aux
   réelles propriétés de la requête et, par conséquence, un plan de requête
   inférieur pourrait être choisi.
  </para>

  <para>
   Avant <productname>PostgreSQL</productname> 7.3, le plan était émis sous la
   forme d'un message <literal>NOTICE</literal>. Maintenant, il apparaît comme
   le résultat d'une requête (formaté comme une table composée d'une seule
   colonne de type texte).
  </para>
 </refsect1>

 <refsect1>
  <title>Exemples</title>

  <para>
   Pour afficher le plan d'une simple requête sur une table avec une seule
   colonne de type <type>integer</type> et 10000 lignes&nbsp;:

<programlisting>
EXPLAIN SELECT * FROM foo;

                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)
(1 row)
</programlisting>
  </para>

  <para>
   S'il existe un index et que nous utilisons une requête avec un condition
   <literal>WHERE</literal> indexable, <command>EXPLAIN</command> pourrait
   afficher un plan différent&nbsp;:

<programlisting>
EXPLAIN SELECT * FROM foo WHERE i = 4;

                         QUERY PLAN
--------------------------------------------------------------
 Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)
   Index Cond: (i = 4)
(2 rows)
</programlisting>
  </para>

  <para>
   Et voici un exemple d'un plan de requête pour une requête utilisant une
   fonction d'agrégat&nbsp;:

<programlisting>
EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;

                             QUERY PLAN
---------------------------------------------------------------------
 Aggregate  (cost=23.93..23.93 rows=1 width=4)
   -&gt;  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)
         Index Cond: (i &lt; 10)
(3 rows)
</programlisting>
  </para>

  <para>
   Voici un exemple d'utilisation de <command>EXPLAIN EXECUTE</command> pour
   afficher le plan d'exécution d'une requête préparée&nbsp;:

<programlisting>
PREPARE query(int, int) AS SELECT sum(bar) FROM test
    WHERE id &gt; $1 AND id &lt; $2
    GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

                                                       QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=39.53..39.53 rows=1 width=8) (actual time=0.661..0.672 rows=7 loops=1)
   -&gt;  Index Scan using test_pkey on test  (cost=0.00..32.97 rows=1311 width=8) (actual time=0.050..0.395 rows=99 loops=1)
         Index Cond: ((id &gt; $1) AND (id &lt; $2))
 Total runtime: 0.851 ms
(4 rows)
</programlisting>
  </para>

  <para>
   Bien sûr, les nombres spécifiques dépendent ici du contenu réel des tables
   impliquées. Notez aussi que les nombres, et même la stratégie de la requête
   sélectionnée, pourrait varier entre les versions de
   <productname>PostgreSQL</productname> à cause des améliorations du
   planificateur. De plus, la commande <command>ANALYZE</command> utilise une
   distribution aléatoire pour estimer les statistiques des données&nbsp;; du
   coup, il est possible que les estimations de coût changent après un lancement
   d'<command>ANALYZE</command>, même si la distribution réelle des données n'a
   pas changé dans la table.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   Il n'existe pas d'instruction <command>EXPLAIN</command> définie dans le
   standard SQL.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
