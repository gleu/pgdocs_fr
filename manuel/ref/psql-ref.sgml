<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/psql-ref.sgml,v 1.5.2.3 2005/08/06 10:14:56 guillaume Exp $
PostgreSQL documentation
-->

<refentry id="APP-PSQL">
  <refmeta>
    <refentrytitle id="app-psql-title"><application>psql</application></refentrytitle>
    <manvolnum>1</manvolnum>
    <refmiscinfo>Application</refmiscinfo>
  </refmeta>

  <refnamediv>
    <refname><application>psql</application></refname>
    <refpurpose>
      terminal interactif <productname>PostgreSQL</productname>
    </refpurpose>
  </refnamediv>

 <indexterm zone="app-psql">
  <primary>psql</primary>
 </indexterm>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>psql</command>
   <arg rep="repeat"><replaceable class="parameter">option</replaceable></arg>
   <arg><replaceable class="parameter">nombase</replaceable>
   <arg><replaceable class="parameter">nomutilisateur</replaceable></arg></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

    <para>
     <application>psql</application> est une interface basée sur une console
     pour <productname>PostgreSQL</productname>. Il vous permet de saisir des
     requêtes de façon interactive, de les exécuter sur
     <productname>PostgreSQL</productname> et de voir les résultats de cette
     requête. Autrement, les entrées peuvent êtres lues à partir d'un fichier.
     De plus, il fournit un certain nombre de méta-commandes et plusieurs
     fonctionnalités style shell pour faciliter l'écriture des scripts et
     automatiser un nombre varié de tâches.
    </para>
 </refsect1>

 <refsect1 id="R1-APP-PSQL-3">
  <title>Options</title>

  <variablelist>
    <varlistentry>
      <term><option>-a</></term>
      <term><option>--echo-all</></term>
      <listitem>
      <para>
      Affiche toutes les lignes à l'écran lorsqu'elles sont lues. Ceci est plus
     utile dans le traitement de scripts que dans le mode interactif. C'est
     équivalent à initialiser la variable <varname>ECHO</varname> à
     <literal>all</literal>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-A</></term>
      <term><option>--no-align</></term>
      <listitem>
      <para>
      Bascule dans le mode d'affichage non aligné. (Le mode d'affichage par
      défaut est aligné.)
      </para>
      </listitem>
    </varlistentry>
	
    <varlistentry>
      <term><option>-c <replaceable
	class="parameter">commande</replaceable></></term>
      <term><option>--command <replaceable
	class="parameter">commande</replaceable></></term>
      <listitem>
      <para>
      Spécifie que <application>psql</application> doit exécuter une chaîne de
      commande, <replaceable class="parameter">commande</replaceable>, puis
      quitter. Ceci est utile dans les scripts shell.
      </para>
      <para>
      <replaceable class="parameter">commande</replaceable> doit être soit une
      chaîne de commande complètement analysable par le serveur (c'est-à-dire
      qu'il ne contient aucune des fonctionnalités spécifiques de
      <application>psql</application>), où il s'agit d'une seule commande
      antislash. Du coup, vous ne pouvez pas mixer les commandes
      <acronym>SQL</acronym> et les méta-commandes
      <application>psql</application>. Pour réussir ceci, vous pouvez envoyer la
      chaîne dans un tube vers <application>psql</application> comme ceci&nbsp;:
<literal>echo "\x \\
      select * from foo;" | psql</literal>.
      </para>
      <para>
       Si la chaîne de commande contient plusieurs commandes SQL, elles sont
       traitées dans une seule transaction sauf si des commandes BEGIN/COMMIT
       explicites sont inclus dans la chaîne pour la diviser en plusieurs
       transactions. Ceci est différent du comportement adopté quand la même
       chaîne est envoyée dans l'entrée standard de
       <application>psql</application>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-d <replaceable
	class="parameter">nombase</replaceable></></term>
      <term><option>--dbname <replaceable
	class="parameter">nombase</replaceable></></term>
      <listitem>
      <para>
      Spécifie le nom de la base de données où se connecter. Ceci est
      équivalent à spécifier <replaceable
      class="parameter">nombase</replaceable> comme premier argument de la
      ligne de commande qui n'est pas une option.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-e</></term>
      <term><option>--echo-queries</></term>
      <listitem>
      <para>
      Affiche toutes les commandes qui sont envoyées au serveur. Ceci est
      équivalent à initialiser la variable <varname>ECHO</varname> à
      <literal>queries</literal>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-E</></term>
      <term><option>--echo-hidden</></term>
      <listitem>
      <para>
      Affiche les requêtes réelles générées par <command>\d</command> et autres
      commandes antislash. Vous pouvez utiliser ceci si vous décidez d'inclure
      une fonctionnalité similaire dans vos propres programmes. Ceci est
      équivalent à initialiser la variable <varname>ECHO_HIDDEN</varname> à
      l'intérieur de <application>psql</application>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-f <replaceable
	class="parameter">nomfichier</replaceable></></term>
      <term><option>--file <replaceable
	class="parameter">nomfichier</replaceable></></term>
      <listitem>
      <para>
      Utilisez le fichier <replaceable
      class="parameter">nomfichier</replaceable> comme source des commandes au
      lieu de lire les commandes de façon interactive. Une fois que le fichier
      est entièrement traité, <application>psql</application> se termine. Ceci
      est équivalent dans bien des cas à la commande interne
      <command>\i</command>.
      </para>

      <para>
       Si <replaceable>nomfichier</replaceable> est un <literal>-</literal>
       (tiret), alors l'entrée standard est lue.
      </para>

      <para>
      Utiliser cette option est légèrement différent d'écrire <literal>psql
      &lt; <replaceable class="parameter">nomfichier</replaceable></literal>. En
      général, les deux feront ce que vous souhaitez mais utiliser
      <literal>-f</literal> active certaines fonctionnalités intéressantes
      comme les messages d'erreur avec les numéros de ligne. Il y a aussi une
      légère chance qu'utiliser cette option réduira la surcharge du lancement.
      D'un autre côté, la variante utilisant la redirection de l'entrée du shell
      est (en théorie) garantie pour ramener exactement le même affichage que
      vous avez eu en saisissant tout manuellement.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-F <replaceable
	class="parameter">séparateur</replaceable></></term>
      <term><option>--field-separator <replaceable
	class="parameter">séparateur</replaceable></></term>
      <listitem>
      <para>
      Utilisez <replaceable class="parameter">séparateur</replaceable> comme
      champ séparateur. Ceci est équivalent à <command>\pset fieldsep</command>
      ou <command>\f</command>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-h <replaceable
	class="parameter">nomhôte</replaceable></></term>
      <term><option>--host <replaceable
	class="parameter">nomhôte</replaceable></></term>
      <listitem>
      <para>
      Spécifie le nom de l'hôte de la machine sur lequel le serveur est en cours
      d'exécution. Si la valeur commence avec un slash, elle est utilisée comme
      répertoire du socket de domaine Unix.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-H</></term>
      <term><option>--html</></term>
      <listitem>
      <para>
      Active l'affichage en tableau <acronym>HTML</acronym>. Ceci est
      équivalent à <literal>\pset format html</literal> ou à la commande
      <command>\H</command>.
      </para>
      </listitem>
    </varlistentry>
 
    <varlistentry>
      <term><option>-l</></term>
      <term><option>--list</></term>
      <listitem>
      <para>
      Liste toutes les bases de données disponibles puis quitter. Les autres
      option non relatives à la connexion sont ignorées. Ceci est similaire à la
      commande interne <command>\list</command>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-n</></term>
      <term><option>--no-readline</></term>
      <listitem>
      <para>
       N'utilise pas readline pour l'édition de ligne et n'utilise pas
       l'historique. Ceci est utile quand on veut désactiver la gestion de la
       tabulation pour l'action copie/colle.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-o <replaceable
	class="parameter">nomfichier</replaceable></></term>
      <term><option>--output <replaceable
	class="parameter">nomfichier</replaceable></></term>
      <listitem>
      <para>
      Place tous les affichages de fichiers dans le fichier <replaceable
      class="parameter">nomfichier</replaceable>. Ceci est équivalent à la
      commande <command>\o</command>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-p <replaceable class="parameter">port</replaceable></></term>
      <term><option>--port <replaceable class="parameter">port</replaceable></></term>
      <listitem>
      <para>
      Spécifie le port TCP ou l'extension du fichier socket de domaine local
      Unix sur lequel le serveur attend les connexions. Par défaut, il s'agit de
      la valeur de la variable d'environnement <envar>PGPORT</envar> ou, si elle
      n'est pas initialisée, le port spécifié au moment de la compilation,
      habituellement 5432.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-P <replaceable
	class="parameter">affectation</replaceable></></term>
      <term><option>--pset <replaceable
	class="parameter">affectation</replaceable></></term>
      <listitem>
      <para>
      Vous permet de spécifier les options d'affichage dans le style de
      <command>\pset</command> sur la ligne de commande. Notez que, ici, vous
      devez séparer nom et valeur avec un signe égal au lieu d'un espace. Du
      coup, pour initialiser le format d'affichage en LaTeX, vous devez écrire
      <literal>-P format=latex</literal>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-q</></term>
      <term><option>--quiet</></term>
      <listitem>
      <para>
      Spécifie que <application>psql</application> devra travailler
      silencieusement. Par défaut, il affiche des messages de bienvenue et des
      informations diverses. Si cette option est utilisée, rien de ceci
      n'arrivera. C'est utile avec l'option <option>-c</option>. À l'intérieur
      de <application>psql</application>, vous pouvez aussi initialiser la
      variable <varname>QUIET</varname> pour arriver au même effet.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-R <replaceable
	class="parameter">séparateur</replaceable></></term>
      <term><option>--record-separator <replaceable
	class="parameter">séparateur</replaceable></></term>
      <listitem>
      <para>
      Utilisez <replaceable class="parameter">séparateur</replaceable> comme
      séparateur d'enregistrement. Ceci est équivalent à la commande
      <command>\pset recordsep</command>.
      </para>
      </listitem>
    </varlistentry>
 
    <varlistentry>
      <term><option>-s</></term>
      <term><option>--single-step</></term>
      <listitem>
      <para>
      S'exécute en mode étape par étape. Ceci signifie qu'une
      intervention de l'utilisateur est nécessaire avant l'envoi de chaque
      commande au serveur, avec une option pour annuler l'exécution. Utilisez
      ceci pour déboguer des scripts.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-S</></term>
      <term><option>--single-line</></term>
      <listitem>
      <para>
      S'exécute en mode simple ligne où une nouvelle ligne termine une commande
      SQL, comme un point-virgule.
      </para>

      <note>
      <para>
      Ce mode est fourni pour ceux qui insistent mais vous n'êtes pas
      nécessairement encouragé à l'utiliser. En particulier, si vous mixez
      <acronym>SQL</acronym> et méta-commandes sur une ligne, l'ordre
      d'exécution ne sera pas toujours clair pour l'utilisateur non expérimenté.
      </para>
      </note>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-t</></term>
      <term><option>--tuples-only</></term>
      <listitem>
      <para>
      Désactive l'affichage des noms de colonnes et le pied de page
      contenant le nombre de résultats, etc. C'est totalement équivalent à la
      méta-commande <command>\t</command>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-T <replaceable
	class="parameter">options_table</replaceable></></term>
      <term><option>--table-attr <replaceable
	class="parameter">options_table</replaceable></></term>
      <listitem>
      <para>
      Permet de spécifier les options à placer à l'intérieur d'une balise
      <sgmltag>table</sgmltag> en <acronym>HTML</acronym>. Voir
      <command>\pset</command> pour plus de détails.
      </para>
      </listitem>
    </varlistentry>
 
    <varlistentry>
      <term><option>-u</></term>
      <listitem>
      <para>
      Fait que <application>psql</application> demande le nom et le mot de
      passe de l'utilisateur avant de se connecter à la base de données.
      </para>

      <para>
      Cette option est obsolète, car elle est conceptuellement mauvaise.
      (Demander un nom d'utilisateur et demander un mot de passe parce que le
      serveur l'exige sont deux choses tout à fait différentes.) Vous êtes
      encouragé à regarder les options <option>-U</option> et
      <option>-W</option> à la place.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-U <replaceable
	class="parameter">nomutilisateur</replaceable></></term>
      <term><option>--username <replaceable
	class="parameter">nomutilisateur</replaceable></></term>
      <listitem>
      <para>
      Se connecte à la base de données en tant que l'utilisateur <replaceable
      class="parameter">nomutilisateur</replaceable> au lieu de celui par
      défaut. (Vous devez aussi avoir le droit de le faire, bien sûr.)
      </para> 
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-v <replaceable
	class="parameter">affectation</replaceable></></term>
      <term><option>--set <replaceable
	class="parameter">affectation</replaceable></></term>
      <term><option>--variable <replaceable
	class="parameter">affectation</replaceable></></term>
      <listitem>
      <para>
      Réalise une affectation de variable comme la commande interne
      <command>\set</command>. Notez que vous devez séparer nom et valeur par
      un signe égal sur la ligne de commande. Pour désinitialiser une variable,
      enlevez le signe d'égalité. Pour simplement initialiser une variable sans
      valeur, utilisez le signe égal sans passer de valeur. Ces affectations
      sont réalisées lors de la toute première étape du lancement, du coup les
      variables réservées à des buts internes pourraient être écrasées plus
      tard.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-V</></term>
      <term><option>--version</></term>
      <listitem>
      <para>
      Affiche la version de <application>psql</application>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-W</></term>
      <term><option>--password</></term>
      <listitem>
      <para>
      Demande que <application>psql</application> affiche une demande de mot de
      passe avant de se connecter à une base de données. Ceci restera initialisé
      pour la session entière même si vous changez la base de données connectée
      avec la commande <command>\connect</command>.
      </para>

      <para>
      Dans la version actuelle, <application>psql</application> lance
      systématiquement une demande de mot de passe quand le serveur requiert une
      authentification par mot de passe. Parce que c'est actuellement basé sur
      un hack, la reconnaissance automatique pourrait mystérieusement échouée,
      ce qui explique cette option pour forcer une demande de mot de passe. Si
      aucune demande n'est affichée et que le serveur requiert une
      authentification par mot de passe, la tentative de connexion échouera.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-x</></term>
      <term><option>--expanded</></term>
      <listitem>
      <para>
      Active le mode de formatage de table étendue. Ceci est équivalent à la
      commande <command>\x</command>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-X,</></term>
      <term><option>--no-psqlrc</></term>
      <listitem>
      <para>
      Ne lit pas le fichier de démarrage <filename>~/.psqlrc</filename>.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><option>-?</></term>
      <term><option>--help</></term>
      <listitem>
      <para>
      Affiche de l'aide sur les arguments en ligne de commande de
      <application>psql</application>.
      </para>
      </listitem>
    </varlistentry>
  </variablelist>
 </refsect1>


 <refsect1>
  <title>Code de sortie</title>

  <para>
   <application>psql</application> renvoie 0 au shell s'il se termine
   normalement, 1 s'il y a eu une erreur fatale de son fait (pas assez de
   mémoire, fichier introuvable), 2 si la connexion au serveur s'est détériorée
   ou a été annulée, 3 si une erreur est survenue dans un script et la variable
   <varname>ON_ERROR_STOP</varname> a été initialisée.
  </para>
 </refsect1>


 <refsect1>
  <title>Usage</title>

  <refsect2 id="R2-APP-PSQL-connecting">
    <title>Se connecter à une base de données</title>

    <para>
    <application>psql</application> est une application client
    <productname>PostgreSQL</productname> standard. Pour se connecter à une
    base de données, vous avez besoin de connaître le nom de votre base de
    données cible, le nom de l'hôte et le numéro de port du serveur ainsi que le
    nom de l'utilisateur que vous souhaitez connecter.
    <application>psql</application> peut connaître ces paramètres à partir
    d'options en ligne de commande, nommément respectivement
    <option>-d</option>, <option>-h</option>, <option>-p</option> et
    <option>-U</option>. Si un argument est trouvé ne correspondant pas à une
    option, il sera interprété comme le nom de la base de données (ou le nom de
    l'utilisateur si le nom de la base de données est aussi donnée). Toutes les
    options ne sont pas requises, des valeurs par défaut sont applicables. Si
    vous omettez le nom de l'hôte , <application>psql</> se connectera via un
    socket de domaine Unix à un serveur sur l'hôte local. Le numéro de port par
    défaut est déterminé au moment de la compilation. Comme le serveur de bases
    de données utilise la même valeur par défaut, vous n'aurez pas besoin de
    spécifier le port dans la plupart des cas. Le nom de l'utilisateur par
    défaut est votre nom d'utilisateur Unix, de même pour le nom de la base de
    données par défaut. Notez que vous ne pouvez pas simplement vous connecter à
    une base de données avec n'importe quel nom d'utilisateur. Votre
    administrateur de bases de données devrait vous avoir informé de vos droits
    d'accès. Pour vous épargner des saisies, vous pouvez initialiser les
    variables d'environnement <envar>PGDATABASE</envar>, <envar>PGHOST</envar>,
    <envar>PGPORT</envar> et <envar>PGUSER</envar> par des valeurs appropriées.
    </para>

    <para>
    Si la connexion ne peut pas se faire quelqu'en soit la raison (c'est-à-dire
    droits non suffisants, serveur arrêté sur l'hôte cible, etc.),
    <application>psql</application> renverra une erreur et quittera.
    </para>
  </refsect2>

  <refsect2 id="R2-APP-PSQL-4">
    <title>Saisir des commandes SQL</title>

    <para>
    Dans le cas normal, <application>psql</application> fournit une invite avec
    le nom de la base de données sur laquelle <application>psql</application>
    est connecté suivi par la chaîne <literal>=&gt;</literal>. Par exemple,
<programlisting>
$ <userinput>psql testdb</userinput>
Welcome to psql &version;, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help on internal slash commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=>
</programlisting>
    </para>

    <para>
    À l'invite l'utilisateur peut saisir les commandes <acronym>SQL</acronym>.
    Ordinairement, les lignes en entrée sont envoyées vers le serveur quand un
    point-virgule de fin de commande est saisi. Une fin de ligne ne termine pas
    une commande. Du coup, les commandes peuvent être saisies sur plusieurs
    lignes pour plus de clarté. Si la commande est envoyée et sans erreur, les
    résultats de la commande sont affichés sur l'écran.
    </para>

    <para>
    À chaque fois qu'une commande est exécutée, <application>psql</application>
    vérifie aussi les événements de notification générés par
    <xref linkend="SQL-LISTEN" endterm="SQL-LISTEN-title"> et
    <xref linkend="SQL-NOTIFY" endterm="SQL-NOTIFY-title">.
    </para>
  </refsect2>

  <refsect2>
    <title>Meta-commandes</title>

    <para>
    Tout ce que vous saisissez dans <application>psql</application> qui
    commence par un antislash non échappé est une méta-commande
    <application>psql</application> qui est traité par
    <application>psql</application> lui-même. Ces commandes sont ce qui rend
    <application>psql</application> intéressant pour l'administration ou pour
    l'écriture de scripts. Les méta-commandes sont plus souvent appelées les
    commandes slash ou antislash.
    </para>

    <para>
    Le format d'une commande <application>psql</application> est l'antislash
    suivi immédiatement d'un verbe de commande et de ses arguments. Les
    arguments sont séparés du verbe de la commande et chacun par un nombre
    illimité d'espaces blancs.
    </para>

    <para>
    Pour inclure des espaces blancs dans un argument, vous devez l'envelopper
    dans des guillemets simples. Pour inclure un guillemet simple dans un
    argument, précédez-le d'un antislash. Tout ce qui est contenu entre des
    guillemets simples est plus sujet à des substitutions style C pour
    <literal>\n</literal> (nouvelle ligne), <literal>\t</literal> (tabulation),
    <literal>\</literal><replaceable>chiffres</replaceable>,
    <literal>\0</literal><replaceable>chiffres</replaceable> et
    <literal>\0x</literal><replaceable>chiffres</replaceable> (le caractère avec
    le code donné en décimal, octal ou hexadécimal).
    </para>

    <para>
    Si un argument sans guillemet commence avec un caractère
    <literal>:</literal>, il est pris pour une variable <application>psql</> et
    la valeur de la variable est utilisée à la place de l'argument.
    </para>

    <para>
    Les arguments placés entre guillemets arrières (<literal>`</literal>) sont
    pris comme une ligne de commande passée au shell. L'affichage de la commande
    (avec toute nouvelle ligne en fin supprimée) est pris comme valeur de
    l'argument. Cela s'applique aussi aux séquences d'échappement ci-dessus.
    </para>

    <para>
    Quelques commandes prennent un identifiant <acronym>SQL</acronym> (comme un
    nom de table) en argument. Ces arguments suivent les règles de la syntaxe
    <acronym>SQL</acronym>&nbsp;: les lettres sans guillemets sont forcés en
    minuscule alors que les guillemets doubles (<literal>"</>) protègent les
    lettres de la conversion de casse et autorisent l'incorporation d'espace
    blanc dans l'identifiant. À l'intérieur des guillemets doubles, les
    guillemets doubles en pair réduisent à un seul guillemet double dans le nom
    résultant. Par exemple, <literal>FOO"BAR"BAZ</> est interprété comme
    <literal>fooBARbaz</> et <literal>"A weird"" name"</> devient <literal>A
    weird" name</>.
    </para>

    <para>
    L'analyse des arguments se termine quand d'autres antislash non entre
    guillemets surviennent. Ceci est pris pour le début d'une nouvelle
    méta-commande. La séquence spéciale <literal>\\</literal> (deux antislashes)
    marque la fin des arguments et continue l'analyse des commandes
    <acronym>SQL</acronym>, s'ils existent. De cette façon, les commandes
    <acronym>SQL</acronym> et <application>psql</application> peuvent être
    mixées librement sur une ligne. Mais dans tous les cas, les arguments d'une
    meta-commande ne peut pas continuer après la fin de la ligne.
    </para>

    <para>
    Les meta-commandes suivantes sont définies&nbsp;:

    <variablelist>
      <varlistentry>
        <term><literal>\a</literal></term>
        <listitem>
        <para>
	Si le format actuel d'affichage d'une table est non aligné, il est
	basculé à aligné. S'il n'est pas non aligné, il devient non aligné.
	Cette commande est conservée pour des raisons de compatibilité. Voir
	<command>\pset</command> pour une solution générale.
        </para>
        </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>\cd</literal>
	<optional><replaceable>répertoire</replaceable></optional></term>
       <listitem>
        <para>
	 Modifie le répertoire courant par
	<replaceable>répertoire</replaceable>. Sans argument, modifie par le
	répertoire personnel de l'utilisateur.
        </para>

	<tip>
	 <para>
	  Pour afficher votre répertoire courant, utilisez
	  <literal>\! pwd</literal>.
	 </para>
	</tip>
       </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\C</literal> [ <replaceable
	class="parameter">titre</replaceable> ]</term>
        <listitem>
        <para>
        Initialise le titre de toute table en cours d'affichage avec le
	résultat d'une requête ou pour supprimer un tel titre. Cette commande
	est équivalent à <literal>\pset title <replaceable
	class="parameter">titte</replaceable></literal>. (Le nom de cette
	commande provient de <quote>caption</quote>, car elle avait précédemment
	pour seul but d'initialiser l'en-tête dans une table
	<acronym>HTML</acronym>.)
        </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\connect</literal> (or <literal>\c</literal>) [
<replaceable class="parameter">nomdb</replaceable> [ <replaceable
class="parameter">nomutilisateur</replaceable> ] ]</term>
        <listitem>
        <para>
	Établie une connexion à une nouvelle base de données et/ou sous un
	nom d'utilisateur. La connexion précédente est fermée. Si <replaceable
	class="parameter">nomdb</replaceable> est <literal>-</literal>, le nom
	de la base de données actuelle est supposé.
	</para>

	<para>
	Si <replaceable class="parameter">nomutilisateur</replaceable> est
	omis, le nom de l'utilisateur courant est supposé. </para>

	<para>
	Comme règle spéciale, <command>\connect</command> sans autre
	argument se connectera à la base de données par défaut en tant que l'
	utilisateur par défaut (comme ce que vous auriez obtenu en lançant 
	<application>psql</application> sans arguments).
	</para>

	<para>
	Si la tentative de connexion échoue (mauvais nom utilisateur, accès
	interdit, etc.), la connexion précédente sera conservée si et seulement
	si <application>psql</application> est en mode interactif. Lorsqu'il
	exécute un script non interactif, le traitement s'arrêtera immédiatement
	avec une erreur. Cette distinction a été choisie pour empêcher les
	problèmes de typographie et un mécanisme sûr pour que les scripts
	n'agissent pas sur la mauvaise base de données.
	</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\copy <replaceable class="parameter">table</replaceable>
	[ ( <replaceable class="parameter">liste_colonne</replaceable> ) ]
        { <literal>from</literal> | <literal>to</literal> }
	<replaceable class="parameter">nomfichier</replaceable> | stdin | stdout
        [ <literal>with</literal> ] 
            [ <literal>oids</literal> ] 
            [ <literal>delimiter [as] </literal> '<replaceable
	class="parameter">caractère</replaceable>' ]
            [ <literal>NULL [as] </literal> '<replaceable
	class="parameter">chaîne</replaceable>' ]</literal>
        </term>

        <listitem>
        <para>
        Réalise un client (interface) pour copy. C'est une opération qui
	exécute une commande <acronym>SQL</acronym>, <xref linkend="SQL-COPY"
	endterm="SQL-COPY-title">, mais au lieu que le serveur lise ou écrive le
	fichier spécifié, <application>psql</application> lit ou écrit le
	fichier en faisant le routage des données entre le serveur et le système
	de fichiers local. Ceci signifie que l'accès et les droits du fichier
	sont ceux de l'utilisateur local, pas celui du serveur, et qu'aucun
	droit de superutilisateur n'est requis.
	</para>

	<para>
	La syntaxe de la commande est similaire à celle de la commande
	<command>COPY</command> <acronym>SQL</acronym>. (Voir sa description
	pour plus de détails.) Notez que, à cause de cela, des règles spéciales
	d'analyse s'appliquent à la commande <command>\copy</command>. En
	particulier, les règles de substitution de variable et d'échappements
	antislash ne s'appliquent pas.
	</para>

        <tip>
        <para>
	Cette opération n'est pas aussi efficace que la commande
	<command>COPY</command> en <acronym>SQL</acronym> parce que toutes les
	données doivent passer au travers de la connexion client/serveur. Pour
	les grosses masses de données, l'autre technique est préférable.
        </para>
        </tip>

        <note>
        <para>
        Notez la différence dans l'interprétation de
        <literal>stdin</literal> et <literal>stdout</literal> entre les copies
	client et serveur&nbsp;: dans une copie client, ils se réfèrent toujours
	aux flux d'entrée et de sortie de <application>psql</application>. Sur
	un serveur, <literal>stdin</literal> s'applique à chaque fois que
	<command>COPY</command> est nécessaire (par exemple, un script s'exécute
	avec l'option <option>-f</option>) et <literal>stdout</literal> se
	réfère au flux de sortie du requête (voir la méta-commande
	<command>\o</command> ci-dessous).
        </para>
        </note>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\copyright</literal></term>
        <listitem>
        <para>
        Affiche le copyright et les termes de distribution de
        <application>PostgreSQL</application>.
        </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\d</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>

        <listitem>
        <para>
	Pour chaque relation (table, vue, index ou séquence) correspondant au
	<replaceable class="parameter">modèle</replaceable>, affiche toutes les
	colonnes, leur types et tout attribut spécial tel que <literal>NOT
	NULL</literal> ou les valeurs par défaut. Les index, contraintes, règles
	et déclencheurs associés sont aussi affichés, ainsi que la définition de
	la vue si la relation est une vue. (<quote>Correspondre au modèle</> est
	défini ci-dessous.)
	</para>

	<para>
	Le forme de la commande <literal>\d+</literal> est identique mais tout
	commentaire associé avec les colonnes de la table est aussi affiché.
	</para>

	<note>
	<para>
	Si <command>\d</command> est utilisé sans argument
	<replaceable class="parameter">modèle</replaceable>, c'est équivalent à
	<command>\dtvs</command> qui affichera une liste de toutes les tables,
	vues et séquences. Ceci est une fonctionnalité de simplicité.
	</para>
	</note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\da</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>

        <listitem>
        <para>
        Liste toutes les fonctions d'agrégat disponibles, avec les types
	de données sur lesquels elles opèrent. Si <replaceable
        class="parameter">modèle</replaceable> est spécifié, seuls les agrégats
	dont les noms commencent par le modèle sont affichés.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dc</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>
        <listitem>
        <para>
        Liste toutes les conversions disponibles entre les codages des
	ensembles de caractères. Si <replaceable
	class="parameter">modèle</replaceable> est spécifié, seules les
	conversions dont le nom correspond au modèle sont listées.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dC</literal></term>
        <listitem>
        <para>
        Liste toutes les conversions de type disponibles.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dd</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>
        <listitem>
        <para>
        Affiche les descriptions des objets correspondant au <replaceable
        class="parameter">modèle</replaceable> ou de tous les objets si aucun
	argument n'est donné. Mais dans tous les cas, seuls les objets qui ont
	une description sont listés. (Le terme <quote>objet</quote> couvre les
	agrégats, les fonctions, les opérateurs, les types, les relations
	(tables, vues, index, séquences, objets larges), les règles et les
	déclencheurs.) Par exemple,&nbsp;:
<programlisting>
=> <userinput>\dd version</userinput>
                     Object descriptions
   Schema   |  Name   |  Object  |        Description
------------+---------+----------+---------------------------
 pg_catalog | version | function | PostgreSQL version string
(1 row)
</programlisting>
        </para>

        <para>
        Les descriptions des objets peuvent être ajoutées avec la commande
        <command>COMMENT</command> <acronym>SQL</acronym>.
	</para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dD</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>
        <listitem>
        <para>
        Liste tous les domaines disponibles. Si <replaceable
        class="parameter">modèle</replaceable> est spécifié, seuls les
	domaines correspondant sont affichés.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\df [ <replaceable class="parameter">modèle</replaceable>
	]</literal></term>

        <listitem>
        <para>
        Liste toutes les fonctions disponibles avec leurs arguments et les types
	en retour. Si <replaceable class="parameter">modèle</replaceable> est
	spécifié, seules les fonctions dont le nom correspond au modèle sont
	affichées. Si la forme <literal>\df+</literal> est utilisée, des
	informations supplémentaires sur chaque fonction, incluant le langage et
	la description, sont proposées.
        </para>

        <note>
        <para>
        Pour réduire les redondances, <literal>\df</> n'affiche pas les
	fonctions d'entrées/sorties des types de données. Ceci est implémenté en
	ignorant les fonctions qui acceptent ou renvoient <type>cstring</>.
        </para>
        </note>

        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\distvS [ <replaceable
	class="parameter">modèle</replaceable> ]</literal></term>

	<listitem>
	<para>
	Ceci n'est pas le nom réel de la commande&nbsp;: les lettres i, s,
	t, v, S correspondent respectivement à index, séquence, table, vue et
	table système. Vous pouvez spécifier une ou toutes ces lettres, dans
	n'importe quel ordre, pour obtenir une liste de tous les objets
	correspondants. La lettre S restreint la liste aux objets système&nbsp;;
	sans S, seuls les objets non système sont affichés. Si
	<literal>+</literal> est ajouté au nom de la commande, chaque objet est
	listé avec sa description associée, si celle-ci est disponible.
	</para>

	<para>
	Si <replaceable class="parameter">modèle</replaceable> est spécifié,
	seuls les objets dont les noms correspondent au modèle sont listés.
	</para>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dl</literal></term>
	<listitem>
	<para>
	Ceci est un alias pour <command>\lo_list</command>, qui affiche une
	liste des objets larges.
	</para>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dn</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>

        <listitem>
        <para>
        Liste tous les schémas disponibles. Si <replaceable
        class="parameter">modèle</replaceable> (une expression rationnelle) est
	spécifiée, seuls les schémas dont le nom correspond au modèle sont
	listés.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\do [ <replaceable class="parameter">modèle</replaceable>
	]</literal></term>
        <listitem>
        <para>
        Liste tous les opérateurs disponibles avec leur opérande et type en
	retour. Si <replaceable class="parameter">modèle</replaceable> est
	spécifié, seuls les opérateurs dont le nom correspond au modèle sont
	listés.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dp</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>
	<listitem>
	<para>
        Produit une liste de toutes les tables disponibles avec leur droits
	d'accès associés. Si <replaceable class="parameter">modèle</replaceable>
	est spécifié, seules les tables dont le nom correspond au modèle sont
	listées.
	</para>

	<para>
	Les commandes <xref linkend="SQL-GRANT"> et <xref linkend="SQL-REVOKE">
	sont utilisées pour configurer les droits d'accès. Voir <xref
	linkend="SQL-GRANT"> pour plus d'informations.
	</para>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\dT [ <replaceable class="parameter">modèle</replaceable>
	]</literal></term>
        <listitem>
        <para>
        Liste tous les types de données ou seulement ceux dont le nom correspond
	à <replaceable class="parameter">modèle</replaceable>. La forme de la
	commande <literal>\dT+</literal> affiche des informations
	supplémentaires.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\du [ <replaceable class="parameter">modèle</replaceable>
	]</literal></term>
        <listitem>
        <para>
        Liste tous les utilisateurs de la base de données ou seulement ceux dont
	le nom correspond au <replaceable
	class="parameter">modèle</replaceable>.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\edit</literal> (ou <literal>\e</literal>) [ <replaceable
	class="parameter">nomfichier</replaceable> ]</term>

        <listitem>
        <para>
        Si <replaceable class="parameter">nomfichier</replaceable> est
	spécifié, le fichier est édité&nbsp;; en quittant l'éditeur, son contenu
	est recopié dans le tampon de requête. Si aucun argument n'est fourni,
	le tampon de requête actuel est copié dans un fichier temporaire qui est
	ensuite édité de la même façon.
        </para>

        <para>
        Le nouveau tampon de requête est ensuite ré-analysé suivant les règles
	habituelles de <application>psql</application>, où le tampon complet est
	traité comme une seule ligne. (Du coup, vous ne pouvez pas faire de
	scripts de cette façon. Utilisez <command>\i</command> pour cela.) Ceci
	signifie aussi que si la requête se termine avec (ou plutôt contient) un
	point-virgule, elle est immédiatement exécutée. Dans les autres cas,
	elle attendra simplement dans le tampon de requête.
        </para>

        <tip>
        <para>
        <application>psql</application> recherche les variables d'environnement
        <envar>PSQL_EDITOR</envar>, <envar>EDITOR</envar> et
        <envar>VISUAL</envar> (dans cet ordre) pour connaître l'éditeur à
	utiliser. Si aucun n'est initialisé, <filename>/bin/vi</filename> est
	lancé.
        </para>
        </tip>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\echo</literal> <replaceable
	class="parameter">texte</replaceable> [ ... ]</term>
        <listitem>
	<para>
        Affiche les arguments sur la sortie standard séparés par un espace et
	suivi par une nouvelle ligne. Ceci peut être utile pour intégrer des
	informations sur la sortie des scripts. Par exemple&nbsp;:
<programlisting>
=> <userinput>\echo `date`</userinput>
Tue Oct 26 21:40:57 CEST 1999
</programlisting>
        Si le premier argument est <literal>-n</literal> sans guillemets,
	alors la fin de ligne n'est pas écrite.
	</para>

	<tip>
	<para>
	Si vous utilisez la commande <command>\o</command> pour rediriger la
	sortie de la requête, vous pourriez souhaiter utiliser
	<command>\qecho</command> au lieu de cette commande.
	</para>
	</tip>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\encoding</literal> [ <replaceable
	class="parameter">codage</replaceable> ]</term>

        <listitem>
        <para>
        Initialise le codage de l'ensemble de caractère du client. Sans
	argument, cette command affiche le codage actuel.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\f</literal> [ <replaceable
	class="parameter">chaîne</replaceable> ]</term>

        <listitem>
        <para>
        Initialise le champ séparateur pour la sortie de requête non alignée.
	La valeur par défaut est la barre verticale (<literal>|</literal>). Voir
	aussi <command>\pset</command> comme moyen générique de configuration
	des options d'affichage.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\g</literal> [ { <replaceable
	class="parameter">nomfichier</replaceable> |
	<literal>|</literal><replaceable
	class="parameter">commande</replaceable> } ]</term>

        <listitem>
        <para>
        Envoie le tampon de requête en entrée vers le serveur et sauvegarde la
	sortie en option dans <replaceable
	class="parameter">nomfichier</replaceable> ou envoie dans un tube la
	sortie vers un autre shell Unix pour exécuter <replaceable
	class="parameter">commande</replaceable>. Un simple
	<literal>\g</literal> est virtuellement équivalent à un point-virgule.
	Un <literal>\g</literal> avec argument est une alternative en <quote>un
	coup</quote> à la commande <command>\o</command>.
        </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\help</literal> (ou <literal>\h</literal>) [
	<replaceable class="parameter">commande</replaceable> ]</term>
        <listitem>
        <para>
        Donne la syntaxe sur la commande <acronym>SQL</acronym> spécifiée. Si
	<replaceable class="parameter">commande</replaceable> n'est pas
	spécifiée, alors <application>psql</application> listera toutes les
	commandes pour lesquelles une aide en ligne est disponible. Si
	<replaceable class="parameter">commande</replaceable> est une astérisque
	(<literal>*</literal>), alors l'aide en ligne de toutes les commandes
	<acronym>SQL</acronym> est affichée.
        </para>

	<note>
	<para>
	Pour simplifier la saisie, les commandes qui consiste en plusieurs mots
	n'ont pas besoin d'être entre guillemets. Du coup, il est correct de
	saisir <userinput>\help alter table</userinput>.
	</para>
	</note>	
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\H</literal></term>
        <listitem>
        <para>
	Active le format d'affichage <acronym>HTML</acronym> des requêtes. Si
	le format <acronym>HTML</acronym> est déjà activé, il est basculé au
	format d'affichage par défaut. Cette commande est pour la compatibilité
	mais voir <command>\pset</command> pour configurer les autres options
	d'affichage.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\i</literal> <replaceable
	class="parameter">nomfichier</replaceable></term>
        <listitem>
        <para>
        Lit l'entrée à partir du fichier <replaceable
        class="parameter">nomfichier</replaceable> et l'exécute comme si elle
	avait été saisie sur le clavier.
        </para>
	<note>
	<para>
	Si vous voulez voir les lignes sur l'écran au moment de leur lecture,
	vous devez initialiser la variable <varname>ECHO</varname> à
	<literal>all</literal>.
	</para>
	</note>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\l</literal> (ou <literal>\list</literal>)</term>
        <listitem>
        <para>
        Liste les noms, propriétaires et codages des ensembles de caractères 
	dans le serveur. Ajoutez un <literal>+</literal> au nom de la commande
	pour voir aussi toute description pour les bases de données.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\lo_export</literal> <replaceable
	class="parameter">loid</replaceable> <replaceable
	class="parameter">nomfichier</replaceable></term>

	<listitem>
	<para>
	Lit l'objet large d'<acronym>OID</acronym> <replaceable
	class="parameter">loid</replaceable> à partir de la base de données
	et l'écrit dans <replaceable
	class="parameter">nomfichier</replaceable>. Notez que ceci est
	subtilement différent de la fonction serveur
	<function>lo_export</function>, qui agit avec les droits de
	l'utilisateur avec lequel est exécuté le serveur de base de données et
	sur le système de fichiers du serveur.
	</para>
	<tip>
	<para>
	Utilisez <command>\lo_list</command> pour trouver
	l'<acronym>OID</acronym> de l'objet large.
	</para>
	</tip>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\lo_import</literal> <replaceable
	class="parameter">nomfichier</replaceable> [ <replaceable
	class="parameter">commentaire</replaceable> ]</term>

	<listitem>
	<para>
	Stocke le fichier dans un objet large
	<productname>PostgreSQL</productname>. En option, il associe le
	commentaire donné avec l'objet. Exemple&nbsp;:
<programlisting>
foo=> <userinput>\lo_import '/home/peter/pictures/photo.xcf' 'une
photo de moi'</userinput>
lo_import 152801
</programlisting>
	La réponse indique que l'objet large a reçu l'ID 152801, dont vous
	devez vous rappeler si vous souhaitez accéder de nouveau à l'objet. Pour
	cette raison, il est recommandé de toujours associer un commentaire
	lisible par un humain avec chaque objet. Ils sont ensuite visibles avec
	la commande <command>\lo_list</command>.
	</para>

	<para>
	Notez que cette commande est subtilement différente de la fonction
	serveur <function>lo_import</function> car elle agit en tant
	qu'utilisateur local sur le système de fichier local plutôt qu'en tant
	qu'utilisateur du serveur et du système de fichiers.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\lo_list</literal></term>
	<listitem>
	<para>
	Affiche une liste de tous les objets larges
	<productname>PostgreSQL</productname> actuellement stockés dans la base
	de données, avec tous les commentaires fournis par eux.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>\lo_unlink</literal> <replaceable class="parameter">loid</replaceable></term>

	<listitem>
	<para>
	Supprime l'objet large d'<acronym>OID</acronym>
	<replaceable class="parameter">loid</replaceable> à partir de la base
	de données.
	</para>

	<tip>
	<para>
	Utilisez <command>\lo_list</command> pour trouver
	l'<acronym>OID</acronym> d'un objet large.
	</para>
	</tip>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\o</literal> [ {<replaceable
	class="parameter">nomfichier</replaceable> |
	<literal>|</literal><replaceable
	class="parameter">commande</replaceable>} ]</term>

        <listitem>
        <para>
        Sauvegarde les résultats de requête future dans le fichier <replaceable
        class="parameter">nomfichier</replaceable> ou envoie via un tube les
	résultats futurs dans un shell Unix séparé pour exécuter <replaceable
	class="parameter">command</replaceable>. Si aucun argument n'est
	spécifié, l'affichage de la requête sera réinitialisé avec la sortie
	standard.
        </para>

	<para>
	Les <quote>résultats de requête</quote> incluent toutes les tables,
	réponses de commande et messages d'avertissement obtenus du serveur de
	bases de données, ainsi que la sortie de différentes commandes
	antislash qui envoient des requêtes à la base de données (comme
	<command>\d</command>), mais sans messages d'erreur.
	</para>

	<tip>
	<para>
	Pour intégrer la sortie texte entre les résultats de requête, utilisez
	<command>\qecho</command>.
	</para>
	</tip>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\p</literal></term>
        <listitem>
        <para>
        Affiche le tampon de la requête actuelle sur la sortie standard.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\pset</literal> <replaceable
	class="parameter">paramètre</replaceable> [ <replaceable
	class="parameter">valeur</replaceable> ]</term>

	<listitem>
	<para>
	Cette commande initialise les options affectant la sortie des tables 
	résultat de la requête. <replaceable
	class="parameter">paramètre</replaceable> décrit l'option à initialiser.
	La sémantique de <replaceable class="parameter">valeur</replaceable> en
	dépend.
	</para>

	<para>
	Les options ajustables d'affichage sont&nbsp;:
	<variablelist>
	  <varlistentry>
	  <term><literal>format</literal></term>
	  <listitem>
	  <para>
	  Initialise le format d'affichage parmi <literal>unaligned</literal>,
	  <literal>aligned</literal>, <literal>html</literal> ou
	  <literal>latex</literal>. Les abréviations uniques sont autorisées.
	  (ce qui signifie qu'une lettre est suffisante.)
	  </para>

	  <para>
	  <quote>Unaligned</quote> écrit toutes les colonnes d'une ligne
	  sur une seule ligne séparées par le séparateur de champ actif. Ceci a
	  pour but de créer l'affichage qui pourrait avoir pour but d'être
	  lisible par d'autres programmes (séparé par des tabulations, séparé
	  par des virgules). Le mode <quote>Aligned</quote> est l'affichage
	  texte standard, lisible par un humain, joliment formaté. C'est aussi
	  la valeur par défaut. Les modes <quote><acronym>HTML</acronym></quote>
	  et <quote>LaTeX</quote> placent les tables qui ont pour but d'être
	  inclus dans des documents utilisant le langage de marques respectif.
	  Ce ne sont pas des documents complets&nbsp;! (Ceci n'est pas si
	  dramatique en <acronym>HTML</acronym> mais en LaTeX vous devez avoir
	  une structure de document complet.)
	  </para>
	  </listitem>
          </varlistentry>

	  <varlistentry>
	  <term><literal>border</literal></term>
	  <listitem>
	  <para>
	  Le second argument doit être un nombre. En général, plus haut est ce
	  nombre, plus les tables auront de bordure et de ligne mais ceci
	  dépend du format. Dans le mode <acronym>HTML</acronym>, ceci sera
	  traduit directement avec l'attribut <literal>border=...</literal>.
	  Avec les autres, seules les valeurs 0 (sans bordure), 1 (lignes
	  internes de division) et 2 (forme de table) ont un sens.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>expanded</literal> (ou <literal>x</literal>)</term>
	  <listitem>
	  <para>
	  Bascule entre le format standard et étendu. Lorsque le format étendu
	  est activé, tout l'affichage a deux colonnes avec le nom de colonne
	  sur la gauche et la donnée sur la droite. Ce mode est utile si les
	  données ne tiennent pas sur l'écran dans le mode
	  <quote>horizontal</quote>.
	  </para>

	  <para>
	  Le mode étendu est supporté par les quatre formats d'affichage.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>NULL</literal></term>
	  <listitem>
	  <para>
	  Le second argument est une chaîne qui sera affichée quand une colonne
	  est NULL. La valeur par défaut est de n'afficher rien, ce qui peut
	  être facilement pris pour, disons, une chaîne vide. Du coup, vous
	  pouvez choisir d'écrire <literal>\pset NULL '(NULL)'</literal>.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>fieldsep</literal></term>
	  <listitem>
	  <para>
	  Spécifie le séparateur de champ à utiliser dans le mode d'affichage
	  non aligné. De cette façon, vous pouvez créer, par exemple, une
	  sortie séparée par des tabulations ou des virgules, que d'autres
	  programmes pourraient préférer. Pour configurer une tabulation comme
	  champ séparateur, saisissez <literal>\pset fieldsep
	  '\t'</literal>. Le séparateur de champ par défaut est
	  <literal>'|'</literal> (une barre verticale).
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>footer</literal></term>
	  <listitem>
	  <para>
	  Bascule l'affichage du bas de page par défaut <literal>(x
	  lignes)</literal>.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>recordsep</literal></term>
	  <listitem>
	  <para>
          Spécifie le séparateur d'enregistrement (ligne) à utiliser dans le
	  mode d'affichage non aligné. La valeur par défaut est un caractère de
	  retour chariot.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>tuples_only</literal> (ou <literal>t</literal>)</term>
	  <listitem>
	  <para>
	  Bascule entre les lignes seules et l'affichage complet. Ce dernier
	  peut afficher des informations supplémentaires telles que les en-têtes
	  de colonnes, les titres et différents bas de page. Dans le mode lignes
	  seules, seules les données réelles de la table sont affichées.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>title</literal> [ <replaceable
	  class="parameter">texte</replaceable> ]</term>
	  <listitem>
	  <para>
	  Initialise le titre de la table pour toutes les tables affichées en
	  suite. Ceci peut être utilisé pour donner vos balises de description
	  d'affichage. Si aucun argument n'est donné, le titre n'est pas
	  initialisé.
	  </para>
	  </listitem>
	  </varlistentry>

	  <varlistentry>
	  <term><literal>tableattr</literal> (ou <literal>T</literal>) [
	  <replaceable class="parameter">texte</replaceable> ]</term>
	  <listitem>
	  <para>
	  Vous permet de spécifier tout attribut à placer à l'intérieur de la
	  balise <sgmltag>table</sgmltag> en <acronym>HTML</acronym>. Ceci
	  pourrait être par exemple <literal>cellpadding</literal> ou
	  <literal>bgcolor</literal>. Notez que vous ne voulez probablement pas
	  spécifier <literal>border</literal> ici car c'est déjà prise en compte
	  par <literal>\pset border</literal>.
	  </para>
	  </listitem>
	  </varlistentry>


	  <varlistentry>
	  <term><literal>pager</literal></term>
	  <listitem>
	  <para>
	  Contrôle l'utilisation d'un paginateur pour les requêtes et les
	  affichages de l'aide de <application>psql</>. Si la variable
	  d'environnement <envar>PAGER</envar> est configurée, la sortie est
	  envoyée via un tube dans ce programme spécifié. Sinon, une valeur par
	  défaut dépendant de la plateforme (comme <filename>more</filename>)
	  est utilisée.
	  </para>

	  <para>
	  Lorsque le paginateur est spécifié, il n'est pas utilisé. Quand le
	  paginateur est activé, il est utilisé seulement si approprié,
	  c'est-à-dire que l'affichage se fait sur un terminal et qu'il ne tient
	  pas sur l'écran. (<application>psql</> ne fait pas un boulot parfait
	  pour savoir quand utiliser le paginateur.) <literal>\pset pager</>
	  active et désactive le paginateur. Ce dernier peut aussi être
	  configurer à <literal>always</>, ce qui fait qu'il est utilisé en
	  permanence.
	  </para>
	  </listitem>
	  </varlistentry>
	</variablelist>
        </para>

        <para>
	Des illustrations sur la façon d'utiliser ces différents formats sont
	disponibles dans la section <xref linkend="APP-PSQL-examples"
	endterm="APP-PSQL-examples-title">.
	</para>

	<tip>
	<para>
	Il existe plusieurs raccourcis de commandes pour
	<command>\pset</command>. Voir
	<command>\a</command>, <command>\C</command>, <command>\H</command>,
	<command>\t</command>, <command>\T</command> et <command>\x</command>.
	</para>
	</tip>

	<note>
	<para>
	C'est une erreur d'appeler <command>\pset</command> sans
	arguments. Dans le futur, cet appel pourrait afficher le statut actuel
	de toutes les options d'affichage.
	</para>
	</note>

	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\q</literal></term>
        <listitem>
        <para>
        Quitte le programme <application>psql</application>.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\qecho</literal> <replaceable
	class="parameter">texte</replaceable> [ ... ] </term>
        <listitem>
        <para>
	Cette commande est identique à <command>\echo</command> sauf que tous
	les affichages seront écrits dans le canal d'affichage des requêtes,
	configuré par <command>\o</command>.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\r</literal></term>
        <listitem>
        <para>
        Réinitialise (efface) le tampon de requêtes.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\s</literal> [ <replaceable
	class="parameter">nomfichier</replaceable> ]</term>
        <listitem>
        <para>
        Affiche ou sauvegarde l'historique des lignes de commande dans
	<replaceable class="parameter">nomfichier</replaceable>. Si <replaceable
	class="parameter">nomfichier</replaceable> est omit, l'historique est
	écrit sur la sortie standard. Cette option est seulement disponible si
	<application>psql</application> est configuré pour utiliser la
	bibliothèque d'historique <acronym>GNU</acronym>.
        </para>

	<note>
	<para>
	Dans la version actuelle, il n'est plus nécessaire de sauvegarder
	l'historique des commandes car c'est fait automatiquement à la fin du
	programme. L'historique est aussi chargé automatiquement chaque fois que
	<application>psql</application> est lancé.
	</para>
	</note>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\set</literal> [ <replaceable
	class="parameter">nom</replaceable> [ <replaceable
	class="parameter">valeur</replaceable> [ ... ]]]</term>

	<listitem>
	<para>
	Initialise la variable interne <replaceable
	class="parameter">nom</replaceable> à <replaceable
	class="parameter">valeur</replaceable> ou, si plus d'une valeur est
	donnée, à la concaténation de toutes les valeurs. Si aucun second
	argument n'est donné, la variable est simplement initialisée sans
	valeur. Pour désinitialiser une variable, utilisez la commande
	<command>\unset</command>.
	</para>

	<para>
	Les noms de variables valides peuvent contenir des caractères, chiffres
	et tirets bas. Voir la section <xref linkend="APP-PSQL-variables"
	endterm="APP-PSQL-variables-title"> ci-dessous pour les détails.
	</para>

	<para>
	Bien que vous soyez bienvenue pour configurer toute variable que vous
	souhaitez, <application>psql</application> traite plusieurs variables de
	façon spéciale. Elles sont documentées dans la section sur les
	variables.
	</para>

	<note>
	<para>
	Cette commande est totalement séparée de la commande 
	<acronym>SQL</acronym> <xref linkend="SQL-SET" endterm="SQL-SET-title">.
	</para>
	</note>
	</listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\t</literal></term>
        <listitem>
        <para>
        Bascule l'affichage des en-têtes de nom de colonne en sortie et celle du
	bas de page indiquant le nombre de lignes. Cette commande est
	équivalente à <literal>\pset tuples_only</literal> et est fournie pour y
	faciliter l'accès.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\T</literal> <replaceable
	class="parameter">options_table</replaceable></term>
        <listitem>
        <para>
        Vous permet de spécifier les attributs à placer à l'intérieur de la
	balise <sgmltag>table</sgmltag> dans le mode d'affichage en tableau
	<acronym>HTML</acronym>. Cette commande est équivalente à <literal>\pset
        tableattr <replaceable
	class="parameter">options_table</replaceable></literal>.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
       <term><literal>\timing</literal></term>
        <listitem>
        <para>
         Bascule un affichage du temps pris par chaque instruction SQL en
	 millisecondes.
        </para>
       </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\w</literal> {<replaceable
	class="parameter">nomfichier</replaceable> | <replaceable
	class="parameter">|commande</replaceable>}</term>
        <listitem>
        <para>
	Place le tampon de requête en cours dans le fichier <replaceable
        class="parameter">nomfichier</replaceable> ou l'envoie via un tube à la
	commande Unix <replaceable class="parameter">commande</replaceable>.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\x</literal></term>
        <listitem>
        <para>
        Bascule le mode étendu de formatage en table. C'est équivalent à
	<literal>\pset expanded</literal>.
       </para>
       </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\z</literal> [ <replaceable
	class="parameter">modèle</replaceable> ]</term>
        <listitem>
        <para>
        Produit une liste de toutes les tables disponibles avec leur droit
	d'accès associé. Si un <replaceable
	class="parameter">modèle</replaceable> est spécifié, seules les tables
	dont le nom correspond au modèle sont listées.
	</para>

	<para>
	Les commandes <xref linkend="SQL-GRANT"> et
	<xref linkend="SQL-REVOKE"> sont utilisées pour configurer les
	droits d'accès . Voir <xref linkend="SQL-GRANT"> pour plus
	d'informations.
	</para>

	<para>
	Ceci est un alias pour <command>\dp</command> (<quote>affichage des
	droits</quote>).
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\!</literal> [ <replaceable
	class="parameter">commande</replaceable> ]</term>
        <listitem>
        <para>
        Échappe vers un shell Unix séparé ou exécute la commande Unix
        <replaceable class="parameter">commande</replaceable>. Les
        arguments ne sont pas plus interprétées, le shell les verra ainsi.
        </para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>\?</literal></term>
        <listitem>
        <para>
        Affiche l'aide sur les commandes antislash.
        </para>
        </listitem>
      </varlistentry>

    </variablelist>
  </para>

  <para>
   Les différentes commandes <literal>\d</> acceptent un paramètre <replaceable
   class="parameter">modèle</replaceable> pour spécifier le(s) nom(s) d'objet à
   afficher. <literal>*</> signifie <quote>toute séquence de caractères</> et
   <literal>?</> signifie <quote>tout caractère simple</>. (Cette notation est
   comparable aux modèles du shell pour les noms de fichier Unix.) Les
   utilisateurs avancés peuvent aussi utiliser des notations d'expressions
   rationnelles telles que les classes de caractères, par exemple
   <literal>[0-9]</> pour correspondre à <quote>tout chiffre</>. Pour faire que
   tous ces caractères de correspondance de modèles soient interprétés de façon
   littérale, englobez-les avec des guillemets doubles.
  </para>

  <para>
   Un modèle contenant un point (sans guillemet) est interprété comme un modèle
   de nom de schéma suivi par un modèle de nom d'objet. Par exemple,
   <literal>\dt foo*.bar*</> affiche toutes les tables dont le nom du schéma
   commence avec <literal>foo</> et dont le nom de table commence avec
   <literal>bar</>. Si aucun point n'apparaît, alors le modèle correspond
   seulement aux objets visibles dans le chemin actuel de recherche de schéma.
  </para>

  <para>
   À chaque fois que le paramètre <replaceable
   class="parameter">modèle</replaceable> est complètement omis, les commandes
   <literal>\d</> affichent tous les objets visibles dans le chemin de
   recherche actuel du schéma. Pour voir tous les objets dans la base de
   données, utilisez le modèle <literal>*.*</>.
  </para>
 </refsect2>

 <refsect2>
  <title>Fonctionnalités avancées</title>

   <refsect3 id="APP-PSQL-variables">
    <title id="APP-PSQL-variables-title">Variables</title>

    <para>
    <application>psql</application> fournit des fonctionnalités de substitution
    de variable similaire aux shells de commandes Unix. Les variables sont
    simplement des paires nom/valeur où la valeur peut être toute chaîne, quel
    que soit sa longueur. Pour initialiser des variables, utilisez la
    méta-commande <application>psql</application> <command>\set</command>&nbsp;:
<programlisting>
testdb=> <userinput>\set foo bar</userinput>
</programlisting>
    initialise la variable <literal>foo</literal> avec la valeur
    <literal>bar</literal>. Pour récupérer le contenu de la variable, précédez
    le nom avec un caractère deux-points et utilisez-la comme argument de toute
    commande slash&nbsp;:
<programlisting>
testdb=> <userinput>\echo :foo</userinput>
bar
</programlisting>
    </para>

    <note>
    <para>
    Les arguments de <command>\set</command> sont sujet aux même règles de
    substitution que les autres commandes. Du coup, vous pouvez construire des
    références intéressantes comme <literal>\set :foo 'quelquechose'</literal>
    et obtenir des <quote>liens doux</quote> ou des <quote>variables de
    variables</quote> comme, respectivement, <productname>Perl</productname> ou
    <productname><acronym>PHP</acronym></productname>. Malheureusement (ou
    heureusement&nbsp;?), il n'existe pas de moyen de faire quelque chose
    d'utile avec ces constructions. D'un autre côté, <literal>\set bar
    :foo</literal> est un moyen parfaitement valide de copier une variable.
    </para>
    </note>

    <para>
    Si vous appelez <command>\set</command> sans second argument, la variable
    est initialisée avec une chaîne vide. Pour désinitialiser (ou supprimer) une
    variable, utilisez la commande <command>\unset</command>.
    </para>

    <para>
    Les noms de variables internes de <application>psql</application> peuvent
    consister de lettres, nombres et tirets bas dans n'importe quel ordre et
    autant de fois que vous le voulez. Un certain nombre de ces variables sont
    traitées spécialement par <application>psql</application>. Elles indiquent
    certaines options qui peuvent changer au moment de l'exécution en modifiant
    la valeur de la variable ou représentent un certain état de l'application.
    Bien que vous pouvez utiliser ces variables dans n'importe quel but, ceci
    n'est pas recommandé car le comportement du programme pourrait grossier de
    façon étrange très rapidement. Par convention, toutes les variables traitées
    spécialement sont uniquement composées de lettres majuscules (et peut-être
    aussi de chiffres et de tirets bas). Pour s'assurer de la compatibilité
    maximum dans le futur, évitez l'utilisation de tels noms de variables pour
    vos propres besoins. Une liste de toutes les variables traitées
    spécialement suit.
   </para>

    <variablelist>
      <varlistentry>
        <term><varname>AUTOCOMMIT</varname></term>
	<listitem>
	<para>
	Si actif (<literal>on</>, valeur par défaut), chaque commande SQL est
	automatiquement validée si elle se termine avec succès. Pour suspendre
	la validation dans ce mode, vous devez saisir une commande SQL
	<command>BEGIN</> ou <command>START TRANSACTION</>. Lorsqu'elle est
	désactivée (<literal>off</>) ou non initialisée, les commandes SQL ne
	sont plus validées tant que vous ne lancez pas explicitement
	<command>COMMIT</> ou <command>END</>. Le mode sans autocommit
	fonctionne en lançant implicitement un <command>BEGIN</> pour vous,
	juste avant toute commande qui n'est pas déjà dans un bloc de
	transaction et qui n'est pas elle-même un <command>BEGIN</> ou une autre
	commande de contrôle de transaction.
	</para>

	<note>
	<para>
	 Dans le mode sans autocommit, vous devez annuler explicitement toute
	transaction échouée en saisissant <command>ABORT</> ou
	<command>ROLLBACK</>. Gardez aussi en tête que si vous sortez d'une
	session sans validation, votre travail sera perdu.
	</para>
	</note>

	<note>
	<para>
	 Le mode auto-commit est le comportement traditionnel de
	 <productname>PostgreSQL</> alors que le mode sans autocommit est plus
	 proche des spécifications SQL. Si vous préférez sans autocommit, vous
	 pourriez souhaiter le configurer dans votre fichier
	<filename>.psqlrc</filename>.
	</para>
	</note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>DBNAME</varname></term>
	<listitem>
	<para>
        Le nom de la base de données où vous êtes actuellement connecté. Ceci
	est configuré à chaque fois que vous vous connectez à une base de
	données (ainsi qu'au lancement du programme) mais peut être
	désinitialiser.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>ECHO</varname></term>
	<listitem>
	<para>
	S'il est initialisé à <literal>all</literal>, toutes les lignes saisies
	ou provenant d'un script sont écrites sur la sortie standard avant
	d'être analysées ou exécutées. Pour sélectionner ce comportement sur le
	lancement de programme, utilisez l'option <option>-a</option>. Si
	configuré à <literal>queries</literal>, <application>psql</application>
	affiche simplement toutes les requêtes au moment de leur envoi au
	serveur. L'option pour ceci est <option>-e</option>.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>ECHO_HIDDEN</varname></term>
	<listitem>
	<para>
	Quand cette variable est initialisée et qu'une commande antislash est
	envoyée à la base de données, la requête est d'abord affichée. De cette
	façon, vous pouvez étudier les internes de
	<productname>PostgreSQL</productname> et fournir des fonctionnalités
	similaires dans vos propres programmes. (Pour sélectionner ce
	comportement au lancement du programme, utilisez l'option
	<option>-E</option>.) Si vous configurez la variable avec la valeur
	<literal>noexec</literal>, les requêtes sont juste affichées mais ne
	sont plus réellement envoyées au serveur et exécutées.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>ENCODING</varname></term>
	<listitem>
	<para>
        Le codage en cours de l'ensemble de caractères du client.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>HISTCONTROL</varname></term>
	<listitem>
	<para>
         Si cette variable est configurée à <literal>ignorespace</literal>, les
	lignes commençant avec un espace n'entrent pas dans la liste de
	l'historique. Si elle est initialisée avec la valeur
	<literal>ignoredups</literal>, les lignes correspondant aux précédentes
	lignes de l'historique n'entrent pas non plus. Une valeur de
	<literal>ignoreboth</literal> combine les deux options. Si elle n'est
	pas initialisée ou si elle est configurée avec une autre valeur que
	celles-ci, toutes les lignes lues dans le mode interactif sont
	sauvegardées dans la liste de l'historique.
	</para>
        <note>
        <para>
        Cette fonctionnalité a été honteusement plagiée sur
        <application>Bash</application>.
        </para>
        </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>HISTSIZE</varname></term>
	<listitem>
	<para>
        Le nombre de commandes à stocker dans l'historique des commandes. La
	valeur par défaut est 500.
	</para>
        <note>
        <para>
        Cette fonctionnalité a été honteusement plagiée sur
        <application>Bash</application>.
        </para>
        </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>HOST</varname></term>
	<listitem>
	<para>
	L'hôte du serveur de la base de données où vous êtes actuellement
	connecté. Ceci est configuré à chaque fois que vous vous connectez à une
	base de données (ainsi qu'au lancement du programme) mais peut être
	désinitialisé.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>IGNOREEOF</varname></term>
	<listitem>
	<para>
         Si non initialisé, envoyer un caractère <acronym>EOF</> (habituellement
         <keycombo action="simul"><keycap>Ctrl</><keycap>D</></>) dans une
	session interactive de <application>psql</application> terminera
	l'application. Si elle est configurée avec une valeur numérique, ce
	nombre de caractères <acronym>EOF</> sera ignoré avant la fin de
	l'application. Si la variable est configurée mais n'a pas de valeur
	numérique, la valeur par défaut est de 10.
	</para>
        <note>
        <para>
        Cette fonctionnalité a été honteusement plagiée sur
        <application>Bash</application>.
        </para>
        </note>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>LASTOID</varname></term>
	<listitem>
	<para>
	La valeur du dernier OID affecté, renvoyé à partir d'une commande
        <command>INSERT</command> ou <command>lo_insert</command>. La
	validité de cette variable est seulement garantie jusqu'après
	l'affichage du résultat de la prochaine commande <acronym>SQL</acronym>.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>ON_ERROR_STOP</varname></term>
	<listitem>
	<para>
	Par défaut, si les scripts non interactifs rencontrent une erreur, comme
	une commande <acronym>SQL</acronym> mal formée ou une méta-commande
	interne. Ceci a été le comportement traditionnel de
	<application>psql</application> mais il est quelque fois indésirable.
	Si cette variable est configurée, le traitement du script s'arrête
	immédiatement. Si le script a été appelé à partir d'un autre script, il
	se terminera de la même façon. Si le script le plus externe n'a pas été
	appelé à partir d'une session interactive de
	<application>psql</application> mais plutôt en utilisant l'option
	<option>-f</option>, <application>psql</application> renverra le code
	erreur 3 pour distinguer ce cas des conditions d'erreurs fatales (code
	d'erreur 1).
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>PORT</varname></term>
	<listitem>
	<para>
        Le port du serveur de la base de données sur laquelle vous êtes
	actuellement connecté. Ceci est configuré à chaque fois que vous vous
	connectez à une base de données (ainsi qu'au lancement du programme)
	mais peut être désinitialisée.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>PROMPT1</varname></term>
        <term><varname>PROMPT2</varname></term>
        <term><varname>PROMPT3</varname></term>
	<listitem>
	<para>
	Ils spécifient à quoi devrait ressembler l'invite
	<application>psql</application>. Voir <xref
	linkend="APP-PSQL-prompting" endterm="APP-PSQL-prompting-title">
	ci-dessous.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>QUIET</varname></term>
	<listitem>
	<para>
	Cette variable est équivalente à l'option <option>-q</option> en ligne
	de commande. Il n'est probablement pas aussi utile dans le mode
	interactif.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>SINGLELINE</varname></term>
	<listitem>
	<para>
	Cette variable est équivalente à l'option <option>-S</option> en ligne
	de commande.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>SINGLESTEP</varname></term>
	<listitem>
	<para>
	Cette variable est équivalente à l'option <option>-s</option> en ligne
	de commande.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>USER</varname></term>
	<listitem>
	<para>
        L'utilisateur de la base de données où vous êtes actuellement
	connecté. Ceci est configuré à chaque fois que vous vous connectez à une
	base de données (ainsi qu'au lancement du programme) mais peut être
	désinitialisé.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>VERBOSITY</varname></term>
	<listitem>
	<para>
	Cette variable peut être configurée avec les valeurs
	<literal>default</>, <literal>verbose</> ou <literal>terse</> pour
	contrôler la verbosité des rapports d'erreurs.
	</para>
	</listitem>
      </varlistentry>

    </variablelist>

   </refsect3>

   <refsect3>
    <title>Interpolation <acronym>SQL</acronym></title>

    <para>
    Un fonctionnalité utile supplémentaire des variables
    <application>psql</application> est que vous pouvez les substituer
    (<quote>interpoler</quote>) dans les instructions <acronym>SQL</acronym>
    standards. La syntaxe pour ceci est encore l'ajout d'un caractère
    deux-points (<literal>:</literal>) avant le nom de la variable.
<programlisting>
testdb=> <userinput>\set foo 'ma_table'</userinput>
testdb=> <userinput>SELECT * FROM :foo;</userinput>
</programlisting>
    enverra alors la requête pour la table <literal>ma_table</literal>. La
    valeur de la variable est copiée littéralement, donc il peut même contenir
    des guillemets non terminés ou des commandes antislash. Vous devez vous
    assurer que cela a un sens. L'interpolation de variable ne sera pas réalisée
    dans des entités SQL <acronym>SQL</acronym> entre guillemets.
    </para>

    <para>
    Une application populaire de cette fonctionnalité est de référer au
    dernier <acronym>OID</acronym> inséré dans les instructions suivantes 
    pour construire un scénario de clé étrangère. Une autre utilisation
    possible de ce mécanisme est de copier le contenu d'un fichier dans une
    colonne d'une table. Tout d'abord, chargez le fichier dans une variable puis
    procédez ainsi.
<programlisting>
testdb=> <userinput>\set contenu '\'' `cat mon_fichier.txt` '\''</userinput>
testdb=> <userinput>INSERT INTO ma_table VALUES (:contenu);</userinput>
</programlisting>
    Un problème possible avec cette approche est que
<filename>mon_fichier.txt</filename> pourrait contenir des guillemets simples.
Ils ont besoin d'être échappés pour ne pas provoquer d'erreurs de syntaxe quand
la deuxième ligne est traitée. Ceci peut se faire avec le programme
<command>sed</command>&nbsp;:
<programlisting>
testdb=> <userinput>\set contenu '\'' `sed -e "s/'/\\\\\\'/g" &lt;
mon_fichier.txt` '\''</userinput>
</programlisting>
    Observez le nombre correct d'antislashs (6)&nbsp;! Cela fonctionne de cette
    façon&nbsp;: après l'analyse de la ligne par
    <application>psql</application>, il passe <literal>sed -e "s/'/\\\'/g" &lt;
    mon_fichier.txt</literal> au shell. Le shell fera son travail à l'intérieur
    des doubles guillemets et exécute <command>sed</command> avec les arguments
    <literal>-e</literal> et <literal>s/'/\\'/g</literal>. Quand
    <command>sed</command> analyse ceci, il remplacera les deux antislashs avec
    un seul et fera ensuite la substitution. Peut-être qu'à un moment vous
    pensiez qu'il était génial que toutes les commandes Unix utilisent le même
    caractère d'échappement. Et ceci ignore le fait que vous pourriez avoir à
    échapper aussi tous les antislashs parce que les constantes de texte
    <acronym>SQL</acronym> sont aussi sujet à certaines interprétations. Dans ce
    cas, vous seriez mieux de préparer le fichier de façon externe.
    </para>

    <para>
    Comme les caractères deux-points pourraient apparaître légalement dans les
    commandes SQL, la règle suivante s'applique&nbsp;: la séquence de caractère
    <quote>:nom</quote> n'est pas changée sauf si <quote>nom</> est le nom
    d'une variable réellement initialisée. Dans tous les cas, vous pouvez
    échapper un deux-points avec un antislash pour le protéger d'une
    substitution. (La syntaxe deux-points pour les variables fait partie du
    standard <acronym>SQL</acronym> pour les langages de requêtes embarqués,
    tels que <application>ECPG</application>. La syntaxe deux-points pour les
    morceaux de tableau et les conversions de types sont des extensions
    <productname>PostgreSQL</productname>, d'où le conflit.)
    </para>

   </refsect3>

   <refsect3 id="APP-PSQL-prompting">
    <title id="APP-PSQL-prompting-title">Invite</title>

    <para>
    Les invites <application>psql</application> peuvent être personnalisées
suivant vos préférences. Les trois variables <varname>PROMPT1</varname>,
<varname>PROMPT2</varname> et <varname>PROMPT3</varname> contiennent des
chaînes et des séquences d'échappement spéciales décrivant l'apparence de
l'invite. L'invite 1 est l'invite normale qui est lancée quand
<application>psql</application> réclame une nouvelle commande. L'invite 2 est
lancée lorsqu'une saisie supplémentaire est attendue lors de la saisie de la
commande parce que la commande n'a pas été terminée avec un point-virgule ou
parce qu'un guillemet n'a pas été fermé. L'invite 3 est lancée lorsque vous
exécutez une commande <acronym>SQL</acronym> <command>COPY</command> et que
vous devez saisir les valeurs des lignes sur le terminal.
    </para>

    <para>
    La valeur de la variable prompt sélectionnée est affichée littéralement
    sauf si un signe pourcentage (<literal>%</literal>) est rencontré. Suivant
    le prochain caractère, certains autres textes sont substitués. Les
    substitutions définies sont&nbsp;:

    <variablelist>
      <varlistentry>
        <term><literal>%M</literal></term>
	<listitem>
         <para>
          Le nom complet de l'hôte (avec le nom du domaine) du serveur de la
	  base de données ou <literal>[local]</literal> si la connexion est
	  établie via un socket de domaine Unix ou
	 <literal>[local:<replaceable>/répertoire/nom</replaceable>]</literal>,
          si le socket de domaine Unix n'est pas dans l'emplacement défini au
	  moment de la compilation.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%m</literal></term>
	<listitem>
         <para>
          Le nom de l'hôte du serveur de la base de données, tronquée au
	  premier point ou <literal>[local]</literal> si la connexion se fait
	  via un socket de domaine Unix.
         </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%&gt;</literal></term>
	<listitem><para>Le numéro de port sur lequel le serveur de la base de 
	données écoute.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%n</literal></term>
	<listitem>
         <para>
          Le nom d'utilisateur de la session. (L'expansion de cette valeur
	  pourrait changer pendant une session après une commande <command>SET
	  SESSION AUTHORIZATION</command>.)
         </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%/</literal></term>
	<listitem><para>Le nom de la base de données courante.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%~</literal></term>
	<listitem><para>Comme <literal>%/</literal> mais l'affichage est un
	<literal>~</literal> (tilde) si la base de données est votre base de
	données par défaut.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%#</literal></term>
	<listitem>
         <para>
          Si l'utilisateur de la session est un superutilisateur, alors un
          <literal>#</literal> sinon un <literal>&gt;</literal>.
          (L'expansion de cette valeur pourrait changer durant une session à la
	  base de données suite à la commande <command>SET SESSION
	  AUTHORIZATION</command>.)
         </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%R</literal></term>
	<listitem>
	<para>
	À l'invite 1 normalement <literal>=</literal> mais
	<literal>^</literal> si en mode simple ligne et <literal>!</literal> si
	la session est déconnectée de la base de données (ce qui peut arriver si
	<command>\connect</command> échoue). À l'invite 2, la séquence est
	remplacée par <literal>-</literal>, <literal>*</literal>, un simple
	guillemet ou un double, suivant si <application>psql</application>
	attend une saisie supplémentaire parce que la commande n'est pas
	terminée, parce que vous êtes à l'intérieur d'un commentaire <literal>/*
	... */</literal>, ou parce que vous n'avez pas terminé un guillemet. À
	l'invite 3, la séquence ne produit rien.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%x</literal></term>
	<listitem>
	<para>
	État de la Transaction&nbsp;: une chaîne vide lorsque vous n'êtes pas
	dans un bloc de transaction ou <literal>*</> si vous vous y trouvez, ou
	<literal>!</> si vous êtes dans une transaction échouée, ou enfin
	<literal>?</> lorsque l'état de la transaction est indéterminé (par
	exemple à cause d'une rupture de la connexion).
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%</literal><replaceable
	class="parameter">chiffres</replaceable></term>
	<listitem>
	<para>
	Le caractère avec ce code numérique est substitué. Si <replaceable
	class="parameter">chiffres</replaceable> commence avec
	<literal>0x</literal>, le reste des caractères est interprété en
	hexadécimal&nbsp;; sinon si le premier caractère est
	<literal>0</literal>, les chiffres sont interprétés comme de
	l'octal&nbsp; enfin, en dernier cas, les chiffres sont lus en tant que
	nombre décimal.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%:</literal><replaceable
	class="parameter">nom</replaceable><literal>:</literal></term>
	<listitem>
	<para>
	La valeur de la variable <replaceable
	class="parameter">nom</replaceable> <application>psql</application>.
	Voir la section <xref linkend="APP-PSQL-variables"
	endterm="APP-PSQL-variables-title"> pour les détails.
	</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>%`</literal><replaceable
	class="parameter">commande</replaceable><literal>`</literal></term>
	<listitem>
	<para>
	la sortie de la <replaceable
	class="parameter">commande</replaceable>, similaire à la substitution
	par <quote>guillemet inverse</quote>.
	</para>
	</listitem>
      </varlistentry>

    </variablelist>

    Pour insérer un pourcentage dans votre invite, écrivez
    <literal>%%</literal>. Les invites par défaut sont
    <literal>'%/%R%# '</literal> pour les invites 1 et 2 et
    <literal>'&gt;&gt; '</literal> pour l'invite 3.
    </para>

    <note>
    <para>
    Cette fonctionnalité a été honteusement plagiée sur
    <application>tcsh</application>.
    </para>
    </note>

   </refsect3>

   <refsect3>
    <title>Édition de la ligne de commande</title>

    <para>
    <application>psql</application> supporte la bibliothèque
    <application>Readline</application> pour une édition et une recherche
    simplifiée et conviviale de la ligne. L'historique de la commande est stocké
    dans un fichier nommé <filename>.psql_history</filename>, placé dans votre
    répertoire personnel, et est rechargé au lancement de
    <application>psql</application>. La complétion par tabulation est aussi
    supportée bien que la logique de complétion n'a pas la prétention d'être un
    analyseur <acronym>SQL</acronym>. Si pour quelques raisons que ce soit, vous
    n'aimez pas la complétion par tabulation, vous pouvez la désactiver en
    plaçant ceci dans un fichier nommé <filename>.inputrc</filename> de votre
    répertoire personnel&nbsp;:
<programlisting>
$if psql
set disable-completion on
$endif
</programlisting>
    (Ceci n'est pas une fonctionnalité <application>psql</application> mais
    <application>Readline</application>. Lisez sa documentation pour plus de
    détails.)
    </para>
   </refsect3>
  </refsect2>
 </refsect1>


 <refsect1>
  <title>Environnement</title>

  <variablelist>
   <varlistentry>
    <term><envar>HOME</envar></term>

    <listitem>
     <para>
      Répertoire pour les fichiers d'initialisation
      (<filename>.psqlrc</filename>) et fichier de l'historique des commandes
      (<filename>.psql_history</filename>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><envar>PAGER</envar></term>

    <listitem>
     <para>
      Si les résultats d'une requête ne tiennent pas sur l'écran, ils sont
      envoyés via un tube sur cette commande. Les valeurs typiques sont
      <literal>more</literal> our <literal>less</literal>. La valeur par défaut
      dépend de la plateforme. L'utilisation du paginateur peut être désactivée
      en utilisant la commande <command>\pset</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><envar>PGDATABASE</envar></term>

    <listitem>
     <para>
      Base de données où se connecter par défaut
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><envar>PGHOST</envar></term>
    <term><envar>PGPORT</envar></term>
    <term><envar>PGUSER</envar></term>

    <listitem>
     <para>
      Paramètres de connexion par défaut
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><envar>PSQL_EDITOR</envar></term>
    <term><envar>EDITOR</envar></term>
    <term><envar>VISUAL</envar></term>

    <listitem>
     <para>
      Éditeur utilisé par la commande <command>\e</command>. Les variables sont
      examinées dans l'ordre donné&nbsp;; la première initialisée est celle qui
      sera utilisée.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><envar>SHELL</envar></term>

    <listitem>
     <para>
      Commande exécutée par la commande <command>\!</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><envar>TMPDIR</envar></term>

    <listitem>
     <para>
      Répertoire pour stocker des fichiers temporaires. La valeur par défaut est
      <filename>/tmp</filename>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>


 <refsect1>
  <title>Fichiers</title>

  <itemizedlist>
   <listitem>
    <para>
     Avant de se lancer, <application>psql</application> tente de lire et
     exécuter les commandes provenant du fichier
     <filename>$HOME/.psqlrc</filename>. Il pourrait être utilisé pour
     configurer le client ou le serveur à votre goût (en utilisant les commandes
     <command>\set</command> et <command>SET</command>).
    </para>
   </listitem>

   <listitem>
    <para>
     L'historique de la ligne de commande est stocké dans le fichier
     <filename>$HOME/.psql_history</filename>.
    </para>
   </listitem>
  </itemizedlist>
 </refsect1>


 <refsect1>
  <title>Notes</title>

    <itemizedlist>
      <listitem>
      <para>
      Dans une vie précédente, <application>psql</application> permettait au
     premier argument d'une commande antislash à une seule lettre de commencer
     directement après la commande sans intervenir sur les espaces blancs. Pour
     la compatibilité, ceci est toujours supporté jusqu'à un certain point mais
     nous n'allons pas expliquer les détails ici car son utilisation n'est pas
     encouragée. Si vous obtenez des messages étranges, gardez ceci en tête. Par
     exemple
<programlisting>
testdb=> <userinput>\foo</userinput>
Field separator is "oo".
</programlisting>
      ce qui n'est peut-être pas ce que nous souhaitons.
      </para>
      </listitem>

      <listitem>
      <para>
      <application>psql</application> travaille seulement correctement avec
      des serveurs de la même version. Cela ne signifie pas que les autres
      combinaisons échoueront immédiatement mais des problèmes subtiles et moins
      subtiles pourraient survenir. Les commandes antislash ont particulièrement
      plus de chance d'échouer si le serveur est d'une version différente.
      </para>
      </listitem>

    </itemizedlist>
 </refsect1>


 <refsect1 id="APP-PSQL-examples">
  <title id="APP-PSQL-examples-title">Exemples</title>

  <para>
  Le premier exemple affiche comment envoyer une commande sur plusieurs lignes
  d'entrée. Notez le changement de l'invite&nbsp;:
<programlisting>
testdb=> <userinput>CREATE TABLE ma_table (</userinput>
testdb(> <userinput> premier integer not NULL default 0,</userinput>
testdb(> <userinput> second text</userinput>
testdb-> <userinput>);</userinput>
CREATE TABLE
</programlisting>
  Maintenant, regardons de nouveau la définition de la table&nbsp;:
<programlisting>
testdb=> <userinput>\d ma_table</userinput>
             Table "ma_table"
 Attribute |  Type   |      Modifier
-----------+---------+--------------------
 premier   | integer | not NULL default 0
 second    | text    |

</programlisting>
  Maintenant, changeons l'invite par quelque chose de plus intéressant&nbsp;:
<programlisting>
testdb=> <userinput>\set PROMPT1 '%n@%m %~%R%# '</userinput>
peter@localhost testdb=>
</programlisting>
  Supposons que nous avons rempli la table de données et que nous voulons les
  regarder&nbsp;:
<programlisting>
peter@localhost testdb=> SELECT * FROM ma_table;
 premier | second
---------+--------
       1 | one
       2 | two
       3 | three
       4 | four
(4 rows)

</programlisting>
  Vous pouvez faire apparaître cette table de façon différente en utilisant la
  commande <command>\pset</command>&nbsp;:
<programlisting>
peter@localhost testdb=> <userinput>\pset border 2</userinput>
Border style is 2.
peter@localhost testdb=> <userinput>SELECT * FROM ma_table;</userinput>
+---------+--------+
| premier | second |
+---------+--------+
|       1 | one    |
|       2 | two    |
|       3 | three  |
|       4 | four   |
+---------+--------+
(4 rows)

peter@localhost testdb=> <userinput>\pset border 0</userinput>
Border style is 0.
peter@localhost testdb=> <userinput>SELECT * FROM ma_table;</userinput>
premier second
------- ------
      1 one
      2 two
      3 three
      4 four
(4 rows)

peter@localhost testdb=> <userinput>\pset border 1</userinput>
Border style is 1.
peter@localhost testdb=> <userinput>\pset format unaligned</userinput>
Output format is unaligned.
peter@localhost testdb=> <userinput>\pset fieldsep ","</userinput>
Field separator is ",".
peter@localhost testdb=> <userinput>\pset tuples_only</userinput>
Showing only tuples.
peter@localhost testdb=> <userinput>SELECT second, first FROM
ma_table;</userinput>
one,1
two,2
three,3
four,4
</programlisting>
  Autrement, utilisez les commandes courtes&nbsp;:
<programlisting>
peter@localhost testdb=> <userinput>\a \t \x</userinput>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=> <userinput>SELECT * FROM ma_table;</userinput>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four
</programlisting>
  </para>

 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
