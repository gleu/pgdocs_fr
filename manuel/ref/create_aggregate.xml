<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/ref/create_aggregate.sgml,v 1.10 2005/09/15 07:03:26 guillaume Exp $
PostgreSQL documentation
-->
<!-- SAS 20060616 : Relecture -->

<refentry id="sql-createaggregate">
 <refmeta>
  <refentrytitle id="sql-createaggregate-title">CREATE AGGREGATE</refentrytitle>
  <refmiscinfo>SQL - Instructions du langage</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <refpurpose>Définir une nouvelle fonction d'agrégat</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE AGGREGATE <replaceable class="PARAMETER">nom</replaceable> ( <replaceable class="PARAMETER">type_donnée_entrée</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="PARAMETER">sfonc</replaceable>,
    STYPE = <replaceable class="PARAMETER">type_donnée_état</replaceable>
    [ , FINALFUNC = <replaceable class="PARAMETER">ffonc</replaceable> ]
    [ , INITCOND = <replaceable class="PARAMETER">condition_initiale</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">operateur_tri</replaceable> ]
)

ou l'ancienne syntaxe

CREATE AGGREGATE <replaceable class="parameter">nom</replaceable> (
    BASETYPE = <replaceable class="parameter">type_base</replaceable>,
    SFUNC = <replaceable class="parameter">sfonc</replaceable>,
    STYPE = <replaceable class="parameter">type_donnée_état</replaceable>
    [ , FINALFUNC = <replaceable class="parameter">ffonc</replaceable> ]
    [ , INITCOND = <replaceable class="parameter">condition_initiale</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">operateur_tri</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <indexterm zone="sql-createaggregate">
   <primary>CREATE AGGREGATE</primary>
  </indexterm>

  <para>
   <command>CREATE AGGREGATE</command> définit une nouvelle fonction d'agrégat.
   Quelques fonctions d'agrégat basiques et largement utilisées sont fournies
   dans la distribution standard&nbsp;; elles sont documentées dans le 
   <xref linkend="functions-aggregate"/>.
   <command>CREATE AGGREGATE</command> est utilisée pour ajouter des 
   fonctionnalités lors de la définition de nouveaux
   types ou si une fonction d'agrégat n'est pas fournie.
  </para>

  <para>
   Si un nom de schéma est donné (par exemple, <literal>CREATE AGGREGATE
   monschema.monagg ...</literal>), alors la fonction d'agrégat est créée dans le
   schéma précisé. Sinon, elle est créée dans le schéma courant.
  </para>

  <para>
   Une fonction d'agrégat est identifiée par son nom et son (ou ses) types de données en
   entrée. Deux agrégats dans le même schéma peuvent avoir le même nom s'ils
   opèrent sur des types différents en entrée. Le nom et le(s) type(s) de données en
   entrée d'un agrégat doivent aussi être distincts du nom et du type de données
   de toutes les fonctions ordinaires du même schéma.
  </para>

  <para>
   Une fonction d'agrégat est réalisée à partir d'une ou deux fonctions
   ordinaires&nbsp;:
   une fonction de transition d'état
   <replaceable class="parameter">sfonc</replaceable>,
   et une fonction de traitement final optionnelle
   <replaceable class="parameter">ffonc</replaceable>.
   Elles sont utilisées ainsi&nbsp;:
<programlisting><replaceable class="parameter">sfonc</replaceable>( état-interne, nouvelle-valeur-données ) ---> prochain-état-interne
<replaceable class="parameter">ffonc</replaceable>( état-interne ) ---> valeur-agrégat
</programlisting>
  </para>

  <para>
   <productname>PostgreSQL</productname> crée une variable temporaire de type
   <replaceable class="parameter">stype</replaceable> pour contenir l'état
   interne courant de l'agrégat. At each input row,
   the aggregate argument value(s) are calculated and
   the state transition function is invoked with the current state value
   and the new argument value(s) to calculate a new
   internal state value. Une fois que toutes les lignes sont traitées, la fonction
   finale est appelée une seule fois pour calculer la valeur de retour de l'agrégat.
   S'il n'existe pas de fonction finale, alors la valeur d'état final est
   retournée en l'état.
  </para>
  
  <para>
   Une fonction d'agrégat peut fournir une condition initiale, c'est-à-dire une
   valeur initiale pour la valeur de l'état interne. Elle est spécifiée et stockée
   en base comme une valeur de type <type>text</type> mais doit
   être une représentation externe valide d'une constante du type de donnée de
   la valeur d'état. Si elle n'est pas fournie, la valeur d'état est initialement 
   positionnée à NULL.
  </para>
  
  <para>
   Si la fonction de transition d'état est déclarée <quote>strict</quote>,
   alors elle ne peut pas être appelée avec des entrées NULL. Avec une telle
   fonction de transition, l'exécution d'agrégat se comporte comme suit. Rows with any null input
   values are ignored (the function is not called and the previous state value
   is retained).  If the initial state value is null, then at the first row
   with all-nonnull input values, the first argument value replaces the state
   value, and the transition function is invoked at subsequent rows with
   all-nonnull input values. Cela est pratique pour implémenter des agrégats comme
   <function>max</function>. Ce comportement n'est possible que
   quand <replaceable class="parameter">type_donnée_état</replaceable> est
   identique au premier <replaceable class="parameter">type_donnée_entrée</replaceable>.
   Lorsque ces types sont différents, une condition initiale
   non NULL doit être fournie, ou une fonction de transition non stricte utilisée.
  </para>
  
  <para>
   Si la fonction de transition d'état n'est pas stricte, alors elle sera
   appelée sans condition pour chaque ligne en entrée et devra gérer les
   entrées NULL et les valeurs de transition NULL. Cela permet à l'auteur de
   l'agrégat d'avoir le contrôle complet sur la gestion des valeurs NULL par
   l'agrégat.
  </para>
  
  <para>
   Si la fonction finale est déclarée <quote>strict</quote>, alors elle ne sera
   pas appelée quand la valeur d'état finale est NULL&nbsp;; à la place, un
   résultat NULL sera retourné automatiquement. C'est le
   comportement normal de fonctions strictes. Dans tous les cas, la fonction
   finale peut retourner une valeur NULL. Par exemple, la fonction
   finale pour <function>avg</function> renvoie NULL lorsqu'elle n'a aucune
   lignes en entrée.
  </para>
  
  <para>
   Les agrégats qui se comportent comme  <function>MIN</function> ou <function>MAX</function>
   peuvent parfois être optimisés en cherchant un index au lieu de parcourir
   toutes les lignes en entrée. Si un agrégat peut être optimisé, un 
   <firstterm>opérateur de tri</firstterm> est spécifié. Dans ce cas, il est nécessaire
   que l'agrégat fournisse le premier élément dans l'ordre imposé par
   l'opérateur&nbsp;; en d'autres mots
<programlisting>SELECT agg(col) FROM tab;
</programlisting>
   doit être équivalent à
<programlisting>SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   On suppose également que l'agrégat ignore les entrées NULL et qu'il
   fournit un résultat NULL si et seulement s'il n'y a aucune entrée NULL.
   D'ordinaire, l'opérateur <literal>&lt;</literal> d'un type de données est le bon
   opérateur de tri pour <function>MIN</function> et <literal>&gt;</literal> celui
   pour <function>MAX</function>. L'optimisation ne prend
   jamais effet sauf si l'opérateur spécifié est membre de la stratégie
   <quote>less than</quote> (NdT&nbsp;: plus petit que) ou <quote>greater
   than</quote> (NdT&nbsp;: plus grand que) d'une classe d'opérateur pour un
   index B-tree.
  </para>
 </refsect1>

 <refsect1>
  <title>Paramètres</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nom</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction d'agrégat à créer (éventuellement qualifié du nom
      du schéma).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_donnée_entrée</replaceable></term>
    <listitem>
     <para>
      An input data type on which this aggregate function operates.
      To create a zero-argument aggregate function, write <literal>*</literal>
      in place of the list of input data types.  (An example of such an
      aggregate is <function>count(*)</function>.)
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">base_type</replaceable></term>
    <listitem>
     <para>
      In the old syntax for <command>CREATE AGGREGATE</command>, the input data type
      is specified by a <literal>basetype</literal> parameter rather than being
      written next to the aggregate name.  Note that this syntax allows
      only one input parameter.  To define a zero-argument aggregate function,
      specify the <literal>basetype</literal> as
      <literal>"ANY"</literal> (not <literal>*</literal>).
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sfonc</replaceable></term>
    <listitem>
     <para>
      The name of the state transition function to be called for each
      input row.  For an <replaceable class="PARAMETER">N</replaceable>-argument
      aggregate function, the <replaceable class="PARAMETER">sfunc</replaceable>
      must take <replaceable class="PARAMETER">N</replaceable>+1 arguments,
      the first being of type <replaceable
      class="PARAMETER">state_data_type</replaceable> and the rest
      matching the declared input data type(s) of the aggregate.
      The function must return a value of type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  This function
      takes the current state value and the current input data value(s),
      and returns the next state value.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_donnée_état</replaceable></term>
    <listitem>
     <para>
      Le type de donnée pour la valeur d'état de l'agrégat.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">ffonc</replaceable></term>
    <listitem>
     <para>
      Le nom de la fonction finale à appeler pour traiter le résultat de
      l'agrégat une fois que toutes les lignes en entrée ont été parcourues.
      La fonction prend un seul argument de type <replaceable
      class="parameter">type_donnée_état</replaceable>. Le type de retour de
      l'agrégat de la fonction est défini comme le type de retour de cette
      fonction. Si <replaceable class="parameter">ffonc</replaceable> n'est pas
      spécifiée, alors la valeur d'état finale est utilisée comme résultat de
      l'agrégat et le type de retour est <replaceable
      class="parameter">type_donnée_état</replaceable>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition_initiale</replaceable></term>
    <listitem>
     <para>
      La configuration initiale pour la valeur de l'état. Elle doit être une
      constante de type chaîne de caractères dans la forme acceptée par le type
      de données <replaceable class="parameter">type_donnée_état</replaceable>.
      Si non spécifié, la valeur d'état est initialement positionnée à NULL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sort_operator</replaceable></term>
    <listitem>
     <para>
      L'opérateur de tri associé pour un agrégat de type <function>MIN</function> ou
      <function>MAX</function>. C'est seulement le nom de l'opérateur (éventuellement qualifié
      du nom du schéma). L'opérateur est supposé avoir les mêmes
      types de données en entrée que l'agrégat (qui doit être un agrégat à un seul
      argument).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Les paramètres de <command>CREATE AGGREGATE</command> peuvent être écrits
   dans n'importe quel ordre, pas uniquement dans l'ordre illustré ci-dessus.
  </para>
 </refsect1>
  
 <refsect1>
  <title>Exemples</title>

  <para>
   Voir <xref linkend="xaggr"/>.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilité</title>

  <para>
   <command>CREATE AGGREGATE</command> est une extension
   <productname>PostgreSQL</productname>. Le standard SQL ne fournit pas de
   fonctions d'agrégat utilisateur.
  </para>
 </refsect1>

 <refsect1>
  <title>Voir aussi</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate" endterm="sql-alteraggregate-title"/></member>
   <member><xref linkend="sql-dropaggregate" endterm="sql-dropaggregate-title"/></member>
  </simplelist>
 </refsect1>
</refentry>
