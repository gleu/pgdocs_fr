<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 $Header: /var/lib/cvs/pgsql-fr/sgml/catalogs.sgml,v 1.9 2005/07/15 06:14:20 guillaume Exp $
 -->

<chapter id="catalogs">
 <title>Catalogues système</title>

  <para>
   Les catalogues système sont le lieu où une base de données relationnelle
   stocke les métadonnées des schémas, comme les informations sur les tables 
   et les colonnes, et des données de suivi internes.
   Les catalogues système de <productname>PostgreSQL</productname> sont de
   simples tables. Vous pouvez les supprimer et les recréer, ajouter des
   colonnes, insérer et mettre à jour des valeurs, et mettre un joyeux bazar
   dans votre système. Normalement, on ne devrait pas modifier les catalogues
   système soi-même, il y a toujours des commandes SQL pour le faire. (Par
   exemple, <command>CREATE DATABASE</command> insère une ligne dans le 
   catalogue <structname>pg_database</structname> &mdash; et crée physiquement
   la base de données sur le disque.) Il y a des exceptions pour certaines 
   opérations particulièrement ésotériques, comme l'ajout de méthodes d'accès
   aux index.
  </para>

 <sect1 id="catalogs-overview">
  <title>Aperçu</title>

  <para>
   <xref linkend="catalog-table"> liste les catalogues système.
   Une documentation détaillée sur les catalogues systèmes vient plus loin.
  </para>

  <para>
   La plupart des catalogues système sont recopiés de la base de données modèle
   lors de la création de la base de données et sont donc spécifiques à 
   chaque base de données. Un petit nombre de catalogues sont physiquement 
   partagés par toutes les bases de données d'une installation de 
   <productname>PostgreSQL</productname>. Ils sont indiqués dans les 
   descriptions des catalogues.
  </para>

  <table id="catalog-table">
   <title>Catalogues système</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom du catalogue</entry>
      <entry>Contenu</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>fonctions d'agrégat</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>opérateurs des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>procédures de support des méthodes d'accès</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>valeurs par défaut des colonnes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>colonnes des tables (<quote>attributs</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>conversions de types de données (cast)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, index, séquences, vues (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>contraintes de vérification, contraintes uniques, contraintes de  
      clés primaires, contraintes de clés étrangères</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>informations de conversions de codage</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>bases de données de l'installation <productname>PostgreSQL</productname> </entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dépendances entre objets de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions ou commentaires des objets de base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groupes d'utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>informations supplémentaires des index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>hiérarchie d'héritage de tables</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>langages pour écrire des fonctions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>gros objets</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-listener"><structname>pg_listener</structname></link></entry>
      <entry>support de notification asynchrone</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schémas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>classes d'opérateurs de méthodes d'accès aux index</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>opérateurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>fonctions et procédures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>règles de réécriture de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>statistiques de l'optimiseur de requêtes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>tablespaces dans ce groupe de bases de données</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>déclencheurs</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>types de données</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_aggregate</structname> stocke les informations 
   sur les fonctions d'agrégat. Une fonction d'agrégat est une fonction
   qui opère sur un ensemble de données (typiquement une colonne de chaque ligne
   qui correspond à une condition de requête) et retourne une valeur unique 
   calculée à partir de toutes ces valeurs.
   Les fonctions d'agrégat classiques sont
   <function>sum</function> (somme), <function>count</function> (compteur) et
   <function>max</function> (plus grande valeur). Chaque entrée dans
   <structname>pg_aggregate</structname> est une extension d'une entrée dans
   <structname>pg_proc</structname>.  L'entrée de <structname>pg_proc</structname>
   décrit le nom de l'agrégat, les types de données d'entrée et de sortie, et
   d'autres informations des fonctions ordinaires.
  </para>

  <table>
   <title>Les colonnes de <structname>pg_aggregate</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID <structname>pg_proc</structname> de la fonction
       d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>fonction de transition</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>fonction finale (zéro s'il n'y en a pas)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type de la donnée interne de transition (état) de la fonction d'agrégat</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Valeur initiale de la fonction de transition. C'est un champ texte qui
       contient la valeur initiale dans sa représentation externe en chaîne de 
       caractères. Si la valeur est NULL, la valeur d'état de transition 
       est initialement NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les nouvelles fonctions d'agrégat sont enregistrées avec la commande 
   <command>CREATE AGGREGATE</command>. Lisez la <xref linkend="xaggr">  pour 
   avoir plus d'informations sur l'écriture des fonctions d'agrégat et sur
   la signification des fonctions de transition, etc.
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_am</structname> enregistre les informations sur
   les méthodes d'accès aux index. Il y a une ligne pour chaque méthode d'accès
   supportée par le système.
   </para>

  <table>
   <title>Colonnes de <structname>pg_am</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>ID utilisateur du propriétaire (actuellement non utilisé)</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de stratégies d'opérateur pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de routines de support pour cette méthode d'accès</entry>
     </row>

     <row>
      <entry><structfield>amorderstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Zéro si l'index n'a pas d'ordre de tri, sinon, numéro de 
      de stratégie de l'opérateur de stratégie qui décrit l'ordre de tri</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les index
       uniques&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les index
       multicolonnes&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amindexnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les entrées d'index NULLs&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amconcurrent</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Est-ce que la méthode d'accès supporte les mises à jour 
      concurrentes&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>prochaine ligne valide</quote></entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>insérer cette ligne</quote></entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>commencer un nouveau balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>redémarrer ce balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>arrêter ce balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>marquer la position actuelle dans le balayage</quote></entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>restaurer une position de balayage
       sauvegardée</quote></entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction <quote>construire un nouvel index</quote></entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de destruction en masse</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction de nettoyage post-<command>VACUUM</command></entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction d'estimation du coût d'un balayage d'index</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

   <para>
    Une méthode d'accès qui supporte les colonnes multiples (qui a 
    <structfield>amcanmulticol</structfield> à vrai) <emphasis>doit</> supporter
    l'indexation des valeurs NULL dans les colonnes autres que la première,
    parce que l'optimiseur de requêtes supposera que le parcours d'index peut 
    être utilisé pour les requêtes portant seulement sur la ou les première(s)
    colonne(s). Par exemple, supposons un index sur (a,b) et une requête 
    contenant <literal>WHERE a = 4</literal>. Le système supposera que le 
    parcours d'index peut être utilisé pour balayer les lignes pour lesquelles
    <literal>a = 4</literal>, ce qui est faux si l'index omet les lignes pour
    lesquelles <literal>b</literal> est nul. Il est cependant possible d'omettre
    les lignes dont la première colonne d'index est NULL. (GiST le fait).
    <structfield>amindexnulls</structfield> ne doit être mis à vrai que si la 
    méthode d'accès indexe toutes les lignes, y compris toute combinaison
    de valeurs NULL.
   </para>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para> Le catalogue <structname>pg_amop</structname> stocke les informations 
  sur les opérateurs associés aux classes d'opérateurs de méthodes d'accès aux index.
  Il y a une ligne pour chaque opérateur qui est membre d'une classe d'opérateurs.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amop</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>La classe d'opérateur d'index de cette entrée.</entry>
     </row>

     <row>
      <entry><structfield>amopsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Sous-type pour distinguer plusieurs entrées d'une stratégie&nbsp;;
       zéro par défaut</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de stratégie d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>amopreqcheck</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Une entrée trouvée dans l'index doit être revérifiée.</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID de l'opérateur</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_amproc</structname> enregistre des informations
   sur les procédures de support associées aux classes d'opérateurs de méthodes 
   d'accès. Il y a une ligne pour chaque procédure de support appartenant à
   une classe d'opérateur.
  </para>

  <table>
   <title>Colonnes de <structname>pg_amproc</structname></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>La classe d'opérateurs d'index de cette entrée</entry>
     </row>

     <row>
      <entry><structfield>amprocsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Sous-type dans le cas d'une routine intertype, zéro sinon</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Numéro de procédure de support</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID de la procédure</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attrdef</structname> stocke les valeurs par
   défaut des colonnes. Les informations principales des colonnes sont stockées
   dans <structname>pg_attribute</structname> (voir plus loin). Seules les
   colonnes pour lesquelles une valeur par défaut est explicitement spécifiée
   (quand la table est créée ou quand une colonne est ajoutée) ont une entrée dans 
   <structname>pg_attrdef</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attrdef</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table de cette colonne.</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Numéro de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Représentation interne de la valeur par défaut de la colonne</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Une représentation lisible de la valeur par défaut</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le champ <structfield>adsrc</structfield> est historique et il est mieux 
   de ne pas l'utiliser parce qu'il ne conserve pas de trace des modifications qui
   pourraient affecter la représentation de la valeur par défaut. La
   compilation inverse du champ <structfield>adbin</structfield> (avec
   <function>pg_get_expr</> par exemple) est une meilleure façon d'afficher la
   valeur par défaut.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_attribute</structname> stocke les informations
   sur les colonnes des tables. Il y a exactement une ligne de 
   <structname>pg_attribute</structname> pour chaque colonne de chaque table de
   la base de données. (Il y a aussi des attributs pour les index et, en fait,
   tous les objets qui possèdent des entrées dans <structname>pg_class</structname>.)
  </para>

  <para>
   Le terme attribut est équivalent à colonne et est utilisé pour des raisons 
   historiques.
  </para>

  <table>
   <title>Colonnes de <structname>pg_attribute</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>La table de cette colonne</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Le nom de la colonne</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Le type de données de cette colonne</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> contrôle le niveau de détail des
       statistiques accumulées pour cette colonne par <xref linkend="sql-analyze"
       endterm="sql-analyze-title">.
       Une valeur de zéro indique qu'aucune statistique ne doit être collectée.
       Une valeur négative indique d'utiliser l'objectif de statistiques 
       par défaut.
       Le sens exacte d'une valeur positive dépend du type de données.
       Pour les données scalaires, <structfield>attstattarget</structfield>
       est à la fois le nombre visé de <quote>valeurs les plus courantes</quote>
       et le nombre visé d'histogrammes à créer.
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typlen</literal> pour le type de cette 
       colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Le numéro de la colonne. Les colonnes ordinaires sont numérotées en 
       commençant par 1. Les colonnes système, comme les 
       <structfield>oid</structfield>, ont des numéros négatifs arbitraires.
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre de dimensions, si la colonne est de type tableau, sinon 0.
       (Pour l'instant, le nombre de dimensions des tableaux n'est pas contrôlé,
       donc une valeur autre que zéro indique que <quote>c'est un tableau</>.)
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Toujours -1 sur disque, mais peut être mis à jour, en mémoire, pour 
       mettre en cache l'emplacement de l'attribut dans la ligne.
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> des données spécifiques au type
       de données précisé lors de la création de la table (par exemple, la
       taille maximale d'une colonne de type <type>varchar</type>). Il est
       transmis à des fonctions spécifiques au type d'entrée de données et de
       vérification de taille. La valeur est généralement de -1 pour les types
       de données qui n'ont pas besoin de <structfield>atttypmod</>.
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Une copie de <literal>pg_type.typbyval</> pour ce type de données.
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contient normalement une copie de <literal>pg_type.typstorage</> pour
       ce type de données. Pour les types de données TOASTables, cette valeur 
       peut être modifiée après la création de la colonne pour contrôler la règle
       de stockage.
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Contient une copie de <literal>pg_type.typalign</> pour le type de 
       cette colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique une contrainte de colonne non NULL. Il est possible de changer
       cette colonne pour activer ou désactiver cette contrainte. 
       </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que cette colonne a une valeur par défaut. Dans ce cas, il y 
       aura une entrée correspondante dans le catalogue 
       <structname>pg_attrdef</structname> pour définir cette valeur.
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique que cette colonne a été supprimée et n'est plus valide. Une 
       colonne supprimée est toujours présente physiquement dans la table,
       mais elle est ignorée par l'analyseur de requête et ne peut être
       accédée en SQL.
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Cette colonne est définie localement dans la relation. Notez qu'une
       colonne peut être définie localement et héritée simultanément.
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Nombre d'ancêtres directs de cette colonne. Une colonne qui a un nombre
       d'ancêtres différent de zéro ne peut être supprimée ni renommée.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
	Dans l'entrée <structname>pg_attribute</structname> d'une colonne
	supprimée, <structfield>atttypid</structfield> est réinitialisée à
	zéro mais <structfield>attlen</structfield> et les autres champs copiés à
	partir de <structname>pg_type</> sont toujours valides. Cet arrangement est
	nécessaire pour s'adapter à la situation où le type de données de la
	colonne supprimée a été ensuite supprimé et qu'il n'existe donc plus de
	ligne <structname>pg_type</>. <structfield>attlen</structfield> et les
	autres champs peuvent être utilisés pour interpréter le contenu
	d'une ligne de la table.
  </para>
 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_cast</structname> stocke les chemins de 
   conversion de type de donnée, qu'ils soient par défaut ou définis avec la
   commande <command>CREATE CAST</command>.
  </para>

  <table>
   <title>Colonnes de <structfield>pg_cast</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données source</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID du type de données en sortie</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       OID de la fonction à utiliser pour faire cette conversion. Vaut Zéro si
       les types de données sont binairement compatibles (c'est-à-dire si aucune
       opération n'est nécessaire pour effectuer la transformation).
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indique dans quel contexte la conversion peut être utilisée.
       <literal>e</> si seules les conversions explicites sont autorisées (avec
       <literal>CAST</> ou <literal>::</>).
       <literal>a</> si les conversions implicites lors de l'affectation à une
       colonne sont autorisées, en plus des conversions explicites.
       <literal>i</> si les conversions implicites dans les expressions sont 
       autorisées en plus des autres cas.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
    Les fonctions de conversion listées dans <structname>pg_cast</structname>
    doivent toujours prendre le type source de la conversion comme type du
    premier argument et renvoyer le type de destination de la conversion comme
    type de retour. Une fonction de conversion peut avoir jusqu'à trois
    arguments. Le deuxième argument, s'il est présent, doit être du type
    <type>integer</>&nbsp;; il reçoit le modificateur de type associé avec le
    type de destination ou <literal>-1</> s'il n'y en a pas. Le troisième
    argument, s'il est présent, doit être du type <type>boolean</>&nbsp;; il
    reçoit <literal>true</> si la conversion est une conversion explicite,
    <literal>false</> sinon.
  </para>

  <para>
    Il est légitime de créer une entrée <structname>pg_cast</structname> dans
    laquelle les types source et cible sont les mêmes, si la fonction associée
    prend plus d'un argument. De telles entrées représentent les
    <quote>fonctions de coercition de longueur</> qui forcent les valeurs du type
    à être légal pour une valeur particulière du modificateur de type.
    Néanmoins, notez qu'à présent il n'existe aucun support pour associer des
    modifications de type autres que ceux de base avec des types de données créés
    par l'utilisateur. Du coup, cette fonctionnalité est seulement utile pour
    un petit nombre de types intégrés qui ont une syntaxe de modificateur de
    type construit dans leur grammaire.
  </para>

  <para>
    Quand une entrée <structname>pg_cast</structname> a des types différents
    pour la source et la destination et qu'une fonction prend plus d'un
    argument, il représente la conversion d'un type vers un autre et la
    coercition en une seule étape. Quand une telle entrée est absente, la
    coercition vers un type qui utilise un modificateur de type implique deux
    étapes, une pour convertir entre les types de données et une seconde pour
    appliquer le modificateur.
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_class</structname> catalogue les tables, et 
   à peu près tout ce qui a des colonnes ou qui ressemble de près ou de loin à
   une table. Cela inclut les index (mais il faut aussi aller voir dans
   <structname>pg_index</structname>), les séquences, les vues, les types
   composites et certaines sortes de relations spéciales&nbsp;; voir
   <structfield>relkind</>.
   Par la suite, lorsque l'on parle de <quote>relation</quote>, on parle de
   tous ces types d'objets. Toutes les colonnes n'ont pas un sens pour tous les
   types de relations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_class</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la table, vue, index, etc.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms qui contient cette relation.
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>
       OID du type de données qui correspond au type de ligne de cette table,
       s'il y en a un.
       Zéro pour les index qui n'ont pas d'entrée dans <structname>pg_type</>.
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
       .usesysid</literal></entry>
      <entry>Propriétaire de la relation.</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-am"><structname>pg_am</structname></link>
       .oid</literal></entry>
      <entry>Si c'est un index, OID de la méthode d'accès utilisée (B-tree,
       hash, etc.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Nom du fichier disque de cette relation&nbsp;; 0 s'il n'y en a
       pas.</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le tablespace dans lequel cette relation est stockée. Si zéro, l'espace
       logique par défaut de cette base de données est utilisée. (Sans intérêt si
       la relation n'a pas de fichier sur disque.)
     </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Taille du fichier disque, exprimée en pages (de taille 
       <symbol>BLCKSZ</symbol>).
       Ce n'est qu'une estimation utilisée par l'optimiseur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme <command>CREATE
       INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Nombre de lignes de la table.
       Ce n'est qu'une estimation utilisée par l'optimiseur. Elle est mise à 
       jour par les commandes <command>VACUUM</command>,
       <command>ANALYZE</command> et quelques commandes DDL comme
       <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table TOAST associée à cette table. 0 s'il n'y en a pas.
       La table TOAST stocke les attributs de grande taille <quote>hors de la
       ligne</quote> dans une table secondaire.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       Pour une table TOAST, OID de son index. 0 si ce n'est pas une table
       TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si cette table a (ou a eu récemment) un ou plusieurs index.
       Ce champ est mis à jour par <command>CREATE INDEX</command>, mais pas
       remis à faux immédiatement après <command>DROP INDEX</command>.
       <command>VACUUM</command> remet <structfield>relhasindex</> à faux s'il
       s'aperçoit que la table n'a pas d'index.
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si cette table est partagée par toutes les bases de données
      du groupe de bases de données. Seuls certains catalogues système (comme
      <structname>pg_database</structname>) sont partagés.</entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</> = table ordinaire, <literal>i</> = index,
       <literal>S</> = séquence, <literal>v</> = vue, <literal>c</> =
       type composite, <literal>s</> = spécial, <literal>t</> = table TOAST.
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de colonnes utilisateur dans la relation (sans compter les
       colonnes système). Il doit y avoir le même nombre d'entrées dans
       <structname>pg_attribute</structname>. Voir aussi
       <literal>pg_attribute.attnum</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de contraintes de vérification sur la table&nbsp;; voir le
       catalogue <structname>pg_constraint</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltriggers</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Nombre de déclencheurs sur la table&nbsp;; voir le catalogue
       <structname>pg_trigger</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>relukeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé. (Ce n'est <emphasis>pas</emphasis> le nombre de clés
       uniques de la table.)</entry>
     </row>

     <row>
      <entry><structfield>relfkeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé. (Ce n'est <emphasis>pas</emphasis> le nombre de clés 
      étrangères de la table.)</entry>
     </row>

     <row>
      <entry><structfield>relrefs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Inutilisé</entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si on génère un OID pour chaque ligne de la relation.
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si la table a (ou a eu) une clé primaire.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table comprend des règles&nbsp;; voir le catalogue
       <structname>pg_rewrite</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si au moins une table hérite ou a hérité de celle-ci.</entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"> pour plus de
       détails.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_constraint</structname> stocke les vérifications,
   clés primaires, clés uniques et étrangères des tables (Les contraintes de
   colonnes ne sont pas traitées de manière particulière. Elles sont 
   équivalentes à des contraintes de tables.) Les contraintes NOT NULL sont
   représentées dans le catalogue <structname>pg_attribute</>.
  </para>

  <para>
   Les contraintes de vérification de domaine sont aussi stockées ici.
  </para>

  <table>
   <title>Colonnes de <structname>pg_constraint</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte (pas nécessairement unique&nbsp;!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms qui contient cette contrainte.
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</> = contrainte de vérification,
        <literal>f</> = contrainte de clé étrangère,
        <literal>p</> = contrainte de clé primaire,
        <literal>u</> = contrainte de clé unique
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte est-elle différable&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La contrainte est-elle différée par défaut&nbsp;?</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid
       </literal></entry>
      <entry>Table à laquelle appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de table.
      </entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Domaine auquel appartient la contrainte&nbsp;; 0 si ce n'est pas
       une contrainte de domaine.
      </entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Si c'est une clé étrangère, la table référencée&nbsp;; sinon
       0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de mise à jour de la clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Code de l'action de suppression de clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Type de vérification de clé étrangère</entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</></entry>
      <entry>Si c'est une contrainte de table, liste des colonnes
       contraintes</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</></entry>
      <entry>Si c'est une clé étrangère, liste des colonnes référencées</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       interne de l'expression</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>S'il s'agit d'une contrainte de vérification, représentation
       compréhensible de l'expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structfield>consrc</structfield> n'est pas mis à jour lors de modification
    d'objets référencés&nbsp;; par exemple, il ne pistera pas les renommages de
    colonnes. Plutôt que se fier à ce champ, il est mieux d'utiliser
    <function>pg_get_constraintdef()</> pour extraire la définition d'une
    contrainte de vérification.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> doit connaître le même nombre de 
    contraintes de vérification pour chaque relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_conversion</structname> décrit les procédures
   disponibles de conversion de codage. Voir la commande <xref
   linkend="sql-createconversion" endterm="sql-createconversion-title"> pour
   plus d'information.
  </para>

  <table>
   <title>Colonnes de <structname>pg_conversion</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la conversion (unique au sein d'un espace de noms)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de nom qui contient cette conversion.
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
	linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
	.usesysid</literal></entry>
      <entry>Propriétaire de la conversion</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage source</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>ID du codage de destination</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
       .oid</literal></entry>
      <entry>Procédure de conversion</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit de la conversion par défaut</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_database</structname> stocke les informations sur
   les bases de données disponibles. Les bases de données sont créées avec la
   commande <command>CREATE DATABASE</command>. Consultez le <xref
   linkend="managing-databases"> pour avoir des détails sur la signification de
   certains paramètres.
  </para>

  <para>
   Contrairement à la plupart des catalogues système,
   <structname>pg_database</structname> est partagé entre toutes les bases de
   données d'un groupe de bases&nbsp;: il n'y a qu'une seule copie de
   <structname>pg_database</structname> par groupe, pas une par base.
  </para>

  <table>
   <title>Colonnes de <structname>pg_database</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la base de données</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
       .usesysid</literal></entry>
      <entry>Propriétaire de la base, généralement l'utilisateur qui l'a
       créée</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Codage des caractères pour cette base de données.</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ vaut vrai, alors la base peut être utilisée dans la clause
       <literal>TEMPLATE</literal> de la commande <command>CREATE
       DATABASE</command> pour créer une nouvelle base qui sera un clone de 
       celle-ci.
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si ce champ vaut faux, alors personne ne peut se connecter à cette
       base de données. Ceci permet d'empêcher toute altération de la base 
       <literal>template0</>.
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Dernier OID système de la base de données&nbsp;; utile en particulier
       pour <application>pg_dump</application>.
      </entry>
     </row>

     <row>
      <entry><structfield>datvacuumxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Toutes les lignes insérées ou supprimées par des ID de transaction
       inférieurs à celui-ci ont été marquées <quote>validé de manière avérée</quote>
       ou <quote>annulé de manière avérée</quote> dans cette base de données. 
       C'est utilisé pour déterminer quand l'espace des journaux de validation
       peut être réutilisé.
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Toutes les lignes insérées ou supprimées par des ID de transaction
       inférieurs à celui-ci ont été réétiquetés avec un ID de transaction
       permanent  (<quote>gelé</> dans cette base de données. C'est utile pour
       vérifier si une base de données doit être rapidement nettoyée avec 
       <command>VACUUM</command> pour éviter les problèmes créés par une remise
       à zéro du compteur de transaction.
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       Le tablespace par défaut de la base de données.
       À l'intérieur de cette base de données, toutes les tables pour lesquelles
       <structname>pg_class</>.<structfield>reltablespace</> vaut zéro seront
       stockées dans ce tablespace&nbsp;; en particulier, tous les catalogues
       système non partagés seront ici.
      </entry>
     </row>

     <row>
      <entry><structfield>datconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeurs par défaut de la session pour les variables modifiables en 
       cours de fonctionnement.
      </entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"> pour des détails.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_depend</structname> enregistre les relations de
   dépendances entre les objets de la base de données. Cette information permet
   à la commande <command>DROP</> de trouver quels autres objets doivent être
   supprimés par la commande <command>DROP CASCADE</> ou au contraire empêchent
   la suppression dans le cas de <command>DROP RESTRICT</>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_depend</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet dépendant se
       trouve.</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet dépendant</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>objid</> et <structfield>classid</> se réfèrent à 
       la table elle-même). Pour tous les autres types d'objets, cette colonne
       est à zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du catalogue système dans lequel l'objet référencé se trouve.
      </entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet référencé</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour une colonne de table, ce champ indique le numéro de colonne (les
       champs <structfield>refobjid</> et <structfield>refclassid</> se réfèrent
       à la table elle même). Pour tous les autres types d'objets, cette colonne
       est à zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Code définissant la sémantique de cette relation de dépendance. Voir le 
       texte.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Dans tous les cas, une entrée dans <structname>pg_depend</structname> indique
   que l'objet référence ne peut pas être supprimé sans supprimer aussi l'objet
   dépendant. Néanmoins, il y a des nuances, identifiées par
   <structfield>deptype</>&nbsp;:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</> (<literal>n</>)</term>
     <listitem>
      <para>
       Une relation normale entre des objets créés séparément. L'objet dépendant
       peut être supprimé sans affecter l'objet référencé. L'objet référencé ne
       peut être supprimé qu'en précisant l'option <literal>CASCADE</>,
       auquel cas l'objet dépendant est supprimé lui-aussi. Exemple&nbsp;: une
       colonne de table a une dépendance normale avec ses types de données. 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</> (<literal>a</>)</term>
     <listitem>
      <para>
       L'objet dépendant peut être supprimé séparément de l'objet de référence,
       et doit être automatiquement supprimé si l'objet référencé est supprimé,
       quel que soit le mode <literal>RESTRICT</> ou <literal>CASCADE</>.
       Exemple&nbsp;: une contrainte nommée sur une table est auto-dépendante
       sur la table et sera automatiquement supprimée en même temps que la
       table.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</> (<literal>i</>)</term>
     <listitem>
      <para>
       L'objet dépendant a été créé comme une partie de l'objet référencé et 
       n'est réellement qu'une partie de son implémentation interne. Un
       <command>DROP</> de l'objet dépendant sera interdit (avec un message 
       à l'utilisateur lui proposant de faire un <command>DROP</> de l'objet
       référencé à la place). Une suppression de l'objet référencé sera propagée
       à l'objet dépendant que <command>CASCADE</> soit précisé ou non.
       Exemple&nbsp;: un trigger qui est créé pour vérifier une contrainte de
       clé étrangère, est rendu dépendant de l'entrée de la contrainte dans
       <structname>pg_constraint</>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <para>
       Il n'y a pas d'objet dépendant&nbsp;; ce type d'entrée signale que le
       système lui même dépend de l'objet référencé, et donc que l'objet ne doit
       jamais être supprimé. Les entrées de ce type sont créées uniquement par
       <command>initdb</command>. Les colonnes pour l'objet dépendant 
       contiennent des zéros.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   D'autres types de dépendance pourraient apparaître dans le futur.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_description</> stocke des descriptions 
   (commentaires) optionnels pour chaque objet de la base de données. Les
   descriptions sont manipulées avec la commande <command>COMMENT</command> et
   lues avec les commandes <literal>\d</literal> de
   <application>psql</application>. Les descriptions de nombreux objets internes
   sont prédéfinies dans <structname>pg_description</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_description</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>toute colonne OID</entry>
      <entry>OID de l'objet décrit.</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID du système catalogue dans lequel apparaît l'objet
       décrit.</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Pour un commentaire sur une table, le numéro de colonne. Les champs
       <structfield>objoid</> et <structfield>classoid</> font référence à la
       table elle-même. Pour tous les autres types de données, cette colonne 
       est à zéro.
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Texte quelconque qui sert de description à cet objet.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="catalog-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_group</structname> définit les groupes et stocke
   les utilisateurs qui en sont membres. Les groupes sont créés avec
   la commande <command>CREATE GROUP</command>. Consultez le <xref
   linkend="user-manag"> pour des informations sur la gestion des droits des
   utilisateurs.
  </para>

  <para>
   Parce que les utilisateurs et les groupes sont définis pour tout le groupe 
   de bases de données, <structname>pg_group</structname> est partagé par
   toutes les bases de données du groupe&nbsp;: il n'y a qu'une seule copie de
   <structname>pg_group</structname> par groupe de bases de données, et non pas 
   une par base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_group</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du groupe</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Un numéro quelconque qui identifie ce groupe.</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>int4[]</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
       .usesysid</literal></entry>
      <entry>Tableau contenant les identifiants des utilisateurs de ce
       groupe</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_index</structname> contient une partie des 
   informations sur les index. Le reste se trouve essentiellement dans
   <structname>pg_class</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_index</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</> pour cet index</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>OID de l'entrée dans <structname>pg_class</> de la table sur 
       laquelle cet index porte.
      </entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>
       Tableau comportant <structfield>indnatts</structfield> valeurs (et pas
       plus de <symbol>INDEX_MAX_KEYS</symbol>), qui précise les colonnes
       indexées. Par exemple, une valeur de <literal>1 3</literal> indique
       que la première et la troisième colonne de la table forment la clé de 
       l'index. Une valeur de zéro dans le tableau indique que l'attribut 
       d'index correspondant est une expression sur les colonnes de la table, et
       non pas une simple référence de colonne.
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link
       linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>
       .oid</literal></entry>
      <entry>
       Pour chaque colonne dans la clé d'index, ce champ contient l'OID de
       l'opérateur de classe à utiliser. Pour plus de détails, voir
       <structname>pg_opclass</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de colonnes de l'index (duplique
      <literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai s'il s'agit d'un index unique.</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si cet index est la clé primaire de la table.
      (<structfield>indisunique</> doit toujours être vrai quand ce champ l'est
aussi.)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la table était organisée en fonction de cet index.</entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbres d'expressions (en représentation
      <function>nodeToString()</function>)
      pour les attributs d'index qui ne sont pas de simples références de 
      colonnes. Il s'agit d'une liste avec un élément pour chaque entrée à
      zéro dans <structfield>indkey</>. Nul si tous les attributs d'index sont 
      de simples références.</entry>
      </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry> Arbre d'expression (en représentation
       <function>nodeToString()</function>) pour les prédicats d'index partiels.
       Nul s'il ne s'agit pas d'un index partiel.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_inherits</> enregistre l'information sur la 
   hiérarchie d'héritage des tables. Il existe une entrée pour chaque table enfant
   direct dans la base de données. (L'héritage indirect peut être déterminé en
   suivant les chaînes des entrées.)
  </para>

  <table>
   <title>Colonnes de <structname>pg_inherits</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table fille.
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname></link>
       .oid</literal></entry>
      <entry>
       OID de la table mère.
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       S'il y a plus d'un parent direct pour une table fille (héritage multiple), ce 
       nombre indique dans quel ordre les colonnes héritées doivent être 
       arrangées. Le compteur commence à 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_language</structname> enregistre les langages
   avec lesquels vous pouvez écrire des fonctions ou des 
   procédures stockées. Voir à <xref linkend="sql-createlanguage"
   endterm="sql-createlanguage-title"> et dans le
   <xref linkend="xplang"> pour avoir plus d'information sur les gestionnaires
   de langages.
  </para>

  <table>
   <title>Colonnes de <structname>pg_language</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du langage</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vaut faux pour les langages internes (comme <acronym>SQL</acronym>) et
       vrai pour les langages définis par l'utilisateur. Pour l'instant, 
       <application>pg_dump</application> utilise ce champ pour déterminer 
       quels langages doivent être sauvegardés mais cela sera peut-être 
       un jour remplacé par un mécanisme différent.
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Indique un langage sécurisé.
       S'il s'agit d'un langage interne, cette colonne est sans importance.
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
       .oid</literal></entry>
      <entry>
       Pour les langages non-internes, ceci référence le gestionnaire de
       langage, qui est une fonction spéciale en charge de l'exécution de toutes
       les fonctions écrites dans ce langage.
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
       .oid</literal></entry>
      <entry>
       Ceci référence une fonction de validation de langage, en charge de 
       vérifier la syntaxe et la validité des nouvelles fonctions lorsqu'elles
       sont créées. Zéro si aucun validateur n'est fourni.
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"> pour les détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_largeobject</structname> contient les données
   qui décrivent les <quote>objets de grande taille</quote>. Un gros objet
   est identifié par un OID qui lui est affecté lors de sa création.
   Chaque objet de grande taille est coupé en segments ou <quote>pages</>
   suffisamment petites pour être facilement stockées dans des lignes de 
   <structname>pg_largeobject</structname>.
   La taille de données par page est définie par <literal>LOBLKSIZE</>, qui vaut
   actuellement <literal>BLCKSZ/4</>, soit habituellement 2&nbsp;Ko).
  </para>

  <table>
   <title>Colonnes de <structname>pg_largeobject</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Identifiant de l'objet de grande taille auquel appartient cette
       page.</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Numéro de cette page parmi son objet de grande taille, en partant
       de zéro.</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Données effectivement stockées dans l'objet de grande taille. Il ne fait
       jamais plus de <symbol>LOBLKSIZE</> mais peut faire moins.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Chaque ligne de <structname>pg_largeobject</structname> contient les données
   d'une page de l'objet de grande taille, en commençant à l'octet
   (<literal>pageno * LOBLKSIZE</>) de l'objet. Ceci permet un stockage
   économique&nbsp;: des pages peuvent manquer, et d'autres faire moins de
   <literal>LOBLKSIZE</> octets même si elles ne sont pas les dernières de leur
   objet. Les parties manquantes sont considérées comme des suites de zéro.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title><structname>pg_listener</structname></title>

  <indexterm zone="catalog-pg-listener">
   <primary>pg_listener</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_listener</structname> supporte les commandes
   <xref linkend="sql-listen" endterm="sql-listen-title"> et
   <xref linkend="sql-notify" endterm="sql-notify-title">. Un notifié
   (<quote>listener</quote>) crée une entrée dans
   <structname>pg_listener</structname> pour chaque nom de notification qu'il
   attend. Un notifieur parcourt <structname>pg_listener</structname>
   et met à jour chaque entrée pour montrer qu'une notification est arrivée.
   Le notifieur envoie aussi un signal (en utilisant le numéro de processus
   PID) enregistré dans la table pour prévenir le notifié.
  </para>

  <table>
   <title>Colonnes de <structname>pg_listener</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la notification. (Il ne doit pas spécialement correspondre
      à un nom de relation de la base. Le nom <structfield>relname</>
      est historique.)
      </entry>
     </row>

     <row>
      <entry><structfield>listenerpid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>PID du processus serveur qui a créé cette entrée.</entry>
     </row>

     <row>
      <entry><structfield>notification</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Zéro si aucun événement n'est en attente pour ce notifié. Si un 
       événement est en attente, ce champ contient le PID du processus serveur
       qui a envoyé cette notification.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_namespace</> stocke les espaces de noms. Un
   espace de noms est la structure sous-jacente des schémas SQL&nbsp;: chaque
   espace de noms peut avoir un ensemble séparé de relations, types, etc. sans
   qu'il y ait de conflit de noms.
  </para>

  <table>
   <title>Colonnes de <structname>pg_namespace</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'espace de noms</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
       .usesysid</literal></entry>
      <entry>Propriétaire de l'espace de noms</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"> pour des détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_opclass</structname> définit les classes
   d'opérateurs de méthodes d'accès aux index. Chaque classe d'opérateur définit
   la sémantique pour les colonnes d'index d'un type particulier, pour une
   méthode d'accès particulière. Notez qu'il peut y avoir plusieurs classes
   d'opérateurs pour une combinaison donnée de type/méthode d'accès, ce qui
   permet de supporter différents comportements.
  </para>

  <para>
   Les classes d'opérateurs sont longuement décrites dans la <xref
   linkend="xindex">.
  </para>

  <table>
   <title>Colonnes de <structname>pg_opclass</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opcamid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-am"><structname>pg_am</structname></link>
       .oid</literal></entry>
      <entry>Méthode d'accès à l'index pour lequel est la classe
       d'opérateur</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la classe d'opérateurs</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>Espace de noms de la classe d'opérateurs.</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
       .usesysid</literal></entry>
      <entry>Propriétaires de la classe d'opérateurs.</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type de données que la classe d'opérateurs indexe.</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si la classe d'opérateurs est la classe par défaut pour
       <structfield>opcintype</></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type de données stocké dans l'index ou zéro s'il s'agit du même que
       <structfield>opcintype</></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   La plus grande partie des informations définissant une classe d'opérateurs
   n'est pas dans les lignes de <structname>pg_opclass</structname> mais
   dans les lignes correspondantes de <structname>pg_amop</structname> et
   <structname>pg_amproc</structname>.
   Ces lignes sont considérées comme faisant partie de la définition de classe
   d'opérateurs, un peu de la même façon qu'une relation est définie par une
   ligne unique de <structname>pg_class</structname> et par les lignes 
   associées de <structname>pg_attribute</structname> et d'autres tables.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_operator</> stocke les informations sur les 
   opérateurs. Voir la commande <xref linkend="sql-createoperator"
   endterm="sql-createoperator-title"> et la
   <xref linkend="xoper"> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_operator</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de nom qui contient cet opérateur.
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname>
       </link>.usesysid</literal></entry>
      <entry>Propriétaire de l'opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</> = infix (<quote>les deux</quote>), <literal>l</> = prefix
       (<quote>gauche</quote>), <literal>r</> = postfix (<quote>droit</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Cet opérateur supporte les jointures par découpage.</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Type de l'opérande de gauche</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>Type de l'opérande de droite</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type du résultat</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname></link>
       .oid</literal></entry>
      <entry>Commutateur de cet opérateur, s'il en existe un.</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>Négateur de cet opérateur, s'il en existe un.</entry>
     </row>

     <row>
      <entry><structfield>oprlsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur qui permet de trier le type de l'opérateur de gauche
       (<literal>L&lt;L</>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprrsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur qui permet de trier le type de l'opérateur de droite
       (<literal>R&lt;R</>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprltcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur qui permet de comparer les types des opérandes 
       de gauche et de droite(<literal>L&lt;R</>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprgtcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-operator"><structname>pg_operator</structname>
       </link>.oid</literal></entry>
      <entry>
       Si cet opérateur supporte les jointures par fusion (merge join), ce champ
       contient l'opérateur plus grand que qui compare les types d'opérandes de 
       gauche et de droite (<literal>L&gt;R</>).
      </entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction qui implémente cet opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction d'estimation de sélectivité de restriction pour cet
       opérateur</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction d'estimation de sélectivité de jointure pour cet
       opérateur</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Les colonnes inutilisées contiennent des zéros, par exemple
   <structfield>oprleft</structfield> vaut zéro pour un opérateur préfixe.
  </para>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_proc</> stocke les informations sur les fonctions
   (ou procédures). Voir <xref linkend="sql-createfunction"
   endterm="sql-createfunction-title"> et <xref linkend="xfunc"> pour plus
   d'informations.
  </para>

  <para>
   Cette table contient des données pour les fonctions d'agrégat comme pour
   les fonctions simples. Si <structfield>proisagg</structfield> est vrai, il
   devrait y avoir une ligne correspondante dans
   <structfield>pg_aggregate</structfield>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_proc</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la fonction</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms auquel cette fonction appartient.
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname>
       </link>.usesysid</literal></entry>
      <entry>Propriétaire de la fonction.</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-language"><structname>pg_language</structname>
       </link>.oid</literal></entry>
      <entry>Langage ou interface d'appel pour cette fonction</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>La fonction est une fonction d'agrégat.</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction définit la sécurité (c'est-à-dire une
       fonction <quote>setuid</>).
      </entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Si vrai, la fonction retourne NULL si un de ses arguments au moins est
       NULL. Dans ce cas, la fonction ne sera en fait pas appelée du tout. 
       Les fonctions qui ne sont pas <quote>strictes</quote> doivent être 
       préparées à traiter des paramètres NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Si vrai, la fonction retourne un ensemble (c'est-à-dire des valeurs
       multiples du type défini).
      </entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield> indique si le résultat de la 
       fonction dépend uniquement de ses arguments ou s'il est affecté par
       des facteurs externes. Il vaut <literal>i</literal> pour les fonctions
       <quote>immuables</>, qui donnent toujours le même résultat quand les
       paramètres entrés sont les mêmes. Il vaut <literal>s</literal> pour les
       fonctions <quote>stables</>, dont le résultat (pour les mêmes paramètres
       d'entrée) ne change pas tout au long d'un balayage (de table). Il vaut
       <literal>v</literal> pour les fonctions <quote>volatiles</>, dont le
       résultat peut varier à tout instant. (Utilisez <literal>v</literal>
       aussi pour les fonctions qui ont des effets de bord, afin que les appels
       à ces fonctions ne soient pas optimisés.)
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre d'arguments</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Type de données renvoyé</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname></link>
       .oid</literal></entry>
      <entry>Tableau contenant les types de données des arguments de la
       fonction.</entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Un tableau avec les noms des arguments de la fonction. Les arguments
       sans nom sont initialisés à des chaînes vides dans le tableau. Si
       aucun des arguments n'a un nom, ce champ pourrait être NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Ce champ indique au gestionnaire de fonctions la façon d'invoquer la
       fonction. Il peut s'agir du code source pour un langage interprété, d'un
       symbole lié, d'un nom de fichier ou de n'importe quoi d'autre, en
       fonction du langage ou de la convention d'appel.
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Information supplémentaire sur la façon d'invoquer la fonction.
       Encore une fois, l'interprétation dépend du langage.
      </entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Droits d'accès&nbsp;; voir <xref linkend="sql-grant"
       endterm="sql-grant-title"> et <xref linkend="sql-revoke"
       endterm="sql-revoke-title"> pour plus de détails.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Pour les fonctions compilées, intégrées et chargées dynamiquement,
   <structfield>prosrc</structfield> contient le nom de la fonction en langage C
   (symbol lié). Pour tous les autres types
   de langages, <structfield>prosrc</structfield> contient le code source de la
   fonction. <structfield>probin</structfield> est inutilisé, sauf pour les 
   fonctions en C chargées dynamiquement, pour lesquelles il donne le nom de 
   fichier de la bibliothèque partagée qui contient la fonction.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_rewrite</structname> stocke les règles de 
   réécriture pour les tables et les vues.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rewrite</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la règle</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table sur laquelle porte cette règle.</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Colonne sur laquelle porte cette règle. Actuellement, cette colonne
       vaut toujours zéro pour indiquer qu'il s'agit de la table entière.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Type d'évènement déclenchant la règle&nbsp;:
        1 = <command>SELECT</>, 2 = <command>UPDATE</>, 3 = <command>INSERT</>, 
        4 = <command>DELETE</>
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai s'il s'agit d'une règle <literal>INSTEAD</literal> 
       (à la place de).
      </entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Arbre d'expression (sous la forme d'une représentation
       <function>nodeToString()</function>) pour la condition qualifiant la
       règle.
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Arbre de requête (sous la forme d'une représentation
       <function>nodeToString()</function>) pour l'action de la règle.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    doit être vrai si une table a au moins une règle dans ce catalogue.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="catalog-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_shadow</structname> contient les informations sur
   les utilisateurs de la base de données. Le nom provient du fait que cette
   table ne doit pas être lisible par le public, vu qu'elle contient 
   des mots de passe.
   <link linkend="view-pg-user"><structname>pg_user</structname></link> est une
   vue accessible par tous sur <structname>pg_shadow</structname> qui masque le
   champ mot de passe.
  </para>

  <para>
   <xref linkend="user-manag"> contient des informations détaillées sur les
   utilisateurs et la gestion des droits d'accès.
  </para>

  <para>
   Parce que les identités des utilisateurs sont globales au groupe de bases de
   données (cluster), <structname>pg_shadow</structname> est partagé par toutes
   les bases de données d'un groupe de bases de données&nbsp;: il n'y a qu'une
   seule copie de <structname>pg_shadow</structname> par groupe de bases de
   données, et non pas une par base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_shadow</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Identifiant de l'utilisateur (numéro arbitraire utilisé pour
      référencer cet utilisateur).</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur a le droit de créer des bases de données.</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur est un super-utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       L'utilisateur a le droit de modifier les catalogues système. (Même un
       super-utilisateur n'a pas le droit de le faire si cette colonne n'est 
       pas vraie).
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Mot de passe (pouvant être crypté)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Date et heure d'expiration du mot de passe (utilisé seulement pour 
      l'authentification par mot de passe).</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Valeur par défaut de session pour les variables de 
       configuration lors de l'exécution.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_statistic</structname> stocke des données
   statistiques sur le contenu de la base de données. Les entrées sont créées 
   par <command>ANALYZE</command>, puis utilisées par l'optimiseur de requêtes.
   Il y a une entrée pour chaque colonne de table qui a été analysée.
   Notez que les données statistiques sont par définition des approximations, 
   même si elles sont à jour.
  </para>

  <para>
   <structname>pg_statistic</structname> stocke aussi les données
   statistiques sur les valeurs des expressions d'index. Elles sont décrites
   comme si elles étaient de vraies colonnes&nbsp;; en particulier,
   <structfield>starelid</structfield> référence l'index. Néanmoins, aucune
   entrée n'est effectuée pour une colonne d'index ordinaire sans expression
   car cela serait redondant avec l'entrée pour la colonne sous-jacente de la
   table.
  </para>

  <para>
   Comme des statistiques différentes seront appropriées pour des types de 
   données différents, <structname>pg_statistic</structname> est prévu pour
   ne faire qu'un minimum de suppositions sur les types de statistiques qu'il
   stocke. Seules des statistiques extrêmement générales (comme les valeurs
   NULL) ont des colonnes dédiées. Tout le reste est stocké dans des 
   <quote>emplacements</quote>, qui sont des groupes de colonnes associées 
   dont le contenu est identifié par un numéro de code dans l'une des colonnes
   de l'emplacement. Pour plus d'information, voir 
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> ne doit pas être lisible par le public
   car même les données statistiques peuvent être considérées comme sensibles.
   (Exemple&nbsp;: les valeurs maximales et minimales d'une colonne de salaire
   peuvent être assez intéressantes).
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link> est
   une vue sur <structname>pg_statistic</structname> accessible à tous, qui
   n'expose que les informations sur ces tables qui sont accessibles à
   l'utilisateur courant.
  </para>

  <table>
   <title>Colonnes de <structname>pg_statistic</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table ou index à laquelle la colonne décrite appartient.</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link
       linkend="catalog-pg-attribute"><structname>pg_attribute</structname>
       </link>.attnum</literal></entry>
      <entry>Numéro de la colonne décrite.</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Fraction des entrées de la colonne qui ont une valeur
       NULL.</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Taille moyenne stockée des entrées non NULL.</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry> 
       Nombre de valeurs distinctes non NULL dans la colonne. Une 
       valeurs positive est le nombre réel de valeurs distinctes. Une valeur
       négative est le négatif d'une fraction du nombre de lignes dans la table
       (par exemple, une colonne dans laquelle les valeurs apparaissent environ
       deux fois en moyenne pourrait être représentée par 
       <structfield>stadistinct</> = -0.5). Une valeur à zéro indique que le
       nombre de valeurs distinctes est inconnu.
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Numéro de code indiquant quel type de statistiques est stocké dans
       <quote>l'emplacement</quote> numéro <replaceable>N</> de la ligne de
       <structname>pg_statistic</structname>.
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
	linkend="catalog-pg-operator"><structname>pg_operator</structname>
	</link>.oid</literal></entry>
      <entry>
       Opérateur utilisé pour dériver les statistiques stockées dans 
       <quote>l'emplacement</quote> numéro <replaceable>N</>. Par exemple, un
       emplacement d'histogramme montrerait l'opérateur <literal>&lt;</literal>,
       qui définit l'ordre de tri des données.
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Statistiques numériques du genre approprié pour
       <quote>l'emplacement</quote> numéro <replaceable>N</> ou NULL si le type
       d'emplacement ne nécessite pas de valeurs numériques.
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Valeurs de données de la colonne du type approprié pour 
       <quote>l'emplacement</quote> numéro <replaceable>N</> ou NULL si
       le type d'emplacement ne stocke aucune valeur de données. Chaque valeur
       d'élément du tableau est en fait du type de données de la colonne 
       spécifiée, si bien qu'il n'y a aucun moyen de définir ces colonnes 
       autrement qu'avec le type <type>anyarray</> (tableau quelconque).
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
   <title><structname>pg_tablespace</structname></title>
   
   <indexterm zone="catalog-pg-tablespace">
     <primary>pg_tablespace</primary>
   </indexterm>
   
   <para>
     Le catalogue <structname>pg_tablespace</structname> enregistre les
     informations sur les tablespaces disponibles. Les tables peuvent
     être placées dans des tablespaces particuliers pour aider à
     l'administration des espaces de stockage.
   </para>
   
   <para>
     Contrairement à la plupart des catalogues système, 
     <structname>pg_tablespace</structname> est partagée parmi toutes les bases
     de données du groupe&nbsp;: il n'y a donc qu'une copie de
     <structname>pg_tablespace</structname> par groupe, et non pas une par
     base.
   </para>
   
   <table>
     <title>Colonnes de <structname>pg_tablespace</></title>
   
   <tgroup cols=4>
     <thead>
       <row>
         <entry>Nom</entry>
         <entry>Type</entry>
         <entry>Références</entry>
         <entry>Description</entry>
       </row>
     </thead>
     
     <tbody>
       <row>
         <entry><structfield>spcname</structfield></entry>
         <entry><type>name</type></entry>
         <entry></entry>
         <entry>Nom du tablespace</entry>
       </row>
       
       <row>
         <entry><structfield>spcowner</structfield></entry>
         <entry><type>int4</type></entry>
         <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
         <entry>Propriétaire du tablespace, habituellement l'utilisateur
           qui l'a créé</entry>
       </row>
       
       <row>
         <entry><structfield>spclocation</structfield></entry>
         <entry><type>text</type></entry>
         <entry></entry>
         <entry>Emplacement (chemin vers le répertoire) de l'espace
           logique</entry>
       </row>
       
       <row>
         <entry><structfield>spcacl</structfield></entry>
         <entry><type>aclitem[]</type></entry>
         <entry></entry>
         <entry>
           Droits d'accès&nbsp;; voir
           <xref linkend="sql-grant" endterm="sql-grant-title"> et
           <xref linkend="sql-revoke" endterm="sql-revoke-title"> pour les
           détails.
           </entry>
           </row>
         </tbody>
       </tgroup>
     </table>
   </sect1>


   <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_trigger</structname> stocke les informations sur
   les déclencheurs des tables. Voir la commande <xref linkend="sql-createtrigger"
   endterm="sql-createtrigger-title"> pour plus d'informations.
  </para>

  <table>
   <title>Colonnes de <structname>pg_trigger</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table sur laquelle porte le déclencheur</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>
       Nom du déclencheur (doit être unique parmi les déclencheurs 
       d'une table).
      </entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction à appeler</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Masque de bits identifiant les conditions du déclencheur.</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est activé. Ceci n'est pas vérifié de
       manière fiable partout où cela devrait, si bien que désactiver un
       déclencheur ne fonctionne pas de manière fiable.
      </entry>
     </row>

     <row>
      <entry><structfield>tgisconstraint</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur implémente une contrainte d'intégrité 
       référentielle.
      </entry>
     </row>

     <row>
      <entry><structfield>tgconstrname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de la contrainte d'intégrité référentielle.</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>Table référencée par une contrainte d'intégrité
       référentielle.</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si le déclencheur est différable.</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Vrai si initialement le déclencheur est différé.</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Nombre de chaînes d'arguments passées à la fonction de
       déclencheur.</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Actuellement inutilisé.</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Chaînes d'arguments à passer au déclencheur, chacune terminée par un
       NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.reltriggers</literal> doit être d'accord avec le nombre
    de déclencheurs trouvés dans cette table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   Le catalogue <structname>pg_type</structname> stocke les informations sur les
   types de données. Les types de base (types scalaires) sont créés avec la 
   commande <xref linkend="sql-createtype" endterm="sql-createtype-title"> et
   les domaines avec <xref linkend="sql-createdomain"
   endterm="sql-createdomain-title">. Un type composite est créé
   automatiquement pour chaque table de la base et représenter ainsi la
   structure des lignes de la table. Il est aussi possible de créer des types
   composites avec <command>CREATE TYPE AS</command> .
  </para>

  <table>
   <title>Colonnes de <structname>pg_type</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom du type</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-namespace"><structname>pg_namespace</structname>
       </link>.oid</literal></entry>
      <entry>
       OID de l'espace de noms qui contient ce type.
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link
       linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
       .usesysid</literal></entry>
      <entry>Propriétaire du type</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Pour les types de taille fixe, <structfield>typlen</structfield> est le
       nombre d'octets de la représentation interne du type. Mais pour les types
       de longueur variable, <structfield>typlen</structfield> est négatif.
       -1 indique un type <quote>varlena</>  (qui a un attribut de longueur),
       -2 indique une chaîne C terminée par le caractère NULL.
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> détermine si les routines internes
       passent une valeur de ce type par valeur ou par référence.
       <structfield>typbyval</structfield> doit être faux si 
       <structfield>typlen</structfield> ne vaut pas 1, 2 ou 4 (ou 8 sur les
       machines dont le mot-machine est de 8 octets). Les types de longueur
       variable sont toujours passés par référence. Notez que
       <structfield>typbyval</structfield> peut être faux même si la longueur
       permettrait un passage par valeur&nbsp;; c'est le cas pour le type 
       <type>float4</type>, par exemple.
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> vaut <literal>b</literal> pour un
       type de base, <literal>c</literal> pour un type composite (c'est-à-dire
       le type d'une ligne de table), <literal>d</literal> pour un domaine
       ou <literal>p</literal> pour un pseudo-type. 
       Voir aussi <structfield>typrelid</structfield> et
       <structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Vrai si le type est défini et faux s'il ne s'agit que d'un remplissage
       pour un type qui n'est pas encore défini. Lorsque 
       <structfield>typisdefined</structfield> est faux, rien à part le nom du
       type, l'espace de noms et l'OID n'est fiable.
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Caractère qui sépare deux valeurs de ce type lorsque le programme
       lit les valeurs d'un tableau en entrée. Notez que le délimiteur est
       associé au type d'élément du tableau, pas au type tableau.
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-class"><structname>pg_class</structname>
       </link>.oid</literal></entry>
      <entry>
       S'il s'agit d'un type composite (voir
       <structfield>typtype</structfield>), alors cette colonne pointe vers la
       ligne de <structname>pg_class</structname> qui définit la table
       correspondante. Pour un type composite sans table, l'entrée dans
       <structname>pg_class</structname> ne représente pas vraiment une table,
       mais elle est néanmoins nécessaire pour trouver les lignes de
       <structname>pg_attribute</structname> liées au type. Zéro pour les types
       autres que composites.
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry>
       Si <structfield>typelem</structfield> ne vaut pas 0, alors il identifie
       une autre ligne de <structname>pg_type</structname>. Le type courant peut
       alors être utilisé comme un tableau contenant des valeurs de type
       <structfield>typelem</structfield>. Un <quote>vrai</quote> type tableau a
       une longueur variable (<structfield>typlen</structfield> = -1), mais
       certains types de longueur fixe (<structfield>typlen</structfield> &gt;
       0) ont aussi un <structfield>typelem</structfield> non nul, par exemple 
       <type>name</type> et <type>oidvector</type>. Si un type de longueur fixe 
       a un <structfield>typelem</structfield>, alors sa représentation interne
       doit être un certain nombre de valeurs de ce type
       <structfield>typelem</structfield>, sans autre donnée. Les types de
       données tableau de taille variable ont un en-tête défini par les
       sous-routines de tableau.
       </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format texte).</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format texte).</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en entrée (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link
       linkend="catalog-pg-proc"><structname>pg_proc</structname>
       </link>.oid</literal></entry>
      <entry>Fonction de conversion en sortie (format binaire), 
       ou 0 s'il n'y en a pas</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Fonction ANALYZE personnalisée  ou 0 pour utiliser la fonction standard</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> est l'alignement requis pour stocker
       une valeur de ce type. Cela s'applique au stockage sur disque aussi bien
       qu'à la plupart des représentations de cette valeur dans
       <productname>PostgreSQL</>.
       Lorsque des valeurs multiples sont stockées consécutivement, comme dans
       la représentation d'une ligne complète sur disque, un remplissage est 
       inséré avant la donnée de ce type pour qu'elle commence à l'alignement
       spécifié. La référence de l'alignement est le début de la première donnée
       de la séquence.
      </para><para>
       Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>c</> = alignement <type>char</type> ce qui signifie
          qu'aucun alignement n'est nécessaire&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>s</> = alignement <type>short</type> (deux octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>i</> = alignement <type>int</type> (quatre octets sur la
          plupart des machines)&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>d</> = alignement <type>double</type> (huit octets sur
          la plupart des machines, mais pas sur toutes).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        Pour les types utilisés dans les tables systèmes il est indispensable
        que les tailles et alignements définis dans
        <structname>pg_type</structname> soient en accord avec la façon dont le 
        compilateur disposera la colonne dans une structure représentant une 
        ligne de table.
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> indique, pour les types varlena 
       (ceux pour lesquels <structfield>typlen</structfield> = -1), si le type
       est préparé pour le TOASTage et quelle stratégie par défaut doit être
       utilisée pour les attributs de ce type. Les valeurs possibles sont&nbsp;:
       <itemizedlist>
        <listitem>
         <para><literal>p</>&nbsp;: La valeur doit être stockée
          normalement&nbsp;;</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</>&nbsp;: La valeur peut être stockée dans une relation
           <quote>secondaire </quote> (si la relation en a une, voir 
           <literal>pg_class.reltoastrelid</literal>)&nbsp;;
          </para>
        </listitem>
        <listitem>
         <para><literal>m</>&nbsp;: La valeurs peut être stockée compressée sur
          place&nbsp;;</para>
        </listitem>
        <listitem>
         <para><literal>x</>&nbsp;: La valeurs peut être stockée compressée sur
          place ou stockée dans une relation <quote>secondaire</quote>.
         </para>
        </listitem>
       </itemizedlist>
       Notez que les colonnes <literal>m</> peuvent aussi être déplacées dans 
       une table de stockage secondaire, mais seulement en dernier recours
       (les colonnes <literal>e</> et <literal>x</> sont déplacées d'abord).
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield> représente une contrainte non NULL
       pour ce type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link
       linkend="catalog-pg-type"><structname>pg_type</structname>
       </link>.oid</literal></entry>
      <entry><para>
       S'il s'agit d'un domaine, (voir <structfield>typtype</structfield>),
       alors <structfield>typbasetype</structfield> identifie le type sur
       lequel celui-ci est basé. Zéro s'il ne s'agit pas d'un domaine.
       </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Les domaines utilisent <structfield>typtypmod</structfield> pour 
       enregistrer le <literal>typmod</> à appliquer à leur type de base (-1 si
       le type de base n'utilise pas de <literal>typmod</>). -1 si ce type
       n'est pas un domaine.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typndims</structfield> est le nombre de dimensions de
       tableau pour un domaine qui est un tableau (c'est-à-dire dont
       <structfield>typbasetype</> est un type tableau&nbsp;; le
       <structfield>typelem</> du domaine correspondra au
       <structfield>typelem</structfield> du type de base). Zéro pour les types
       autres que les domaines tableaux.
     </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       Si <structfield>typdefaultbin</> n'est pas NULL, ce champ est la 
       représentation <function>nodeToString()</function> d'une expression par 
       défaut pour le type. Ceci n'est utilisé que pour les domaines.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</> est NULL si le type n'a pas de valeur par
       défaut associée. Si <structfield>typdefaultbin</> est non NULL,
       <structfield>typdefault</> doit contenir une version lisible de 
       l'expression par défaut représentée par <structfield>typdefaultbin</>.
       Si <structfield>typdefaultbin</> est NULL et si
       <structfield>typdefault</> ne l'est pas, alors
       <structfield>typdefault</> est la représentation externe de la valeur par
       défaut du type, qui peut être passée à la fonction de conversion en
       entrée du type pour produire une constante.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="views-overview">
  <title>Vues système</title>

  <para>
   En plus des catalogues système, <productname>PostgreSQL</productname>
   apporte un certain nombre de vues internes. Quelques vues systèmes apportent un
   moyen simple et agréable d'accéder à des requêtes habituellement utilisées
   dans les catalogues systèmes. D'autres vues donnent accès à l'état du serveur
   interne.
  </para>

  <para>
   Le schéma information (<xref linkend="information-schema">) fournit un autre
   ensemble de vues qui rejoignent les fonctionnalités des vues systèmes. Comme
   le schéma information est en SQL standard alors que les vues décrites ici
   sont spécifiques à <productname>PostgreSQL</productname>, il est généralement
   mieux d'utiliser le schéma information si celui-ci apporte toutes les
   informations dont vous avez besoin.
  </para>

  <para>
   <xref linkend="view-table"> indique les vues systèmes décrites ici.
   Une documentation plus détaillée de chaque vue suit ceci. Il existe en plus
   des vues supplémentaires permettant d'accéder aux résultats du collecteur de
   statistiques&nbsp; elles sont décrites dans le <xref
   linkend="monitoring-stats-views-table">.
  </para>

  <para>
   Sauf lorsque c'est noté, toutes les vues décrites ici sont en lecture seule.
  </para>

  <table id="view-table">
   <title>Vues système</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Nom de la vue</entry>
      <entry>But</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>index</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>verrous actuellement contenus</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>règles</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>configuration</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>statistiques du planificateur</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>utilisateurs de la base de données</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>vues</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   La vue <structname>pg_indexes</structname> fournit un accès à des
   informations utiles sur chaque index de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_indexes</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant les tables et index</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table concernant cet index</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de l'index</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>nom du tablespace contenant l'index (NULL s'il s'agit de la
       valeur par défaut de la base de données)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>définition de l'index (une commande de création reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   La vue <structname>pg_locks</structname> fournit un accès aux informations
   concernant les verrous détenus par les transactions ouvertes à
   l'intérieur du serveur de bases de données. Voir le <xref linkend="mvcc">
   pour une discussion plus importante sur les verrous.
  </para>

  <para>
   <structname>pg_locks</structname> contient une ligne par objet verrouillable
   actif, mode de verrouillage demandé et transaction indiquée. Donc, le même
   objet verrouillable pourrait apparaître plusieurs fois si plusieurs
   transactions ont pris ou attendent des verrous sur celui-ci. Néanmoins, un
   objet qui n'est pas verrouillé n'apparaîtra pas du tout. Un objet verrouillé
   est soit une relation (c'est-à-dire une table) soit un identifiant de
   transaction.
  </para>

  <para>
   Notez que cette vue inclut seulement des verrous au niveau de la table, pas
   au niveau des lignes. Si une transaction attend un verrou ligne, il
   apparaîtra dans la vue en attente d'un identifiant de transaction du déteneur
   actuel du verrou.
  </para>

  <table>
   <title>Colonnes <structname>pg_locks</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID de la relation verrouillée ou NULL si l'objet verrouillé est un
       identifiant de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       OID de la base de données dans lequel la relation verrouillée existe ou
       zéro si la relation verrouillée est une table partagée globalement ou
       NULL si l'objet verrouillable est un identifiant de transaction
      </entry>
     </row>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       ID d'une transaction ou NULL si l'objet verrouillable est une relation
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Identifiant (PID) du processus serveur détenant ou attendant ce
       verrou</entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Nom du mode de verrou détenu ou attendu par ce processus (voir la
       <xref linkend="locking-tables">)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>vrai si le verrou est détenu, faux s'il est attendu</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>granted</structfield> est vrai sur une ligne représentant un
   verrou tenu par la session indiquée. Une valeur faux indique que cette
   session attend l'acquisition du verrou, ce qui implique qu'une autre session
   a choisi un mode de verrouillage conflictuel sur le même objet partageable.
   La session en attente dormira jusqu'à la relâche du verrou (ou jusqu'à ce
   qu'une situation de blocage soit détectée). Une session seule ne peut attendre
   d'acquérir qu'au plus un verrou à la fois.
  </para>

  <para>
   Chaque transaction détient un verrou exclusif sur son identifiant de
   transaction durant toute la durée de son exécution. Si une transaction trouve
   nécessaire d'attendre spécifiquement une autre transaction, elle le fait en
   essayant d'acquérir un verrou partagé sur l'identifiant de l'autre
   transaction. Ceci sera couronné de succès seulement lorsque l'autre
   transaction termine et relâche son verrou.
  </para>

  <para>
   Quand la vue <structname>pg_locks</structname> est accédée, les structures de
   données du gestionnaire interne de verrous sont momentanément verrouillées et
   une copie est faite pour que la vue s'affiche. Ceci nous assure que la vue
   produise un ensemble consistant de résultats, tout en ne bloquant pas les
   opérations habituelles du gestionnaire de verrous plus longuement que
   nécessaire. Néanmoins, il peut y avoir des impacts sur les performances de la
   base de données si cette vue est lue fréquemment.
  </para>

  <para>
   <structname>pg_locks</structname> fournit une vue globale de tous les verrous
   du cluster de bases de données, et non pas seulement une vue de ceux de la
   base en cours. Bien que sa colonne <structfield>relation</structfield> puisse
   être jointe avec <structname>pg_class</>.<structfield>oid</> pour identifier
   les relations verrouillées, ceci ne fonctionnera correctement qu'avec les
   relations de la base en cours (celles pour qui la colonne
   <structfield>database</structfield> est soit l'OID de la base en cours soit
   zéro).
  </para>

  <para>
   Si vous avez activé le collecteur de statistiques, la colonne
   <structfield>pid</structfield> peut être jointe à la colonne
   <structfield>procpid</structfield> de la vue
   <structname>pg_stat_activity</structname> pour obtenir plus d'information sur
   le propriétaire de la session ou attendant de détenir le verrou.
  </para>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   La vue <structname>pg_rules</structname> fournit un accès à des informations
   utiles sur les règles de réécriture des requêtes.
  </para>

  <table>
   <title>Colonnes de <structname>pg_rules</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table pour laquelle est créée la règle</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>nom de la règle</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>définition de la règle (une commande de création reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   La vue <structname>pg_rules</structname> exclut les règles ON SELECT rules
   des vues&nbsp;; elles sont disponibles dans <structname>pg_views</structname>.
  </para>

 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   La vue <structname>pg_settings</structname> fournit un accès aux paramètres
   d'exécution du serveur. C'est essentiellement une autre interface aux
   commandes <command>SHOW</> et <command>SET</>. Elle fournit aussi un accès à
   certaines informations sur chaque paramètre qui ne sont pas directement
   accessibles avec <command>SHOW</>, telles que les valeurs minimales et maximales.
  </para>

  <table>
   <title>Colonnes de <structname>pg_settings</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>nom du paramètres d'exécution</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>valeur actuelle du paramètre</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>groupe logique du paramètre</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>une description brève du paramètre</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>information supplémentaire, plus détaillée, sur le paramètre</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>contexte requis pour initialiser la valeur du paramètre</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>type du paramètre (<literal>bool</>, <literal>integer</>,
       <literal>real</> ou <literal>string</>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>source de la valeur du paramètre actuel</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>valeur minimum autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>valeur maximum autorisée du paramètre (NULL pour les valeurs non
       numériques)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   La vue <structname>pg_settings</structname> n'accepte pas d'insertion ou de
   suppression mais peut être mise à jour. Un <command>UPDATE</command> appliqué
   à une ligne de <structname>pg_settings</structname> est équivalent à
   l'exécution de la commande <xref linkend="SQL-SET" endterm="SQL-SET-title">
   sur ce paramètre nommé. Le changement affecte seulement la valeur utilisée
   par la session actuelle. Si un <command>UPDATE</command> est lancé à
   l'intérieur d'une transaction qui est annulée plus tard, les effets de la
   commande <command>UPDATE</command> disparaissent lorsque les effets de la
   transaction sont annulés. Une fois que la transaction est validée, les effets
   persistent jusqu'à la fin de la session, à moins qu'un autre
   <command>UPDATE</command> ou <command>SET</command> ne modifie la valeur.
  </para>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   La vue <structname>pg_stats</structname> fournit un accès aux informations
   stockées dans la table système <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>.
   Cette vue autorise un accès aux seules lignes de
   <structname>pg_statistic</structname> correspondant aux tables pour lequel
   l'utilisateur a un droit de lecture et, donc, aucun problème de sécurité
   n'empêche l'accès en lecture de cette vue au public.
  </para>

  <para>
   <structname>pg_stats</structname> est aussi conçu pour afficher l'information
   dans un format plus lisible que le catalogue sous-jacent, au prix d'un schéma
   qui doit être étendu lorsque de nouveaux types sont définis dans
   <structname>pg_statistic</structname>.
  </para>

  <table>
   <title>Colonnes de <structname>pg_stats</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant la table</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>nom de la colonne décrite par cette ligne</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>fraction d'entrées de colonnes qui sont NULL</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>largeur moyenne en octets des entrées de la colonne</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Si plus grand que zéro, le nombre estimé de valeurs distinctes dans
      la colonne. Si négatif, le nombre de valeurs distinctes divisé par le
      nombre de lignes, le tout muliplié par -1. (La forme négative est utilisée
      quand <command>ANALYZE</> croit que le nombre de valeurs distinctes a
      tendance à grossir au fur et à mesure que la table grossit&nbsp;; la forme
      positive est utilisé lorsque la commande semble avoir un nombre fixe de
      valeurs possibles.) Par exemple, -1 indique une colonne unique pour
      laquelle le nombre de valeurs distinctes est identique aux nombres de
      lignes.
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Une liste des valeurs habituelles dans cette colonne. (NULL si
       aucune valeur ne semble identique aux autres.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>Une liste des fréquences des valeurs les plus habituelles,
       c'est-à-dire le nombre d'occurrences de chacune divisé par le nombre
       total de lignes. (NULL lorsque
       <structfield>most_common_vals</structfield> l'est.)
     </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>Une liste des valeurs qui divisent les valeurs de la colonne en
       groupes de population approximativement identique. Les valeurs dans
       <structfield>most_common_vals</>, s'ils existent, sont omises de ce
       calcul d'histogramme. (Cette colonne est NULL si le type de données de la
       colonne ne dispose pas de l'opérateur <literal>&lt;</> ou si la liste
       <structfield>most_common_vals</> tient compte de la population complète.)
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Corrélation statistique entre l'ordre physique des lignes et
       l'ordre logique des valeurs de la colonne. Ceci va de -1 à +1. Lorsque la
       valeur est plus près de -1 ou +1, un parcours de l'index sur la colonne
       sera estimé moins cher que si cette valeur tend vers zéro, à cause de la
       réduction d'accès aléatoire au disque. (Cette colonne est NULL si le type
       de données de la colonne n'a pas l'opérateur <literal>&lt;</> operator.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Le nombre maximum d'entrées dans <structfield>most_common_vals</>
   et <structfield>histogram_bounds</> est configurable colonne par colonne en
   utilisant la commande <command>ALTER TABLE SET STATISTICS</> ou globalement
   avec le paramètre d'exécution <xref linkend="guc-default-statistics-target">.
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   La vue <structname>pg_tables</structname> fournit un accès à des informations
   utiles sur chaque table de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_tables</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>nom du schéma contenant la table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>nom de la table</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usename</literal></entry>
      <entry>nom du propriétaire de la table</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link
       linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>nom du tablespace contenant la table (NULL s'il s'agit du
       tablespace par défaut pour cette base)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>vrai si la table a (ou a récemment eu) des index</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>vrai si la table dispose de règles</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.reltriggers</literal></entry>
      <entry>vrai si la table dispose de déclencheurs (triggers)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   La vue <structname>pg_user</structname> fournit un accès aux informations
   concernant les utilisateurs de la base de données. C'est une simple vue
   lisible publiquement de
   <link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
   mais qui n'affiche pas le champ du mot de passe.
  </para>

  <table>
   <title>Colonnes de <structname>pg_user</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Nom de l'utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Identifiant de l'utilisateur (un nombre arbitraire utilisé en
       référence à cet utilisateur)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur peut créer des bases de données</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>L'utilisateur est un super-utilisateur</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       L'utilisateur pourrait mettre à jour les tables systèmes. (Même un
       super-utilisateur ne pourrait pas le faire tant que cette colonne n'est
       pas initialisée à vrai.
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Ce n'est pas le mot de passe (toujours <literal>********</>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Temps d'expiration du mot de passe (utilisé seulement pour
       l'authentification des mots de passe)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Variables d'exécution par défaut de la session</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   La vue <structname>pg_views</structname> fournit un accès à d'importantes
   informations de chaque vue de la base de données.
  </para>

  <table>
   <title>Colonnes de <structname>pg_views</></title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Nom</entry>
      <entry>Type</entry>
      <entry>Références</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Nom du schéma contenant la vue</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Nom de la vue</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usename</literal></entry>
      <entry>Nom du propriétaire de la vue</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Définition de la vue (une requête SELECT reconstruite)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->


