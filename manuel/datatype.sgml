<!--
$Header: /var/lib/cvs/pgsql-fr/sgml/datatype.sgml,v 1.7.2.2 2005/07/15 06:33:36 guillaume Exp $
-->

 <chapter id="datatype">
  <title id="datatype-title">Types de données</title>

  <indexterm zone="datatype">
   <primary>Types de données</primary>
  </indexterm>

  <indexterm>
   <primary>type</primary>
   <see>type de données</see>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> a un large choix de types de 
   données disponibles nativement.
   Les utilisateurs peuvent ajouter de nouveaux types à 
   <productname>PostgreSQL</productname> en utilisant la commande
   <command>CREATE TYPE</command>.
  </para>

  <para>
   <xref linkend="datatype-table"> montre tous les types de données
   généraux disponibles nativement.
   La plupart des types de données alternatifs listés dans la colonne
   <quote>Alias</quote> sont les noms utilisés en interne par
   <productname>PostgreSQL</productname> pour des raisons historiques.
   De plus, certains types de données internes ou obsolètes sont 
   disponibles, mais ils ne sont pas listés ici.
 
  </para>

   <table id="datatype-table">
    <title>Types de données</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Alias</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>Entier signé de 8 octets</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>Entier de 8 octets à incrémentation automatique</entry>
      </row>

      <row>
       <entry><type>bit</type></entry>
       <entry></entry>
       <entry>Suite de bits de longueur fixe</entry>
      </row>

      <row>
       <entry><type>bit varying(<replaceable>n</replaceable>)</type></entry>
       <entry><type>varbit(<replaceable>n</replaceable>)</type></entry>
       <entry>Suite de bits de longueur variable</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>Booléen (Vrai/Faux)</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
<entry> Boite rectangulaire dans le plan</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>Donnée binaire</entry>
      </row>

      <row>
       <entry><type>character varying(<replaceable>n</replaceable>)</type></entry>
       <entry><type>varchar(<replaceable>n</replaceable>)</type></entry>
       <entry>Suite de caractères de longueur variable</entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type></entry>
       <entry><type>char(<replaceable>n</replaceable>)</type></entry>
       <entry>Suite de caractères de longueur fixe</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>Adresse réseau IPv4 ou IPv6 </entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>Cercle dans le plan</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>Date du calendrier (année, mois, jour)</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>Nombre à virgule flottante de double précision</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>Adresse d'ordinateur IPv4 ou IPv6</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>Entier signé de 4 octets</entry>
      </row>

      <row>
       <entry><type>interval(<replaceable>p</replaceable>)</type></entry>
       <entry></entry>
       <entry>Interval de temps</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>Ligne infinie dans le plan (partiellement disponible)</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>Segment de droite dans le plan</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>adresse MAC</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>montant d'une devise</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
<entry>Nombre exact de la précision indiquée</entry>
      </row>
      
      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>Chemin ouvert et fermé dans le plan</entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>Point géométrique dans le plan</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>Chemin géométrique fermé dans le plan</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>Nombre à virgule flottante de simple précision</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>Entier signé de 2 octets</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>Entier de 4 octets à incrémentation automatique</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>Chaîne de caractères de longueur variable</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>Heure du jour</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>Heure du jour, avec fuseau horaire</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry><type>timestamp</type></entry>
       <entry>Date et heure</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>Date et heure, avec fuseau horaire</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <title>Compatibilité</title>
   <para>
    Les types suivants sont conformes à la norme <acronym>SQL</acronym>:
    <type>bit</type>, <type>bit varying</type>, <type>boolean</type>, 
    <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (avec et sans fuseau horaire),
    <type>timestamp</type> (avec et sans fuseau horaire).
   </para>
  </note>

  <para>
   Chaque type de données a une représentation externe déterminée par
   ses fonctions d'entrée et de sortie. De nombreux type de données
   internes ont un format externe évident. Cependant, certains types
   sont soit spécifiques à <productname>PostgreSQL</productname>,
   comme les chemins ouverts et fermés, ou ont différents formats 
   possibles, comme les types de données de date et d'heure.
   Certaines fonctions d'entrée et de sortie ne sont pas inversables:
   Le résultat de la fonction de sortie peut perdre de la précision
   comparé à l'entrée initiale.
  </para>

  <para>
   Certains des opérateurs et des fonctions (comme l'addition et la
   multiplication) n'effectuent pas de vérification d'erreur à 
   l'exécution, pour améliorer la vitesse d'exécution.
   Dans certains systèmes, pour certains types de données, les 
   opérateurs numériques peuvent causer des dépassements de précision
   sans afficher erreur.
  </para>

  <sect1 id="datatype-numeric">
   <title>Types numériques</title>

   <indexterm zone="datatype-numeric">
    <primary>Type de données</primary>
    <secondary>numeric</secondary>
   </indexterm>

   <para>
    Les types numériques sont constitués d'entiers de 2, 4 ou 8 octets,
    de nombre à virgule flottante de 4 ou 8 octets, et de décimaux à
    précision fixe.
</para>

    <table id="datatype-numeric-table">
     <title>Types numériques</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Étendue</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</></entry>
        <entry>2 octets</entry>
        <entry>entier de faible étendue</entry>
        <entry>-32768 à +32767</entry>
       </row>
       <row>
       <entry><type>integer</></entry>
        <entry>4 octets</entry>
        <entry>entiers les plus courants</entry>
        <entry>-2147483648 à +2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</></entry>
        <entry>8 octets</entry>
        <entry>grands entiers</entry>
        <entry>-9223372036854775808 à 9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</></entry>
        <entry>variable</entry>
        <entry>Précision indiquée par l'utilisateur. Valeurs exactes</entry>
        <entry>pas de limite</entry>
       </row>
       <row>
        <entry><type>numeric</></entry>
        <entry>variable</entry>
        <entry>Précision indiquée par l'utilisateur. Valeurs exactes</entry>
        <entry>pas de limite</entry>
       </row>

       <row>
        <entry><type>real</></entry>
        <entry>4 octets</entry>
        <entry>Précision variable. Valeurs inexactes</entry>
        <entry>précision de 6 décimales</entry>
       </row>
       <row>
        <entry><type>double precision</></entry>
        <entry>8 octets</entry>
        <entry>Précision variable. Valeurs inexactes</entry>
        <entry>précision de 15 décimales</entry>
       </row>

       <row>
        <entry><type>serial</></entry>
        <entry>4 octets</entry>
        <entry>entier à incrémentation automatique</entry>
        <entry>1 à 2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
        <entry>8 octets</entry>
        <entry>entier de grande taille à incrémentation automatique</entry>
        <entry>1 à 9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    La syntaxe des constantes pour les types numériques est décrite
    dans <xref linkend="sql-syntax-constants">. Les types numériques
    ont un ensemble complet d'opérateurs arithmétiques et de fonctions.
    Référez vous à <xref linkend="functions"> pour plus d'informations.
    Les sections suivantes décrivent ces types en détail.
   </para>

   <sect2 id="datatype-int">
    <title>Types entiers</title>

    <indexterm zone="datatype-int">
     <primary>integer</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>

    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

    <para>
     Les types <type>smallint</type>, <type>integer</type>, et
     <type>bigint</type> stockent des nombres entiers, c'est à dire
     sans décimale, de différentes étendues.
     Toute tentative d'y stocker une valeur trop grande ou trop petite
     produite une erreur.
    </para>

    <para>
     Le type <type>integer</type> est le plus courant. Il offre un
     bon compromis entre capacité, espace utilisé et performances.
     Le type <type>smallint</type> n'est utilisé que si l'économie
     d'espace disque est le premier critère de choix.
     Le type <type>bigint</type> ne doit être utilisé que si le 
     type <type>integer</type> n'offre pas une étendue suffisante,
     car le type <type>integer</type> est nettement plus rapide.
    </para>

    <para>
     Le type <type>bigint</type> peut ne pas fonctionner correctement
     sur toutes les plates-formes, car il repose sur la capacité du
     compilateur à supporter les entiers de 8 octets.
     Sur une machine qui ne les supporte pas, <type>bigint</type> se
     comporte comme <type>integer</type> (mais prend bien huit octets
     d'espace de stockage). Ceci dit, nous ne connaissons pas de
     plate-forme raisonnable sur laquelle il en va ainsi.
    </para>

    <para>
     <acronym>SQL</acronym> ne spécifie que les types de données 
     <type>integer</type> (ou <type>int</type>) et
     <type>smallint</type>.  Le type <type>bigint</type>, et les noms
     de types <type>int2</type>, <type>int4</type>, et
     <type>int8</type> sont des extensions, qui sont partagées avec
     d'autres systèmes de bases de données <acronym>SQL</acronym>.
    </para>

    <note>
     <para>
      Si vous avez une colonne de type <type>smallint</type> ou
      <type>bigint</type> avec un index, vous pourrez rencontrer des 
      problèmes pour que le système utilise cet index. Par exemple, 
      une clause de la forme
<programlisting>
... WHERE smallint_column = 42
</programlisting>
      n'utilisera pas l'index, parce que le système assigne le type
      <type>integer</type> à la constante 42, et 
      <productname>PostgreSQL</productname> ne sait pour l'instant
      pas utiliser un index lorsque deux types de données différents
      sont utilisés. Un contournement est d'entourer la constante
      entre apostrophes, comme:
<programlisting>
... WHERE smallint_column = '42'
</programlisting>
      Cela forcera le système à retarder la résolution de type, ce
      qui permettra d'assigner le bon type à la constante.
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <title>Nombre à précision arbitraire</title>

    <indexterm zone="datatype-numeric-decimal">
     <primary>numeric (data type)</primary>
    </indexterm>

    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>

    <para>
     Le type <type>numeric</type> peut stocker des nombres avec 
     jusqu'à 1000 chiffres significatifs et effectuer des calculs
     exacts. Il est spécialement recommander pour stocker les montants
     financiers et autres quantités pour lesquelles l'exactitude est 
     indispensable. Néanmoins, le type <type>numeric</type> est très
     lent comparé aux types à virgule flottante décrits dans la
     section suivante.
    </para>

    <para>
     Dans ce qui suit, on utilise les termes suivants: 
     L'<firstterm>échelle</firstterm> d'un <type>numeric</type> est le
     nombre de chiffres décimaux de la partie fractionnaire. La 
     <firstterm>précision</firstterm> d'un <type>numeric</type> est le
     nombre total de chiffres significatifs dans le nombre entier, 
     c'est à dire avant et après la virgule. Donc, le nombre 23,5141
     a une précision de 6 et une échelle de 4. On peut considérer que 
     les entiers ont une échelle de 0.
   </para>

    <para>
     La précision et l'échelle d'un numérique peuvent être réglés.
     Pour déclarer une colonne de type numérique, il faut utiliser la
     syntaxe.
<programlisting>
NUMERIC(<replaceable>précision</replaceable>, <replaceable>échelle</replaceable>)
</programlisting>
     La précision pour être strictement positive, l'échelle positive
     ou nulle.
     Alternativement, 
<programlisting>
NUMERIC(<replaceable>précision</replaceable>)
</programlisting>
     indique une échelle de 0.  Préciser
<programlisting>
NUMERIC
</programlisting>
     sans précision ni échelle crée une colonne dans laquelle on
     peut stocker des valeurs de n'importe quelle précision ou
     échelle, jusqu'à la limite de précision. Une colonne de ce type
     ne forcera aucune valeur entrée à une précision particulière,
     alors que les colonnes <type>numeric</type> avec une échelle 
     forcent les valeurs entrées à cette échelle. (Le standard 
     <acronym>SQL</acronym> demande une précision par défaut de 0, 
     c'est à dire de forcer la transformation en entiers. Nous
     trouvons ça inutile. Si vous êtes soucieux de portabilité, 
     précisez toujours la précision et l'échelle explicitement.)
    </para>

    <para>
     Si la précision ou l'échelle d'une valeur sont supérieures à la
     précision ou à l'échelle d'une colonne, le système tentera 
     d'arrondir la valeur. Si la valeur ne peut être arrondie d'une
     manière qui corresponde aux limites déclarées, alors une erreur
     est produite.
    </para>

    <para>
     Les types <type>decimal</type> et <type>numeric</type> sont 
     équivalents. Les deux types sont dans le standard 
     <acronym>SQL</acronym>.
    </para>
   </sect2>


   <sect2 id="datatype-float">
    <title>Types à virgule flottante</title>

    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>double precision</primary>
    </indexterm>

    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>floating point</primary>
    </indexterm>

    <para>
     Les types de données <type>real</type> et <type>double
     precision</type> sont des types numériques à précision variable
     inexacts. En pratique, ils sont généralement conformes à la norme
     <acronym>IEEE</acronym> 754 pour l'arithmétique binaire à 
     virgule flottante (respectivement simple et double précision), 
     dans la mesure où les processeurs, le système d'exploitation et
     le compilateur les supportent.
    </para>

    <para>
     Inexact signifie que certaines valeurs ne peuvent être converties
     exactement dans le format interne, et sont stockées sous forme
     d'approximations, si bien que stocker puis réafficher ces valeurs
     peut faire apparaître de légers écarts.
     Prendre en compte ces erreurs et la façon dont elles se propagent
     au cours des calculs est le sujet d'une branche entière des
     mathématiques et de l'informatique. Nous n'en dirons pas plus que 
     ce qui suit:
     <itemizedlist>
      <listitem>
       <para>
        Si vous avez besoin d'un stockage et de calculs exacts, comme
        pour les valeurs monétaires, utilisez plutôt le type
        <type>numeric</type>.
      </para>
      </listitem>

      <listitem>
       <para>
        Si vous voulez faire des calculs compliqués avec ces types 
        pour quoi que ce soit d'important, et particulièrement si
        vous comptez sur certains comportements aux limites (infinis, 
        zéro), alors vous devriez étudier le comportement de votre
        plate-forme avec soin.
       </para>
      </listitem>

      <listitem>
       <para>
        Tester l'égalité de deux valeurs à virgule flottante peux ne
        pas donner le résultat attendu.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Sur la plupart des plates-formes, le type <type>real</type> a une
     étendue d'au moins 1E-37 à 1E37 avec une précision d'au moins
     6 chiffres décimaux. Le type <type>double precision</type> a
     généralement une étendue de 1E-307 à 1E+308 avec une précision
     d'au moins 15 chiffres. Les valeurs trop grandes ou trop petites 
     produisent une erreur. Un arrondi peut avoir lieu si la précision
     d'un nombre en entrée est trop grande. Les nombres trop proches
     de zéro qui ne peuvent être représentés autrement que par zéro
     produisent une erreur (underflow).
    </para>

    <para>
     <productname>PostgreSQL</productname> autorise aussi la notation
     <type>float</type> du standard SQL, ainsi que 
     <type>float(<replaceable>p</replaceable>)</type> pour indiquer
     des types numériques inexacts. Ici, <replaceable>p</replaceable>
     indique la précision minimale acceptable en chiffres binaires.
     <productname>PostgreSQL</productname> accepte 
     <type>float(1)</type> à <type>float(24)</type>, transformés en
     type <type>real</type> et 
     <type>float(25)</type> to <type>float(53)</type>, transformés en
     type <type>double precision</type>. Toute valeur de 
     <replaceable>p</replaceable> hors de la zone de valeurs possible
     produit une erreur. <type>float</type> sans précision est compris
     comme <type>double precision</type>.
    </para>

    <note>
     <para>
      Avant <productname>PostgreSQL</productname> 7.4, la précision 
      d'un <type>float(<replaceable>p</replaceable>)</type> était
      supposée indiquer une précision en chiffres décimaux.
      Nous l'avons corrigée pour respecter le standard SQL, qui 
      indique que la précision est indiquée en chiffres binaires.
      L'affirmation que les <type>real</type> et les 
      <type>double precision</type> ont exactement 24 et 53 bits
      dans la mantisse est correcte pour les implémentations des 
      nombres à virgule flottante respectant le standard IEEE.
      Sur les plates-formes non-IEEE, c'est peut-être un peu sous-estimé,
      mais pour plus de simplicité, la gamme de valeurs pour 
      <replaceable>p</replaceable> est utilisée sur toutes les 
      plates-formes.
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
    <title>Types Série</title>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>

    <indexterm>
     <primary>séquence</primary>
     <secondary>type serial</secondary>
    </indexterm>

    <para>
     Les types de données <type>serial</type> et <type>bigserial</type>
     ne sont pas de vrais types, mais plutôt un raccourci de notation
     pour décrire des colonnes d'identifiants uniques (similaires à la
     propriété <literal>AUTO_INCREMENT</literal> utilisée par d'autres
     SGBD). Dans la version actuelle, indiquer 

<programlisting>
CREATE TABLE <replaceable class="parameter">nom_de_table</replaceable> (
    <replaceable class="parameter">nom_de_colonne</replaceable> SERIAL
);
</programlisting>

     est équivalent à écrire :

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">nom_de_table</replaceable> (
    <replaceable class="parameter">nom_de_colonne</replaceable> integer DEFAULT nextval('<replaceable class="parameter">nom_de_table</replaceable>_<replaceable class="parameter">nom_de_colonne</replaceable>_seq') NOT NULL
);
</programlisting>

     Ainsi, nous avons créé une colonne d'entiers et fait en sorte
     que ses valeurs par défaut soient assignées par un générateur de
     séquence. Une contrainte <literal>NOT NULL</literal> est ajoutée pour
     s'assurer qu'une valeur Nulle ne puisse pas être explicitement 
     insérée. Dans la plupart des cas, vous voudrez aussi ajouter une 
     contrainte <literal>UNIQUE</literal> ou <literal>PRIMARY KEY</literal> pour
     interdire que des doublons soient créés par accident, mais ce
     n'est pas automatique.
    </para>

    <note>
     <para>
      Avant <productname>PostgreSQL</productname> 7.3, 
      <type>serial</type> sous entendait <literal>UNIQUE</literal>.
      Ce n'est plus automatique. Si vous souhaitez qu'une colonne
      serial soit unique ou soit une clé primaire, il faut le préciser,
      comme pour un autre type.
     </para>
    </note>

    <para>
     Pour insérer la valeur suivante de la séquence dans la colonne 
     <type>serial</type>, il faut faire en sorte d'utiliser la valeur 
     par défaut de la colonne.
     Cela peut se faire de deux façons: soit en excluant cette
     colonne de la liste des colonnes de la commande 
     <command>INSERT</command>, ou en utilisant le mot clé
     <literal>DEFAULT</literal>.
    </para>

    <para>
     Les types <type>serial</type> et <type>serial4</type> sont
     identiques: ils créent tous les deux des colonnes 
     <type>integer</type>. Les types <type>bigserial</type> et 
     <type>serial8</type> fonctionnent de la même façon, et créent des
     colonnes <type>bigint</type>. <type>bigserial</type> doit
     être utilisé si vous pensez utiliser plus de 2<superscript>31</superscript>
     identifiants dans toute la vie de la table.
    </para>

    <para>
     La séquence créée pour une colonne <type>serial</type> est 
     automatiquement supprimée quand la colonne correspondante est
     supprimée, et ne peut l'être autrement. (Ce n'était
     pas le cas avant la version 7.3 de 
     <productname>PostgreSQL</productname>. Notez que ce lien de
     suppression automatique de séquence ne fonctionnera pas pour
     une base restaurée d'une sauvegarde SQL (dump) antérieure à la 
     version 7.3. La sauvegarde ne contient en effet pas l'information
     nécessaire à l'établissement du lien de dépendance.)
     De plus, ce lien de dépendance n'est mis que pour la colonne de
     type <type>serial</> elle même. Si d'autres colonnes référencent
     la séquence (par exemple en appellent la fonction 
     <function>nextval</>), elles ne peuvent plus fonctionner si la 
     séquence est supprimée.
     Utiliser le type <type>serial</> de cette façon n'est pas recommandé.
     Si vous souhaitez remplir plusieurs colonnes avec le même générateur de 
     séquence, créez la séquence indépendamment.
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>Types monétaires</title>

   <note>
    <para>
     Le type <type>money</type> est obsolète. Utilisez plutôt les  
     types <type>numeric</type> ou <type>decimal</type>, en 
     combinaison avec la fonction <function>to_char</function>.
    </para>
   </note>

   <para>
    Le type <type>money</type> stocke un montant d'une devise avec
    un nombre fixe de chiffres après la virgule. Voir <xref
    linkend="datatype-money-table">.
    De nombreux formats sont acceptés en entrée, dont les entiers et
    les nombre à virgule flottante ainsi que les formats classiques
    de devises, comme <literal>'$1,000.00'</literal>. 
    Le format de sortie est généralement ce dernier, mais dépend de la
    localisation.
   </para>

    <table id="datatype-money-table">
     <title>Types monétaires</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Étendue</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>money</entry>
        <entry>4 octets</entry>
        <entry>montants de devise</entry>
        <entry>-21474836.48 à +21474836.47</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>


  <sect1 id="datatype-character">
   <title>Types caractères</title>

   <indexterm zone="datatype-character">
    <primary>Chaîne de caractères</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <indexterm>
    <primary>Chaîne</primary>
    <see>Chaîne de caractères</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

    <table id="datatype-character-table">
<title>Types caractères</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type></entry>
        <entry>Longueur variable avec limite</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</>)</type>, <type>char(<replaceable>n</>)</type></entry>
        <entry>longueur fixe, comblé avec des espaces</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
        <entry>longueur variable illimitée</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>
    <xref linkend="datatype-character-table"> montre les types
    génériques disponibles dans <productname>PostgreSQL</productname>.
   </para>

   <para>
    <acronym>SQL</acronym> définit deux types de caractères principaux:
    <type>character varying(<replaceable>n</>)</type> et
    <type>character(<replaceable>n</>)</type>, où <replaceable>n</>
    est un entier positif.
    Ces deux types peuvent stocker des chaînes de caractères de taille
    inférieure ou égale à <replaceable>n</replaceable>. Une tentative d'insérer
    une chaîne trop longue donnera une erreur, à moins que les 
    caractères en trop soient tous des espaces, auquel cas la chaîne 
    sera tronquée à la taille maximale. (Cette exception un rien 
    étrange est imposée par la norme <acronym>SQL</acronym>).
    Si la chaîne à stocker est plus petite que la taille déclarée,
    elle sera complétée par des espaces pour le type 
    <type>character</type>, et elle sera stockée telle quelle pour le 
    type <type>character varying</type>.
   </para>

    <para>
     Si vous transtypez (cast) explicitement une valeur en 
     <type>character varying(<replaceable>n</replaceable>)</type> ou en
     <type>character(<replaceable>n</replaceable>)</type>, alors une chaîne trop
     longue sera tronquée à <replaceable>n</replaceable> caractères sans que
     cela génère d'erreur. (Ce comportement est aussi imposé par
     la norme <acronym>SQL</acronym>.)
    </para>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.2, les chaînes trop longues
     étaient toujours tronquées sans générer d'erreur, que ce soit
     par une transformation explicite ou implicite.
    </para>
   </note>

   <para>
    Les notations <type>varchar(<replaceable>n</replaceable>)</type> et
    <type>char(<replaceable>n</replaceable>)</type> sont des alias pour
    <type>character varying(<replaceable>n</replaceable>)</type> et
    <type>character(<replaceable>n</replaceable>)</type>, respectivement.
    <type>character</type> sans indication de taille est équivalent à
    <type>character(1)</type>. Si <type>character varying</type> est
    utilisé sans indicateur de taille, le type accepte des chaînes de
    toutes tailles. Il s'agit là d'une spécificité de 
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    <productname>PostgreSQL</productname> propose aussi le type
    <type>text</type>, qui permet de stocker des chaînes de n'importe
    quelle taille. Bien que le type <type>text</type> ne soit pas
    dans le standard <acronym>SQL</acronym>, plusieurs autres systèmes de
    gestion de bases de données SQL le proposent aussi.
   </para>

   <para>
    L'espace de stockage utilisé pour les données de ces types est
    de 4 octets en plus de la taille de la chaîne, plus le remplissage
    dans le cas du type <type>character</type>.
    Les grandes chaînes sont automatiquement compressées par le 
    système, si bien que l'espace effectivement utilisé peut être
    inférieur. Les grandes chaînes sont aussi stockées dans des tables
    d'arrière plan, afin de ne pas ralentir l'accès aux autres
    colonnes plus petites.
    Dans tous les cas, la taille maximale possible pour une chaîne de 
    caractères est de l'ordre 1 Go. (La taille maximale pour 
    <replaceable>n</replaceable> dans la déclaration de type est plus petite
    que cela. Il ne serait pas très utile de le changer parce qu'avec 
    l'encodage des caractères sur plusieurs octets, le nombre de caractères
    et d'octets peuvent être très différents. Si vous voulez stocker
    de longues chaînes sans limite de taille spécifique, utilisez le type 
    <type>text</type> ou le type <type>character varying</type> sans indiquer
    de taille, plutôt que d'indiquer une limite de taille arbitraire.)
   </para>

   <tip>
    <para>
     Il n'y a pas de différence de performance entre ces trois types,
     à part la place disque supplémentaire pour le type qui remplit les
     vides avec des espaces.
    </para>
   </tip>

   <para>
    Voyez <xref linkend="sql-syntax-strings"> pour avoir plus d'informations
    sur la syntaxe des littéraux de chaînes, et <xref linkend="functions">
    pour avoir des informations sur les opérateurs et les fonctions.
   </para>

   <example>
    <title>Utilisation des types caractères</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char">
<computeroutput>
  a   | char_length
------+-------------
 ok   |           4
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('bien      ');
INSERT INTO test2 VALUES ('trop long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('trop long'::varchar(5)); -- troncature explicite
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 bien  |           5
 trop  |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
       La fonction <function>char_length</function> est décrite dans
       <xref linkend="functions-string">.
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
    Il y a deux autres types caractères de taille constante dans
    <productname>PostgreSQL</productname>, décrits dans <xref
    linkend="datatype-character-special-table">. Le type <type>name</type>
    existe <emphasis>seulement</emphasis> pour le stockage des identifiants
    dans les catalogues systèmes, et n'est pas destiné à être utilisé par
    les utilisateurs normaux. Sa taille est actuellement définie à 64 octets 
    (63 utilisables plus le terminateur), mais doit être référencée en
    utilisant la constante <symbol>NAMEDATALEN</symbol>. La taille est
    définie à la compilation (et est donc ajustable pour des besoins 
    particuliers). La taille maximale par défaut pourrait changer dans une
    prochaine version. Le type <type>"char"</type> (notez les guillemets)
    est différent de <type>char(1)</type> car il n'utilise qu'un seul octet 
    de stockage. Il est utilisé dans les catalogues systèmes comme un type 
    d'énumération économique.
   </para>

    <table id="datatype-character-special-table">
     <title>Types caractères spéciaux</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 octet</entry>
        <entry>type interne de 1 caractère</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <entry>64 octets</entry>
        <entry>type interne pour les noms d'objets</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>Types de données binaires</title>

  <indexterm zone="datatype-binary">
   <primary>binary data</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>
   <para>
    Le type de données <type>bytea</type> permet de stocker des chaînes
    binaires; voir <xref linkend="datatype-binary-table">.
   </para>

   <table id="datatype-binary-table">
    <title>Types de données binaires</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Espace de stockage</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>4 octets plus la taille de la chaîne binaire à stocker</entry>
       <entry>Chaîne binaire de longueur variable</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Une chaîne binaire est une séquence d'octets. Les chaînes binaires
    se distinguent des chaînes de caractères par deux caractéristiques:
    D'abord, les chaînes binaires permettent de stocker des octets de
    valeurs zéro, et autres caractères <quote>non imprimables</quote> (définis
    comme des octets en dehors de l'échelle de 32 à 126).
    Ensuite, les opérations sur les chaînes binaires les traitent 
    telles quelles, alors que le traitement et l'encodage des chaînes
    de caractères dépend des paramètres de localisation.
   </para>

   <para>
    Lors de la saisie de valeurs de type <type>bytea</type>, certaines valeurs
    d'octets <emphasis>doivent</emphasis> être préparées avec des caractères 
    d'échappement(mais toutes les valeurs <emphasis>peuvent</emphasis> 
    l'être) lorsqu'elles sont font partie d'une chaîne littérale dans une
    commande <acronym>SQL</acronym>. En général, pour échapper un octet,
    il faut le convertir en nombre octal sur 3 caractères, précédés par deux
    antislashs. <xref linkend="datatype-binary-sqlesc"> contient les
    caractères qui doivent être échappés, et donne les séquences 
    d'échappement possibles.
   </para>

   <table id="datatype-binary-sqlesc">
    <title><type>bytea</> Octets littéraux à échapper</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Valeur décimale de l'octet</entry>
       <entry>Description</entry>
       <entry>Représentation échappée d'entrée</entry>
       <entry>Exemple</entry>
       <entry>Représentation de sortie</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>octet zéro</entry>
       <entry><literal>'\\000'</literal></entry>
       <entry><literal>SELECT '\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>apostrophe</entry>
       <entry><literal>'\''</literal> ou <literal>'\\047'</literal></entry>
       <entry><literal>SELECT '\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>antislash</entry>
       <entry><literal>'\\\\'</literal> ou <literal>'\\134'</literal></entry>
       <entry><literal>SELECT '\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>de 0 à 31 et de 127 à 255</entry>
       <entry>octets <quote>non affichables</quote></entry>
       <entry><literal>'\\<replaceable>xxx'</></literal> (valeur octal)</entry>
       <entry><literal>SELECT '\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    La nécessité d'échapper les octets <quote>non affichables</quote> varie en
    fait suivant les paramétrages de la locale. Quelques fois, vous pouvez
    vous en sortir sans les échapper. Notez que le résultat de chacun des
    exemples de <xref linkend="datatype-binary-sqlesc"> était d'une longueur
    exacte d'un octet, même si la représentation en sortie de l'octet zéro et
    de l'antislash font plus d'un caractère.
   </para>

   <para>
    La raison pour laquelle il faut écrire autant de antislashs, comme
    indiqué dans <xref linkend="datatype-binary-sqlesc">, est qu'une
    chaîne binaire doit passer à travers deux phases d'analyse dans le
    serveur <productname>PostgreSQL</productname>. Le premier antislash
    de chaque paire est vu comme un caractère d'échappement par
    l'analyseur de littéral chaîne et est donc consommé,
    laissant le second antislash de la paire. Le antislash restant est
    compris par la fonction d'entrée de <productname>PostgreSQL</productname>
    comme le début d'une valeur octale sur trois caractères, ou comme
    l'échappement d'un autre antislash.
    Par exemple, un littéral de chaînes passé au serveur comme
    <literal>'\\001'</literal> devient <literal>\001</literal> après
    être passé à travers l'analyseur de littéral chaîne.
    Le <literal>\001</literal> est envoyé à la fonction d'entrée de
    <type>bytea</type>, qui le convertit en un octet simple ayant une valeur
    décimale de 1. Notez que le caractère apostrophe n'est pas traité
    spécialement par <type>bytea</type>, et suit donc les règles normales
    pour les littéraux de chaîne. Voir aussi <xref linkend="sql-syntax-strings">.)
   </para>

   <para>
   Les octets de <type>Bytea</type> sont aussi échappés en sortie. En général,
   chaque octet <quote>non-imprimable</quote> est converti en équivalent
   octal sur trois caractères et précédé d'un antislash.
   La plupart des caractères <quote>imprimables</quote> sont représentés 
   par leur représentation standard dans le jeu de caractère du client.
   Les octets de valeur décimale 92 (antislash) ont une représentation
   alternative spéciale. Les détails sont dans 
   <xref linkend="datatype-binary-resesc">.
   </para>

   <table id="datatype-binary-resesc">
    <title><type>bytea</> Octets échappés en sortie</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Valeur décimale de l'octet</entry>
       <entry>Description</entry>
       <entry>Représentation de sortie échappée</entry>
       <entry>Exemple</entry>
       <entry>Résultat de sortie</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>antislash</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT '\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 à 31 et 127 à 255</entry>
       <entry>octets<quote>non-imprimables</quote></entry>
       <entry><literal>\<replaceable>xxx</></literal> (valeur octale)</entry>
       <entry><literal>SELECT '\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32 à 126</entry>
       <entry>octets <quote>imprimables</quote></entry>
       <entry>Représentation de l'ensemble de caractères du client</entry>
       <entry><literal>SELECT '\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    En fonction du client que vous utilisez pour accéder à
    <productname>PostgreSQL</>, vous pouvez avoir un travail d'échappement
    supplémentaire à effectuer pour échapper et déséchapper les
    chaînes <type>bytea</type>. Par exemple, il se peut que vous deviez 
    échapper les sauts de lignes et retours à la ligne si votre programme
    client les traduit automatiquement.
   </para>

   <para>
    Le standard <acronym>SQL</acronym> définit un type binaire différent,
    appelé <type>BLOB</type> ou <type>BINARY LARGE OBJECT</type>. 
    Le format d'entrée est différent de celui du <type>bytea</type>, mais les
    fonctions et opérateurs fournis sont globalement les mêmes.
   </para>
 </sect1>


  <sect1 id="datatype-datetime">
   <title>Types date/heure</title>

   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time without time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time with time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp with time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp without time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>interval</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time span</primary>
   </indexterm>
   <para>
<productname>PostgreSQL</productname> supporte l'ensemble des types date 
    et heure de <acronym>SQL</acronym>, montrés dans <xref
    linkend="datatype-datetime-table">.
   </para>

    <table id="datatype-datetime-table">
     <title>Types date et heure</title>
     <tgroup cols="6">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
        <entry>Valeur minimale</entry>
        <entry>Valeur maximale</entry>
        <entry>Résolution</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 octets</entry>
        <entry>date et heure</entry>
        <entry>4713 avant JC</entry>
        <entry>5874897 après JC</entry>
        <entry>1 microseconde / 14 chiffres</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8 octets</entry>
        <entry>date et heure, avec fuseau horaire</entry>
        <entry>4713 avant JC</entry>
        <entry>5874897 après JC</entry>
        <entry>1 microseconde / 14 chiffres</entry>
       </row>
       <row>
        <entry><type>interval [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>12 octets</entry>
        <entry>intervals de temps</entry>
        <entry>-178000000 années</entry>
        <entry>178000000 années</entry>
        <entry>1 microseconde</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>4 octets</entry>
        <entry>dates seulement</entry>
        <entry>4713 avant JC</entry>
        <entry>32767 après JC</entry>
        <entry>1 jour</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 octets</entry>
        <entry>heures seulement</entry>
        <entry>00:00:00.00</entry>
        <entry>23:59:59.99</entry>
        <entry>1 microseconde</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12 octets</entry>
        <entry>heures seulement, avec fuseau horaire</entry>
        <entry>00:00:00.00+12</entry>
        <entry>23:59:59.99-12</entry>
        <entry>1 microseconde</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.3, écrire seulement
     <type>timestamp</type> était équivalent à <type>timestamp with
     time zone</type>. Ceci a été changé pour une meilleure compatibilité avec
     le standard SQL.
    </para>
   </note>

   <para>
    <type>time</type>, <type>timestamp</type>, et
    <type>interval</type> acceptent une précision optionnelle
    <replaceable>p</replaceable>, qui précise le nombre de chiffres
    après la virgule pour les secondes. Par défaut, il n'y a pas de 
    limite explicite à la précision. Les valeurs acceptées pour
    <replaceable>p</replaceable> vont de 0 à 6 pour les types
    <type>timestamp</type> et <type>interval</type>.
   </para>

   <note>
   <para>
    When <type>timestamp</> values are stored as double precision floating-point
    numbers (currently the default), the effective limit of precision
    may be less than 6. <type>timestamp</type> values are stored as seconds
    before or after midnight 2000-01-01.  Microsecond precision is achieved for
    dates within a few years of 2000-01-01, but the precision degrades for
    dates further away.  When <type>timestamp</type> values are stored as
    eight-byte integers (a compile-time
    option), microsecond precision is available over the full range of
    values. However eight-byte integer timestamps have a more limited range of
    dates than shown above: from 4713 BC up to 294276 AD.
   </para>
   </note>
   
   <note>
   <para>
    Lorsque les valeurs de type <type>timestamp</> sont stockées comme des 
    nombres à virgule flottante de précision double (ce qui est le cas par
    défaut), la limite de précision effective peut être inférieure à 6.
    Les valeurs de <type>timestamp</> sont stockées comme des secondes depuis
    le avant ou après minuit le 1er janvier 2001. La précision de la
    milliseconde est atteinte pour quelques années autour de cette date mais
    la précision se dégrade si on s'en éloigne. Lorsque les valeurs de
    <type>timestamp</> sont stockés comme des entiers sur 8 octets, ce qui
    est une option à la compilation, la précision de la microseconde est 
    disponible sur tout l'intervalle des valeurs. Néanmoins, cet intervalle est
    encore plus limité&nbsp:: de 4713 avant Jésus Christ à 294276 après Jésus
    Christ.
   </para>
   </note>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.3, indiquer juste
     <type>timestamp</type> était équivalent à <type>timestamp with
     time zone</type>. Ce comportement a été changé en respect du standard SQL.
    </para>
   </note>

   <para>
    Pour les types <type>time</type>, l'intervalle accepté pour
    <replaceable>p</replaceable> est de 0 à 6 lorsque les entiers sur
    8 octets sont utilisés, ou de 0 à 10 lorsque le stockage se fait sous
    forme de nombre à virgule flottante.
   </para>

   <para>
    Le type <type>time with time zone</type> est défini dans le standard
    SQL, mais sa définition lui prête des propriétés qui font douter de son
    utilité. Dans la plupart des cas, une combinaison de <type>date</type>,
    <type>time</type>, <type>timestamp without time zone</type>, et 
    <type>timestamp with time zone</type> devrait permettre de résoudre
    toutes les fonctionnalités de date et heure nécessaires à une application.
   </para>

   <para>
    Les types <type>abstime</type> et <type>reltime</type> sont des types de
    précision moindre, utilisés en interne. Il n'est pas recommandé de les
    utiliser dans de nouvelles applications. Au contraire, il est souhaitable
    de migrer l'existant vers un autre type approprié.
    Ces types internes pourraient disparaître dans une future version.
   </para>

   <sect2 id="datatype-datetime-input">
    <title>Entrée des dates et heures</title>

    <para>
     La saisie de dates et heures et possible dans la plupart des formats
     raisonnables, dont ISO8601, compatible <acronym>SQL</acronym>, traditionnel
     <productname>POSTGRES</productname>, et d'autres.
     Pour certains formats, l'ordre des jours, mois et années en entrée est ambigu.
     Il est alors possible de préciser l'ordre attendu pour ces champs.
     Réglez le paramètre <varname>datestyle</varname> à <literal>MDY</literal> pour choisir
     une interprétation mois-jour-année, à <literal>DMY</literal> pour jour-mois-année,
     à <literal>YMD</literal> pour année-mois-jour.
    </para>

    <para>
     <productname>PostgreSQL</productname> est plus flexible que la norme 
     <acronym>SQL</acronym> ne l'exige pour la manipulation des dates et
     des heures. Voir <xref linkend="datetime-appendix"> pour connaître
     les règles exactes de reconnaissance des dates et heures,
     ainsi que les formats de champs texte comme les mois, les jours de la
     semaine et les fuseaux horaires.
    </para>

    <para>
     Rappelez vous que chaque littéral date ou heure à entrer doit être mis
     entre apostrophes, comme les chaînes de caractères.
     Référez vous à <xref linkend="sql-syntax-constants-generic"> pour
     plus d'information.
     <acronym>SQL</acronym> requière la syntaxe suivante:
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     où <replaceable>p</replaceable> dans la spécification optionnelle de
     précision est un entier correspondant au nombre de chiffres après la virgule
     dans le champ secondes.
     La précision peut être précisée pour les types <type>time</type>,
<type>timestamp</type>, et <type>interval</type>.
     Les valeurs admissibles sont mentionnées plus haut. Si aucune précision
     n'est indiquée dans une spécification de constante, elle prend la
     précision de la valeur littérale.
    </para>

    <sect3>
    <title>Dates</title>

    <indexterm>
     <primary>date</primary>
    </indexterm>
 
    <para>
     <xref linkend="datatype-datetime-date-table"> montre les formats
     de date possibles pour les entrées de type <type>date</type>.
    </para>

     <table id="datatype-datetime-date-table">
      <title>Saisie de date</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Exemple</entry>
         <entry>Description</entry>
        </row>
           </thead>
           <tbody>
        <row>
         <entry>January 8, 1999</entry>
         <entry>sans ambiguïté quel que soit le style de date 
         (<varname>datestyle</varname>)</entry>
        </row>
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO-8601; 8 janvier, quel que soit le mode
         (format recommandé)</entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <entry>8 janvier en mode MDY<literal>MDY</>;
1er Août en mode <literal>DMY</></entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <entry>18 janvier en mode <literal>MDY</>;
      rejeté dans les autres modes</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <entry>2 janvier 2003 en mode <literal>MDY</>;
          1er février 2003 en mode <literal>DMY</>;
          3 février 2003 en mode <literal>YMD</>
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <entry>8 janvier dans tous les modes</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <entry>8 janvier en mode <literal>YMD</>, erreur sinon</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <entry>8 janvier, sauf en mode <literal>YMD</>: erreur</entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <entry>8 janvier, sauf en mode <literal>YMD</>: erreur</entry>
        </row>
        <row>
         <entry>19990108</entry>
         <entry>ISO-8601; 8 janvier 1999 dans tous les modes</entry>
        </row>
        <row>
         <entry>990108</entry>
         <entry>ISO-8601; 8 janvier 1999 dans tous les modes</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <entry>Année et jour dans l'année</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <entry>Jour du calendrier Julien</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>année 99 avant Jésus Christ</entry>
        </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>

    <sect3>
     <title>Heures</title>

     <indexterm>
      <primary>heure</primary>
     </indexterm>
     <indexterm>
      <primary>heure sans fuseau horaire</primary>
     </indexterm>
     <indexterm>
      <primary>heure avec fuseau horaire</primary>
     </indexterm>

     <para>
      Les types heure-du-jour sont <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> et
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>. Écrire juste <type>time</type> est équivalent à
      <type>time without time zone</type>
     </para>

     <para>
      Les valeurs d'entrée valides pour ces types sont constituées d'une heure
      du jour suivi d'un fuseau horaire optionnel. (voir <xref
      linkend="datatype-datetime-time-table"> 
      et <xref linkend="datatype-timezone-table">.) Si un fuseau est précisé
      pour le type <type>time without time zone</type>, il est ignoré sans
      message d'erreur.
     </para>

      <table id="datatype-datetime-time-table">
       <title>Saisie d'heure</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Exemple</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>Identique à 04:05; AM n'affecte pas la valeur</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>Identique à 16:05; l'heure doit être <= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>fuseau horaire précisé en lettres</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <title>Saisie des zones de date</title>
       <tgroup cols="2">
        <thead>

         <row>
          <entry>Exemple</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>PST</entry>

          <entry>Heure standard du Pacifique (Pacific Standard Time)</entry>
         </row>
         <row>
          <entry>-8:00</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry>-800</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry>-8</entry>
          <entry>Décalage ISO-8601 pour la zone PST</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>Abréviation des militaires pour GMT</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <entry>Version courte de <literal>zulu</literal></entry>
         </row>
        </tbody>
       </tgroup>
      </table>
    </sect3>

    <sect3>
    <title>Horodatages (time stamps)</title>

    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

     <para>
      Les valeurs d'entrée valides sont constituées par la concaténation
      d'une date, d'une heure, d'un qualificatif optionnel 
      <literal>AD</literal> (avant Jésus Christ) ou <literal>BC</literal> 
      (après Jésus Christ), et d'un fuseau horaire optionnel. Ainsi:

<programlisting>
1999-01-08 04:05:06
</programlisting>
      et
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      sont des valeurs valides, qui suivent le standard 
      <acronym>ISO</acronym> 8601. De plus, le format

<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      très courant, est supporté.
     </para>

     <para>
      Pour <type>timestamp [without time zone]</type>, un fuseau horaire
      explicite est ignoré sans message. C'est à dire que la date/heure
      résultante n'est pas ajustée pour le fuseau horaire.
     </para>

     <para>
      Pour <type>timestamp with time zone</type>, la valeur stockée en interne
      est toujours en UTC (Temps Universel Coordonné), aussi
      connu sous le nom de <acronym>GMT</acronym>.
      Les valeurs d'entrée qui ont un fuseau horaire explicite sont converties
      en UTC en utilisant le décalage approprié. Si aucun fuseau horaire
      n'est précisé, alors le système considère que la date est dans le fuseau
      horaire indiqué par le paramètre système <varname>timezone</varname>, et la
      convertit en UTC en utilisant le décalage de la zone 
      <varname>timezone</varname>.
     </para>

     <para>
      Quand une valeur <type>timestamp with time zone</type> est affichée, 
      elle est toujours convertie de UTC vers le fuseau horaire courant
      (variable <varname>timezone</varname>), et affichée comme une heure locale de
      cette zone.
      Pour voir l'heure dans un autre fuseau horaire, il faut soit changer la
      valeur de <varname>timezone</varname> ou utiliser la construction
      <literal>AT TIME ZONE</literal> (voir <xref
      linkend="functions-datetime-zoneconvert">).
     </para>

     <para>
      Les conversions entre <type>timestamp without time zone</type> et
      <type>timestamp with time zone</type> considèrent normalement
      que la valeur <type>timestamp without time zone</type> utilise
      le fuseau horaire <varname>timezone</varname>. Une zone différente
      peut être choisie en utilisant <literal>AT TIME ZONE</literal>.
     </para>
    </sect3>

    <sect3>
     <title>Intervalles</title>

     <indexterm>
      <primary>interval</primary>
     </indexterm>

      <para>
       Les valeurs de type <type>interval</type> utilisent la syntaxe suivante:

<programlisting>
<optional>@</> <replaceable>quantité</> <replaceable>unité</> <optional><replaceable>quantité</> <replaceable>unité</>...</> <optional><replaceable>direction</></optional>
</programlisting>

      Où: <replaceable>quantité</replaceable> est un nombre (éventuellement signé);
      <replaceable>unité</replaceable> est <literal>second</literal>,
      <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
      <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
      <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
ou des abréviations ou des pluriels de ces unités;
      <replaceable>direction</replaceable> peut être <literal>ago</literal> ou
      vide.  L'arobase (<literal>@</literal>) est du bruit optionnel. Les valeurs
      des différentes unités sont implicitement ajoutées en utilisant le signe
      approprié.
     </para>

     <para>
      Les quantités de jours, heures, minutes et secondes peuvent être précisées
      sans unité explicite. Par exemple <literal>'1 12:59:10'</literal> est lu comme
      <literal>'1 day 12 hours 59 min 10 sec'</literal> (1 jour, 12 heures,
      59 minutes, 10 secondes).
     </para>

     <para>
      La précision optionnelle doit être entre 0 et 6, et prend la précision
      du littéral comme valeur par défaut.
     </para>
    </sect3>

    <sect3>
     <title>Valeurs spéciales</title>

     <indexterm>
      <primary>heure</primary>
      <secondary>constantes</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>constantes</secondary>
     </indexterm>

     <para>
      Les fonctions suivantes, compatibles <acronym>SQL</acronym>, sont
      utilisables comme des valeurs de date ou d'heure: 
      <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
      <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>, 
      <literal>LOCALTIMESTAMP</literal>.
      Les 4 dernières acceptent une spécification de précision optionnelle.
      (voir aussi <xref linkend="functions-datetime-current">.)
     </para>

     <para>
      <productname>PostgreSQL</productname> supporte aussi plusieurs
      valeurs de dates spéciales, par simplicité, comme montré dans
      <xref linkend="datatype-datetime-special-table">.
      Les valeurs <literal>infinity</literal> et <literal>-infinity</literal>
      ont une représentation spéciale dans le système et seront affichées de 
      la même façon. Les autres sont simplement des facilités de notation
      qui seront converties en dates/heures ordinaires lorsqu'elles seront 
      lues. Toutes ces valeurs sont traitées comme des constantes normales,
      et doivent être écrites entre apostrophes.
     </para>

      <table id="datatype-datetime-special-table">
       <title>Saisie de dates/heures spéciales</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Chaînes entrées</entry>
          <entry>Types valides</entry>
        <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
     
      <entry><literal>epoch</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>1970-01-01 00:00:00+00 (date système zéro d'Unix)</entry>
     </row>
     <row>
      <entry><literal>infinity</literal></entry>
      <entry><type>timestamp</type></entry>
      <entry>plus tard que toutes les autres dates</entry>
     </row>
     <row>
      <entry><literal>-infinity</literal></entry>
      <entry><type>timestamp</type></entry>
      <entry>plus tôt que toutes les autres dates</entry>
     </row>
     <row>
      <entry><literal>now</literal></entry>
      <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
      <entry>heure de début de la transaction courante</entry>
     </row>
     <row>
      <entry><literal>today</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>minuit aujourd'hui</entry>
     </row>
     <row>
      <entry><literal>tomorrow</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>minuit demain</entry>
     </row>
     <row>
      <entry><literal>yesterday</literal></entry>
      <entry><type>date</type>, <type>timestamp</type></entry>
      <entry>minuit hier</entry>
     </row>
     <row>
      <entry><literal>allballs</literal></entry>

     </row>
     <row>
      <entry><literal>allballs</></entry>
      <entry><type>time</type></entry>
      <entry>00:00:00.00 UTC</entry>
     </row>
    </tbody>

       </tgroup>
      </table>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>Affichage des Date/Heure</title>

    <indexterm>
     <primary>date</primary>
     <secondary>format d'affichage</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <indexterm>
     <primary>heure</primary>
     <secondary>format de sortie</secondary>
     <seealso>formatage</seealso>
    </indexterm>

    <para>
     Le format de sortie des types date/heure peut être choisi parmi un des
     quatre formats de date suivants: ISO 8601, <acronym>SQL</acronym> 
     (Ingres), Traditionnel POSTGRES, et Allemand, en utilisant la commande
     <literal>SET datestyle</literal>. Le format par défaut est le format
     <acronym>ISO</acronym>, comme demandé par le standard 
     <acronym>SQL</acronym>. Le nom du format d'affichage <quote>SQL</quote>
     est un accident historique. 
     <xref linkend="datatype-datetime-output-table">  montre des exemples de
     chaque format d'affichage. Le format d'un type <type>date</type> ou
     <type>time</type> est bien sur celui de la partie date ou heure, comme
     montré dans les exemples.
    </para>

     <table id="datatype-datetime-output-table">
      <title>Styles d'affichage de date/heure</title>
      <tgroup cols="3">
       <thead>
        <row>
    
        <entry>Spécification de style</entry>
       <entry>Description</entry>
       <entry>Exemple</entry>
       </row>

       </thead>
       <tbody>
        <row>

         <entry>ISO</entry>
         <entry>standard ISO 8601/SQL</entry>
         <entry>1997-12-17 07:37:16-08</entry>
        </row>
        <row>

         <entry>SQL</entry>
         <entry>style traditionnel</entry>
         <entry>12/17/1997 07:37:16.00 PST</entry>
        </row>
        <row>

     <entry>POSTGRES</entry>
     <entry>style original</entry>
     <entry>Wed Dec 17 07:37:16 1997 PST</entry>
    </row>
    <row>

     <entry>German</entry>
     <entry>style régional</entry>
     <entry>17.12.1997 07:37:16.00 PST</entry>
    </row>

       </tbody>
      </tgroup>
     </table>

    <para>
     Dans les styles <acronym>SQL</acronym> et POSTGRES, les jours
     apparaissent avant le mois si l'ordre des champs DMY a été précisé,
     sinon les mois apparaissent avant les jours.
     (Voir <xref linkend="datatype-datetime-input">  pour savoir comment
     ce paramètre affecte l'interprétation des valeurs entrées.)
     <xref linkend="datatype-datetime-output2-table"> montre un exemple.
    </para>

     <table id="datatype-datetime-output2-table">
      <title>Convention d'ordre des dates</title>
      <tgroup cols="3">
       <thead>
    <row>
     <entry>Réglage de ><varname>datestyle</varname> (style de date)</entry>

     <entry>Ordre d'entrée</entry>
     <entry>Exemple d'affichage</entry>
    </row>

       </thead>
       <tbody>
    <row>

        <entry><literal>SQL, DMY</></entry>
         <entry><replaceable>jour</replaceable>/<replaceable>mois</replaceable>/<replaceable>année</replaceable></entry>
         <entry>17/12/1997 15:37:16.00 CET</entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</></entry>
         <entry><replaceable>mois</replaceable>/<replaceable>jour</replaceable>/<replaceable>année</replaceable></entry>
         <entry>12/17/1997 07:37:16.00 PST</entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</></entry>
         <entry><replaceable>jour</replaceable>/<replaceable>mois</replaceable>/<replaceable>année</replaceable></entry>
         <entry>Wed 17 Dec 07:37:16 1997 PST</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     L'affichage du type <type>interval</type> ressemble au format de saisie,
     sauf que les unités comme <literal>century</literal> ou
     <literal>week</literal> sont converties en années et jours, et que
     <literal>ago</literal> est converti en un signe approprié. En mode ISO,
     l'affichage ressemble à:
<programlisting>
<optional> <replaceable>quantité</> <replaceable>unité</> <optional> ... </> </> <optional> <replaceable>jours</> </> <optional> <replaceable>heures</>:<replaceable>minutes</>:<replaceable>secondes</> </optional>
</programlisting>
    </para>

    <para>
     Les styles de date/heure peuvent être sélectionnés soit en utilisant la
     commande <command>SET datestyle</command>, soit en utilisant le paramètre
     <varname>datestyle</varname> du fichier de configuration
     <filename>postgresql.conf</filename>, soit avec la variable 
     d'environnement <envar>PGDATESTYLE</envar> sur le serveur ou le client.
     La fonction de formatage <function>to_char</function> (voir <xref 
     linkend="functions-formatting">) permet aussi, de manière plus flexible,
     pour formater les affichages de date/heure.
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title>Fuseaux horaires</title>

    <indexterm zone="datatype-timezones">
     <primary>fuseau horaire</primary>
    </indexterm>

   <para>
    Les fuseaux horaires et les conventions d'heures sont influencées
    par des décisions politiques, pas seulement par la géométrie de la terre.
    Les fuseaux horaires se sont un peu standardisés au cours du
    vingtième siècle, mais continuent d'être soumis à des changements
    arbitraires.
    <productname>PostgreSQL</productname> utilise les fonctionnalités de votre
    système d'exploitation pour proposer le support des fuseaux horaires. 
    Souvent, ces systèmes ne contiennent les informations que pour la période
    qui va de 1902 à 2038 (ce qui correspond à l'étendue complète des dates
    système conventionnelles d'Unix).
    <type>timestamp with time zone</type> et <type>time with time
     zone</type> n'utilisent les informations de fuseaux horaires que dans
    cette période, et utilisent l'heure <acronym>UTC</acronym> pour les
    autres dates.
    Mais comme le support des fuseaux horaires est issu de celui du système
    d'exploitation, il peut supporter les heures d'été et autres comportements
    particuliers.
    </para>

    <para>
     <productname>PostgreSQL</productname> se veut compatible avec les
     définitions standard <acronym>SQL</acronym> pour un usage typique.
     Néanmoins, le standard <acronym>SQL</acronym> possède un mélange 
     bizarre de types de date/heure et de possibilités. Deux problèmes 
     sont évidents:

     <itemizedlist>
      <listitem>
       <para>
        Bien que le type  <type>date</type> n'ait pas de fuseau horaire
       associé, le type  <type>heure</type> peut en avoir un.
        Les fuseaux horaires, dans le monde réel, ne peuvent avoir de sens
        qu'associés à une date et à une heure, vu que l'écart peut varier
        avec l'heure d'été.
       </para>
      </listitem>

      <listitem>
       <para>
        Le fuseau horaire par défaut est précisé comme un écart numérique constant
        avec l'<acronym>UTC</>. Il n'est pas possible de s'adapter à l'heure 
        d'été ou d'hiver lorsque l'on fait des calculs arithmétiques qui passent
        les limites de l'heure d'été et l'heure d'hiver.
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     Pour ne pas avoir ces difficultés, nous recommandons d'utiliser des
     types de date/heure qui contiennent à la fois une date et une heure
     lorsque vous utilisez les fuseaux horaires. Nous recommandons de
     <emphasis>ne pas</emphasis> utiliser le type <type>time with
     time zone</type>. Ce type est néanmoins proposé par 
     <productname>PostgreSQL</productname> pour les applications
     existantes et pour assurer la compatibilité avec les autres
     bases de données compatibles <acronym>SQL</acronym>. 
     <productname>PostgreSQL</productname> utilise votre fuseau horaire
     pour tous les types qui ne contiennent qu'une date ou une heure.
    </para>

    <para>
     Toutes les dates et heures sont stockées en interne en 
     <acronym>UTC</acronym>. Les heures sont converties en heure
     locale sur le serveur de bases de données avant d'être envoyées au client,
     et sont donc par défaut dans le fuseau horaire du serveur.
    </para>

    <para>
     Il y a plusieurs façons de choisir le fuseau horaire utilisé par le 
     serveur:

     <itemizedlist>
      <listitem>
       <para>
        La variable d'environnement <envar>TZ</envar> du serveur hôte est
        utilisée par le serveur de bases de données comme fuseau horaire par
        défaut, si aucune autre n'est précisée.
       </para>
      </listitem>

      <listitem>
       <para>
        Le paramètre de configuration <varname>timezone</varname> peut être 
        indiqué dans le fichier <filename>postgresql.conf</>.
       </para>
      </listitem>

      <listitem>
       <para>
        La variable d'environnement <envar>PGTZ</envar>, si elle est mise à jour
        par le client, est utilisée par les applications basées sur 
        <application>libpq</application> pour envoyer une commande 
        <command>SET TIME ZONE</command> au serveur lors de la connexion.
       </para>
      </listitem>

      <listitem>
       <para>
        La commande <acronym>SQL</acronym> <command>SET TIME ZONE</command>
        permet de choisir le fuseau horaire pour la session.
       </para>
      </listitem>
     </itemizedlist>
    </para>

     <note>
      <para>
       Si un fuseau horaire invalide est indiqué, le fuseau horaire
       devient <acronym>UTC</acronym> (sur la plupart des systèmes).
      </para>
     </note>

   <para>
    Voir <xref linkend="datetime-appendix"> pour avoir une liste
    des fuseaux horaires disponibles.
   </para>

   </sect2>

   <sect2 id="datatype-datetime-internals">
<title>Types internes</title>

    <para>
    <productname>PostgreSQL</productname> utilise les dates Juliennes pour tous
    les calculs de date/heure. Elles ont la propriété intéressante de permettre
    le calcul de toute date entre 4713 avant Jésus Christ et loin dans le futur,
    si on utilise le fait que l'année dure 365,2425 jours.
    </para>

    <para>
     Les conventions de date antérieures au 19ème siècle offrent une lecture 
     intéressante, mais ne sont pas assez consistantes pour être codées
     dans un gestionnaire de dates.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>Type Boolean</title>

   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> dispose du type <type>boolean</type>
    du standard <acronym>SQL</acronym>.
    Le type booléen ne peut avoir que deux états:<quote>true</quote> (vrai) 
    et <quote>false</quote> (faux). Un troisième état, <quote>unknown</quote>
    (inconnu), est représenté par la valeur nulle de <acronym>SQL</acronym>.
   </para>

   <para>
    Les valeurs littérales valides pour l'état <quote>vrai</quote> sont:
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    Pour l'état <quote>faux</quote>, les valeurs suivantes peuvent être
    utilisées:
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    Il est recommandé d'utiliser <literal>TRUE</literal> et
    <literal>FALSE</literal> (qui sont compatibles avec la norme 
    <acronym>SQL</acronym>).
   </para>

   <example id="datatype-boolean-example">
    <title>Utilisation du type <type>boolean</type>.</title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>

   <para>
   <xref linkend="datatype-boolean-example"> montre que
   les valeurs booléennes sont affichées en utilisant les lettres
   <literal>t</literal> et <literal>f</literal>.
   </para>

   <tip>
    <para>
     Les valeurs de booléennes ne peuvent être directement converties en
     d'autres types. Par exemple, <literal>CAST(
     <replaceable>boolval</replaceable> AS integer)</literal> ne fonctionne
     pas.
     Il faut pour cela utiliser la construction <literal>CASE</literal>:
     <literal>CASE WHEN <replaceable>boolval</replaceable> THEN 'value if true'
     ELSE 'value if false' END</literal>.
     Voir aussi <xref linkend="functions-conditional">.
    </para>
   </tip>

   <para>
    le type <type>boolean</type> utilise 1 octet de stockage.
   </para>
  </sect1>

  <sect1 id="datatype-geometric">
<title>Types géométriques</title>

   <para>
    Les types de données géométriques représentent des objets à deux 
    dimensions. <xref linkend="datatype-geo-table"> liste les types 
    disponibles dans <productname>PostgreSQL</productname>.
    Le type le plus fondamental, le point, forme la base pour tous les
    autres types.
   </para>

    <table id="datatype-geo-table">
     <title>Types géométriques</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Représentation</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
        <entry>16 octets</entry>
        <entry>Point du plan</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <entry>32 octets</entry>
        <entry>Ligne infinie (pas entièrement implémenté)</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
        <entry>32 octets</entry>
        <entry>Segment de droite fini</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
        <entry>32 octets</entry>
        <entry>Boite rectangulaire</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n octets</entry>
        <entry>Chemin fermé (similaire à un polygone)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n octets</entry>
        <entry>Chemin ouvert</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n octets</entry>
        <entry>Polygone (similaire à un chemin fermé)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
        <entry>24 octets</entry>
        <entry>Cercle</entry>
        <entry><(x,y),r> (centre et rayon)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Un large ensemble de fonctions et d'opérateurs permettent d'effectuer
    différentes opérations géométriques, comme l'agrandissement, la translation,
    la rotation, la détermination des intersections. Elles sont expliquées dans
    <xref linkend="functions-geometry">.
   </para>

   <sect2>
    <title>Points</title>

    <indexterm>
     <primary>point</primary>
    </indexterm>

    <para>
     Les points sont les blocs fondamentaux pour construire les types géométriques.
     Les valeurs de type <type>point</type> sont spécifiées en utilisant les syntaxes
     suivantes&nbsp;:
<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     où <replaceable>x</> et <replaceable>y</> sont les coordonnées respectives
     sous forme de nombre à virgule flottante.
    </para>

    <para>
     Les points sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

   <sect2>
    <title>Segments de droites</title>

    <indexterm>
     <primary>lseg</primary>
    </indexterm>

    <indexterm>
     <primary>ligne</primary>
    </indexterm>

    <para>
     Les segments de droites (<type>lseg</type>) sont représentés sous forme
     paires de points, en utilisant une des syntaxes suivantes&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     où
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     et
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sont les points extrémités du segment.
    </para>

    <para>
     Les segments de droites sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

   <sect2>
    <title>Boxes</title>

    <indexterm>
     <primary>boîte (type de données)</primary>
    </indexterm>

    <indexterm>
     <primary>rectangle</primary>
    </indexterm>


    <para>
     Les boites (rectangles) sont représentées par paires de points qui sont les coins
     opposés de la boite, en utilisant une des syntaxes suivante&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     où
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     et
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     sont les coins opposés du rectangle.
    </para>

    <para>
     Les rectangles sont affichés en utilisant la deuxième syntaxe.
    </para>

    <para>
     Tous les coins opposés peuvent être saisis, mais les valeurs seront
     réordonnées pour stocker les coins en haut à droite, et en bas à gauche,
     dans cet ordre.
    </para>
   </sect2>

   <sect2>
    <title>Chemins</title>

    <indexterm>
     <primary>path (type de données)</primary>
    </indexterm>

    <para>
     Les chemins ( type <type>path</type> )
     sont représentés par des ensembles de points connectés.
     Les chemins peuvent être <firstterm>ouverts</firstterm>, si le premier et
     le dernier point ne sont pas connectés, ou <firstterm>fermés</firstterm>,
     si le premier et le dernier point sont connectés.
     Les fonctions <function>popen(<replaceable>p</>)</function> et
     <function>pclose(<replaceable>p</>)</function>
     permettent de forcer l'ouverture et la fermeture d'un chemin,
     et les fonctions <function>isopen(<replaceable>p</>)</function>
     et <function>isclosed(<replaceable>p</>)</function> permettent de
     tester l'un ou l'autre type dans une expression.
    </para>

    <para>
     Les valeurs de type <type>path</type> sont entrées avec une des syntaxes
     suivantes&nbsp;:
     
<synopsis>
 [ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
 ( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
   ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
   ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
     <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

    où les points sont les extrémités des segments de droites qui forment
    le chemin. Les crochets (<literal>[]</literal>) indiquent un chemin ouvert,
    alors que les parenthèses (<literal>()</literal>) indiquent un chemin fermé.
    Quand les parenthèses externes sont omises, comme dans les syntaxes 3 à 5,
    il est supposé qu'il s'agit d'un chemin fermé.
    </para>

    <para>
     Les chemins sont affichés avec la première syntaxe.
    </para>
   </sect2>

   <sect2>
    <title>Polygones</title>

    <indexterm>
     <primary>polygon</primary>
    </indexterm>

    <para>
     Les polygones ( type <type>polygon</type>) sont représentés par des
     ensembles de points. Ils devraient probablement être considérés comme des
     chemins fermés, mais ils sont stockés différemment et ont leurs propres
     routines de manipulation.
    </para>

    <para>
     Les valeurs de type <type>polygon</type> sont saisies avec une des
     syntaxes suivantes&nbsp;:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>    
</synopsis>

     où les points sont les extrémités des segments de droites
     qui forment les limites du polygone.
    </para>

    <para>
     Les polygones sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

   <sect2>
    <title>Cercles</title>

    <indexterm>
     <primary>circle</primary>
    </indexterm>

    <para>
     Les cercles (type <type>circle</type>) sont représentés par le point
     central et le rayon. 
     Les valeurs de type <type>circle</type> sont saisies avec une des syntaxes 
     suivantes&nbsp;:

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>  
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>  
</synopsis>

     où
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     est le centre et <replaceable>r</replaceable> est le rayon du cercle.
    </para>

    <para>
     Les cercles sont affichés en utilisant la première syntaxe.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>Types d'adresses réseau</title>

   <indexterm zone="datatype-net-types">
    <primary>réseau</primary>
    <secondary>types de données</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</> offre des types de données pour stocker des
    adresses IPv4, IPv6 et MAC, décrites dans 
    <xref linkend="datatype-net-types-table">
    Il est préférable d'utiliser ces types plutôt que des types texte
    standards, car ils proposent un contrôle de syntaxe lors de la saisie et
    plusieurs opérations et fonctions spécialisées.
   </para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>Types d'adresses réseau</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Taille de stockage</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <entry>12 or 24 octets</entry>
        <entry>réseaux IPv4 ou IPv6</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <entry>12 or 24 octets</entry>
        <entry> hôtes et réseaux IPv4 et IPv6</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 bytes</entry>
        <entry>adresses MAC</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    Lors du tri d'un type <type>inet</type> ou <type>cidr</type>,
    Les adresses IPv4 apparaîtront toujours avant les adresses IPv6,
    Y compris les adresses IPv4 encapsulées, comme
    ::10.2.3.4 or ::ffff:10.4.3.2.
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet (type de données)</primary>
    </indexterm>

    <para>
     Le type <type>inet</type> contient une adresse d'hôte IPv4 ou IPv6,
     et optionnellement l'identité de son sous réseau, le tout dans un 
     seul champ. L'identité du sous réseau est représentée en indiquant
     combien de bits de l'adresse hôte constituent l'adresse réseau
     (le <quote>masque réseau</quote>).
     Si le masque réseau est 32 et l'adresse de type IPV4,
     alors la valeur n'indique pas un sous réseau, juste un hôte.
     En IPv6, la longueur de l'adresse est de 128 bits, si bien que 
     128 bits définissent une adresse réseau unique. Notez que si vous ne
     voulez utiliser que des adresses de réseau, il est préférable
     d'utiliser le type <type>cidr</type> plutôt que le type <type>inet</type>.
    </para>

    <para>
      Le format de saisie pour ce type est 
      <replaceable class="parameter">address/y</replaceable>
      où
      <replaceable class="parameter">address</replaceable>
      est une adresse IPv4 ou IPv6 et
      <replaceable class="parameter">y</replaceable>
      est le nombre de bits du masque réseau.
      Si <replaceable class="parameter">y</replaceable>
      est omis, alors le masque vaut 32 pour IPv4 et
      128 pour IPv6, et la valeur représente un hôte unique.
      A l'affichage, la portion
      <replaceable class="parameter">/y</replaceable>
      est supprimée si le masque réseau indique un hôte unique.
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
     Le type <type>cidr</type> contient une spécification de réseau 
     IPv4 ou IPv6. L'entrée et la sortie suivent les conventions
     Classless Internet Domain Routing.
     Le format pour indiquer un réseau est <replaceable
     class="parameter">address/y</replaceable> où <replaceable
     class="parameter">address</replaceable> est le réseau représenté sous forme
     d'une adresse IPv4 ou IPv6 et <replaceable
     class="parameter">y</replaceable> est le nombre de bits du masque réseau.
     Si <replaceable class="parameter">y</replaceable> est omis, il calculé en
     utilisant les règles de l'ancien système de classes d'adresses,
     à ceci près qu'il sera au moins assez grand pour inclure tous
     les octets saisis. C'est une erreur de spécifier une adresse réseau
     avec des bits à droite du masque spécifié.
    </para>

    <para>
     <xref linkend="datatype-net-cidr-table"> donne des exemples.
    </para>

     <table id="datatype-net-cidr-table">
      <title><type>cidr</> Exemples de saisie de types</title>
      <tgroup cols="3">
       <thead> 
        <row> 
         <entry>Saisie de <type>cidr</type></entry>
         <entry>Affichage de <type>cidr</type></entry>
         <entry><literal><function>abbrev</function>(<type>cidr</type>)</literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <title>Comparaison de <type>inet</type> et <type>cidr</type></title>

    <para>
    La différence principale entre les types de données <type>inet</type>
    et <type>cidr</type> est que <type>inet</type> accepte des valeurs avec
des bits non nuls à la droite du masque de réseau, alors que <type>inet</type>
    ne l'accepte pas.
    </para>

      <tip>
        <para>
        Si n'aimez pas le format d'affichage des valeurs <type>inet</type>
        et <type>cidr</type>, essayez les fonctions <function>host</>,
        <function>text</>, et <function>abbrev</>.
        </para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm>
     <primary>macaddr (type de données)</primary>
    </indexterm>

    <indexterm>
     <primary>adresse MAC</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
     Le type <type>macaddr</type> stocke des adresses MAC, c'est à dire
     des adresses de cartes réseau Ethernet (mais les adresses MAC sont
     aussi utilisées dans d'autres cas). Les entrées sont acceptées dans
     de nombreux formats, dont:

     <simplelist>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
     </simplelist>

     Qui indiquent tous la même adresse. Les majuscules et les minuscules sont
     acceptées pour les chiffres de <literal>a</literal> à <literal>f</literal>.
     L'affichage se fait toujours selon le dernier format.
    </para>

    <para>
     Le répertoire <filename class="directory">contrib/mac</filename>
     de la distribution des sources de <productname>PostgreSQL</productname>
     contient des outils qui peuvent être utilisés pour trouver les noms
     des fabricants de matériel liés à des adresses MAC.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <title>Types champs de bits</title>

   <indexterm zone="datatype-bit">
    <primary>champ de bits</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <para>
    Les champs de bits sont des chaînes de 0 et de 1. Ils peuvent être
    utilisés pour stocker ou visualiser des masques de bits.
    Il y a deux types champs de bits SQL:
    <type>bit(<replaceable>n</replaceable>)</type> et <type>bit
    varying(<replaceable>n</replaceable>)</type>, où
    <replaceable>n</replaceable> est un entier positif.
   </para>

   <para>
    Les données de type <type>bit</type> doivent avoir une longueur de 
    exactement <replaceable>n</replaceable> bits. Essayer d'y affecter une
    chaîne de bits plus longue ou plus courte déclenche une erreur.
    Les données de type <type>bit varying</type> ont une longueur variable,
    mais ne peuvent dépasser une taille de <replaceable>n</replaceable> bits.
    Les chaînes plus longues sont rejetées.
    Écrire <type>bit</type> sans longueur est équivalent à 
    <literal>bit(1)</literal>, alors que <type>bit varying</type> sans
    longueur indique une taille illimitée.
   </para>

   <note>
    <para>
     Lors d'un transtypage explicite (cast) d'une chaîne de bits vers un 
     champ de type <type>bit(<replaceable>n</replaceable>)</type>, la chaîne obtenue
     sera complétée avec des zéros ou bien tronquée, pour obtenir une taille
     d'exactement <replaceable>n</replaceable> bits, sans que cela produise une erreur.
     De la même façon, si une chaîne de bits est explicitement transtypée vers
     un champ de type <type>bit varying(<replaceable>n</replaceable>)</type>, elle sera tronquée
     si elle fait plus de <replaceable>n</replaceable> bits.
    </para>
   </note>

   <note>
    <para>
     Avant <productname>PostgreSQL</productname> 7.2, les données de type <type>bit</type>
     étaient toujours tronquées (ou complétées avec des zéros) silencieusement,
     que le transtypage soit explicite ou non. Ce comportement a été modifié
     pour se conformer au standard <acronym>SQL</acronym>.
    </para>
   </note>

   <para>
    Voir <xref linkend="sql-syntax-bit-strings"> pour plus d'information sur
    la syntaxe des constantes de champ de bits.
    Les opérateurs logiques bit à bit et les manipulations de chaînes de bits
    sont décrits dans <xref linkend="functions">.
   </para>

   <example>
    <title>Utilisation des types de champs de bits</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

  </sect1>

  &array;

  <sect1 id="datatype-oid">
   <title>Types identifiants d'objets</title>

   <indexterm zone="datatype-oid">
    <primary>identifiant d'objet</primary>
    <secondary>type de données</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <para>
    Les identifiants d'objets (OID) sont utilisés en interne par
    <productname>PostgreSQL</productname> comme
    clés primaires de différentes tables système. 
    De plus, une colonne système OID est 
    ajoutée aux tables créées par les utilisateurs (sauf si 
    <literal>WITHOUT OIDS</literal> est indiqué à la création de la table).
    Le type <type>oid</type> représente un identificateur d'objet
    Il a aussi différents types alias : 
    <type>regproc</type>, <type>regprocedure</type>,
    <type>regoper</type>, <type>regoperator</type>, <type>regclass</type>,
    et <type>regtype</type>. <xref linkend="datatype-oid-table">
    donne un aperçu.
   </para>

   <para>
    Le type <type>oid</type> est actuellement un entier de quatre octets.
    Du coup, il n'est pas suffisamment grand garantir l'unicité dans une
    grosse base de données, où même dans une très grosse table. Du coup,
    l'utilisation d'une colonne OID comme clé primaire d'une table créée
    par un utilisateur est déconseillée.
    Les OID surtout destinés à être des références vers les tables système.
   </para>

   <para>
    Le type <type>oid</type> lui même dispose de peu d'opérations à part la
    comparaison. Néanmoins, il peut être transtypé en entier (integer)
    et manipulé en utilisant les opérateurs habituels des entiers.
    (Attention aux possibles confusions entre les entiers signés et non
    signés si vous le faites.)
   </para>

   <para>
    Les types alias d'OID n'ont pas d'opérations propres, à part
    des routines d'entrées et sorties spécifiques. Ces routines
    acceptent et affichent des formes symboliques pour les objets
    systèmes, plutôt que les valeurs numériques brutes que le type
    <type>oid</type> utilise. Les types alias permettent une recherche
    simplifiée de valeurs d'OID pour les objets: par exemple, on
    peut utiliser <literal>'mytable'::regclass</literal> pour obtenir
    l'OID de la table <literal>mytable</literal>, plutôt que
    <literal>SELECT oid FROM pg_class WHERE relname = 'mytable'</literal>.
    (En réalité, une commande <command>SELECT</command> plus complexe est
    nécessaire pour retrouver le bon OID lorsqu'il y a plusieurs tables
    du même nom dans différents schémas.)
   </para>

    <table id="datatype-oid-table">
     <title>Types identifiants d'objet</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Référence</entry>
        <entry>Description</entry>
        <entry>Exemple</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</></entry>
        <entry>tous</entry>
        <entry>identifiant d'objet numérique</entry>
        <entry><literal>564182</></entry>
       </row>

       <row>
        <entry><type>regproc</></entry>
        <entry><structname>pg_proc</></entry>
        <entry>nom de fonction</entry>
        <entry><literal>sum</></entry>
       </row>

       <row>
        <entry><type>regprocedure</></entry>
        <entry><structname>pg_proc</></entry>
        <entry>fonction avec les types d'arguments</entry>
        <entry><literal>sum(int4)</></entry>
       </row>

       <row>
        <entry><type>regoper</></entry>
        <entry><structname>pg_operator</></entry>
        <entry>nom d'opérateur</entry>
        <entry><literal>+</></entry>
       </row>

       <row>
        <entry><type>regoperator</></entry>
        <entry><structname>pg_operator</></entry>
        <entry>opérateur avec types d'arguments</entry>
        <entry><literal>*(integer,integer)</> ou <literal>-(NONE,integer)</></entry>
       </row>

       <row>
        <entry><type>regclass</></entry>
        <entry><structname>pg_class</></entry>
        <entry>nom de relation</entry>
        <entry><literal>pg_type</></entry>
       </row>

       <row>
        <entry><type>regtype</></entry>
        <entry><structname>pg_type</></entry>
        <entry>nom de type de données</entry>
        <entry><literal>integer</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Tous les types alias d'OID acceptent des noms avec un préfixe de schéma,
    et affichent des noms préfixés par un schémas si l'objet ne peut être 
trouvé dans le chemin de recherche courant sans préfixe de schéma.
    Les types alias <type>regproc</type> et <type>regoper</type> n'acceptent que des
    noms uniques en entrée (sans surcharge), si bien qu'ils sont d'un usage
    limité. Dans la plupart des cas, <type>regprocedure</type> ou
    <type>regoperator</type> sont plus appropriés. Pour <type>regoperator</type>,
    les opérateurs unaires sont identifiés en écrivant <literal>NONE</literal> pour
    les opérandes non utilisés.
   </para>

   <para>
    Un autre type identifiant utilisé par le système est <type>xid</type>, ou
    identifiant (abrégé <abbrev>xact</abbrev>) de transaction.
    C'est le type de données des colonnes systèmes <structfield>xmin</structfield> et
    <structfield>xmax</structfield>. Les identifiants de transactions sont des
    quantités sur 32 bits.
   </para>

   <para>
    Un troisième type identifiant utilisé par le système est <type>cid</type>,
    ou identifiant de commande. C'est le type de données des colonnes systèmes
    <structfield>cmin</structfield> et <structfield>cmax</structfield>. Les identifiants de commandes
    sont aussi des quantités sur 32 bits.
   </para>

   <para>
    Un dernier type identifiant utilisé par le système est <type>tid</type>,
    ou identifiant de tuple (identifiant de ligne). C'est le type de données
    des colonnes système <structfield>ctid</structfield>. Un tuple est une paire
    (numéro de bloc, index de tuple dans le bloc) qui identifie l'emplacement
    physique de la ligne dans sa table.
   </para>

   <para>
    (Les colonnes systèmes sont expliquées plus en détail dans <xref
    linkend="ddl-system-columns">.)
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <title>Pseudo-Types</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>

   <para>
    Le système de types de <productname>PostgreSQL</productname>
    contient un certain nombre de types à usage spécial qui sont
    collectivement appelés des <firstterm>pseudo-types</firstterm>. Un
    pseudo-type ne peut être utilisé pour une colonne de table, mais il peut
    être utilisé pour déclarer un argument de fonction ou un type 
    de résultat. Chacun des pseudo-types disponibles est utile dans des
    situations où le comportement d'une fonction ne correspond pas simplement
    à accepter ou retourner des valeurs d'un type de données
    <acronym>SQL</acronym> spécifique. <xref
    linkend="datatype-pseudotypes-table"> liste les pseudo-types existants.
   </para>

    <table id="datatype-pseudotypes-table">
     <title>Pseudo-Types</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Nom</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</type></entry>
        <entry>
         Indique qu'une fonction accepte n'importe quel type de données,
         quel qu'il soit.
        </entry>
       </row>

       <row>
        <entry><type>anyarray</type></entry>
        <entry>
         Indique qu'une fonction accepte tout type tableau (voir
         <xref linkend="extend-types-polymorphic">).
        </entry>
       </row>

       <row>
        <entry><type>anyelement</type></entry>
        <entry>Indique qu'une fonction accepte tout type de données.
        (voir <xref linkend="extend-types-polymorphic">).</entry>
       </row>

       <row>
        <entry><type>cstring</type></entry>
        <entry>Indique qu'une fonction accepte ou retourne une chaîne de caractères
         du langage C (terminée par un NULL).</entry>
       </row>

       <row>
        <entry><type>internal</type></entry>
        <entry>Indique qu'une fonction accepte ou retourne un type de données
         interne du serveur de bases de données.</entry>
       </row>

       <row>
        <entry><type>language_handler</type></entry>
        <entry>Une fonction d'appel de langage procédural est déclarée retourner un <type>language_handler</>.</entry>
       </row>

       <row>
        <entry><type>record</type></entry>
        <entry>Identifie une fonction qui retourne un type de ligne non spécifié.</entry>
       </row>

       <row>
        <entry><type>trigger</type></entry>
        <entry>Une fonction trigger est déclarée comme retournant un type <type>trigger.</></entry>
       </row>

       <row>
        <entry><type>void</type></entry>
        <entry>Indique qu'une fonction ne retourne pas de valeur.</entry>
       </row>

       <row>
        <entry><type>opaque</type></entry>
        <entry>Un type de données obsolète qui servait précédemment à tous les usages cités ci-dessus.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Les fonctions codées en C (incluses dans le produit ou chargées dynamiquement)
    peuvent déclarer, accepter ou retourner chacun de ces pseudo-types. Il est de
    la responsabilité de l'auteur de la fonction de s'assurer que la fonction se
    comporte normalement lorsqu'un pseudo-type est utilisé comme type d'argument.
   </para>

   <para>
    Les fonctions codées en langage procédural peuvent utiliser les
    pseudo-types si leur langage le permet. A ce jour, tous les langages
    interdisent l'usage d'un pseudo-type comme argument, et n'acceptent que
    <type>void</type> et <type>record</type> comme type retourné (plus <type>trigger</type>
    lorsque la fonction est utilisée comme trigger).
    Certains supportent aussi les fonctions polymorphes en utilisant les 
    types <type>anyarray</type> et <type>anyelement</type>.
   </para>

   <para>
    Le pseudo-type <type>internal</type> sert à déclarer des fonctions qui
    ne sont appelées que par la base de données en interne,
    et non pas directement par une requête <acronym>SQL</acronym>.
    Si une fonction a au moins un argument de type <type>internal</type>,
    alors elle ne peut être appelée depuis <acronym>SQL</acronym>.
    Pour préserver la sécurité de cette restriction, il est important de
    suivre cette règle de codage: ne créez pas de fonction qui retourne un
    <type>internal</type> si elle n'a pas au moins un argument de type
    <type>internal</type>.
   </para>

  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->

