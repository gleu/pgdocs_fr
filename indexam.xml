<?xml version="1.0" encoding="ISO-8859-15"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<chapter id="indexam">
 <title>Définition de l'interface des méthodes d'accès aux index</title>

  <para>
   Ce chapitre définit l'interface entre le système
   <productname>PostgreSQL</productname> et les <firstterm>méthodes d'accès
   aux index</firstterm>, qui gérent les types d'index individuels. Le système principal
   ne sait rien des index en dehors de ce qui est spécifié ici. Il est donc
   possible de développer de nouveaux types d'index en écrivant du code
   supplémentaire.
  </para>

  <para>
   Tous les index de <productname>PostgreSQL</productname> sont connus
   techniquement en tant qu'<firstterm>index secondaires</firstterm>&nbsp;; c'est-à-dire
   que l'index est séparé physiquement du fichier de table qu'il décrit. Chaque index
   est stocké dans sa propre <firstterm>relation</firstterm> physique et donc décrit
   par une entrée dans le catalogue <structname>pg_class</structname>. Le contenu d'un
   index est entièrement contrôlé par la méthode d'accès à l'index. En
   pratique, toutes les méthodes d'accès aux index les divisent en pages de
   taille standard de façon à utiliser le gestionnaire de stockage
   et le gestionnaire de tampon pour accéder au contenu de l'index. De plus,
   toutes les méthodes existantes d'accès aux index utilisent la disposition
   de page standard décrite dans <xref linkend="storage-page-layout"/> et
   le même format pour les en-têtes de ligne de
   l'index&nbsp;; mais ces décisions ne sont pas contraintes sur une méthode
   d'index.
  </para>

  <para>
   Dans les faits, un index est une correspondance entre les valeurs des clés
   de données et les
   identifiants de lignes (<firstterm>tuple identifiers</firstterm>, ou <acronym>TIDs</acronym>)
   des versions de lignes dans la table parent de l'index. Un TID consiste en un
   numéro de bloc et un numéro d'élément à l'intérieur de ce bloc (voir <xref
   linkend="storage-page-layout"/>). C'est une information suffisante pour
   récupérer une version de ligne particulière à partir de la table. Les index
   n'ont pas directement la connaissance de l'existence éventuelle, sous MVCC,
   de plusieurs versions de la même ligne logique&nbsp;; pour un index, chaque ligne
   est un objet indépendant qui a besoin de sa propre entrée dans l'index. Du
   coup, la mise à jour d'une ligne crée toujours toutes les nouvelles entrées
   d'index pour la ligne, même si les valeurs de la clé ne changent pas. Les
   entrées d'index pour les lignes mortes sont réclamées (par le VACUUM) lorsque
   les lignes mortes elles-même sont réclamées.
  </para>

 <sect1 id="index-catalog">
  <title>Entrées du catalogue pour les index</title>

  <para>
   Chaque méthode d'accès à l'index est décrite par une ligne dans le catalogue
   système <structname>pg_am</structname> (voir <xref linkend="catalog-pg-am"/>).
   Le contenu principal d'une ligne de <structname>pg_am</structname> est
   constitué de références à des entrées de
   <link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>
   qui identifient les fonctions d'accès à l'index fournies par la méthode d'accès.
   Les API de ces fonctions sont définies plus loin dans ce chapitre. De plus,
   la ligne de <structname>pg_am</structname> spécifie quelques propriétés fixes
   de la méthode d'accès, comme le support des index multi-colonnes. Il
   n'existe pas de support spécial pour la création ou la suppression d'entrées
   dans <structname>pg_am</structname>&nbsp;; toute personne capable d'écrire
   une nouvelle méthode d'accès est supposée assez compétente pour insérer la
   ligne appropriée.
  </para>

  <para>
   Pour être utile, une méthode d'accès à l'index doit aussi avoir une ou
   plusieurs <firstterm>familles d'opérateur</firstterm> et <firstterm>classes
   d'opérateur</firstterm> définies dans
   <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>,
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link> et
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   Ces entrées permettent au planificateur de déterminer les types de qualification
   des requêtes qui peuvent être utilisés avec les index de cette méthode d'accès.
   Les familles et classes d'opérateurs sont décrites dans <xref
   linkend="xindex"/>, qui est un élément requis pour comprendre ce chapitre.
  </para>

  <para>
   Un index individuel est défini par une entrée dans
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   le définissant comme une relation physique, et une entrée dans
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   affichant le contenu logique de l'index &mdash; c'est-à-dire ses colonnes
   d'index et la sémantique de ces colonnes, telles que
   récupérées par les classes d'opérateur associées. Les colonnes de
   l'index (valeurs clés) peuvent être des colonnes simples de la table
   sous-jacente ou des expressions sur les lignes de la table. Habituellement,
   la méthode d'accès à l'index ne s'intérese pas à la provenance
   des valeurs clés de l'index (ce sont toujours des valeurs clés
   pré-traitées), mais trouve beaucoup d'intérêt aux informations de la classe
   d'opérateur dans <structname>pg_index</structname>. Les entrées de ces deux
   catalogues peuvent être accédées comme partie de la structure de données de
   <structname>Relation</structname> passée à toute opération sur l'index.
  </para>

  <para>
   Certaines colonnes d'options de <structname>pg_am</structname> ont des
   implications peu évidentes. Les besoins de <structfield>amcanunique</structfield>
   sont discutés dans  <xref linkend="index-unique-checks"/>.
   L'option <structfield>amcanmulticol</structfield> indique que la méthode
   d'accès supporte les index multi-colonnes alors que 
   <structfield>amoptionalkey</structfield> indique que des parcours sont
   autorisés lorsqu'aucune clause de restriction indexable n'est donnée pour la première colonne
   de l'index. Quand <structfield>amcanmulticol</structfield> est faux,
   <structfield>amoptionalkey</structfield> indique essentiellement si la méthode
   d'accès autorise les parcours complets de l'index sans clause de restriction.
   Les méthodes d'accès qui supportent les colonnes d'index multiples
   <emphasis>doivent</emphasis> supporter les parcours qui omettent des
   restrictions sur une ou toutes les colonnes après la première&nbsp;;
   néanmoins, elles peuvent imposées qu'une restriction apparaisse pour la
   première colonne de l'index, ce qui est signalé par l'initialisation de
   <structfield>amoptionalkey</structfield> à faux.
   <structfield>amindexnulls</structfield> indique que des entrées d'index sont
   créées pour les valeurs de clés NULL. Comme la plupart des opérateurs indexables
   sont stricts et, du coup, ne peuvent pas renvoyer TRUE pour des entrées NULL,
   il est à première vue attractif de ne pas stocker les entrées d'index pour les
   valeurs NULL&nbsp;: un parcours d'index ne peut, de toute façon, pas les
   retourner. Néanmoins, cet argument tombe lorsqu'un parcours d'index
   n'a pas de clause de restriction pour une colonne d'index donnée. En pratique,
   cela signifie que les index dont <structfield>amoptionalkey</structfield> vaut
   true doivent indexer les valeurs NULL, car le planificateur peut décider
   d'utiliser un tel index sans aucune clé de parcours. Une restriction en
   découle&nbsp;: une méthode d'accès qui supporte des colonnes d'index
   multiples <emphasis>doit</emphasis> supporter l'indexage des valeurs NULL dans les colonnes
   qui suivent la première, car le planificateur suppose que l'index peut être
   utilisé pour les requêtes qui ne restreignent pas ces colonnes. Par exemple,
   si l'on considère un index sur (a,b) et une requête avec <literal>WHERE a =
   4</literal>, le système suppose que l'index peut être utilisé pour
   rechercher les lignes pour lesquelles <literal>a = 4</literal>, ce qui est
   faux si l'index omet les lignes où <literal>b</literal> est null.
   Néanmoins, il est correct d'omettre les lignes où la
   première colonne indexée est NULL. Du coup,
   <structfield>amindexnulls</structfield> doit valoir true seulement si la
   méthode d'accès à l'index indexe toutes les lignes, en incluant les
   combinaisons arbitraires de valeurs NULL. Une méthode d'accès d'index qui
   initialise <structfield>amindexnulls</structfield> peut aussi initialiser
   <structfield>amsearchnulls</structfield>, indiquant ainsi qu'elle supporte
   les clauses <literal>IS NULL</literal> dans les conditions de recherche.
  </para>

 </sect1>

 <sect1 id="index-functions">
  <title>Fonctions de la méthode d'accès aux index</title>

  <para>
   Les fonctions de construction et de maintenance d'index que doit fournir
   une méthode d'accès aux index sont&nbsp;:
  </para>

  <para>
<programlisting>IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   Construire un nouvel index. La relation de l'index a été créée physiquement
   mais elle est vide. Elle doit être remplie avec toute donnée fixe nécessaire
   à la méthode d'accès, ainsi que les entrées pour toutes les lignes existant
   déjà dans la table. Habituellement, la fonction <function>ambuild</function> appelle
   <function>IndexBuildHeapScan()</function> pour parcourir la table à la
   recherche des lignes qui existent déjà et calculer les clés à insérer dans
   l'index. La fonction doit renvoyer une structure allouée par palloc contenant
   les statistiques du nouvel index.
  </para>

  <para>
<programlisting>bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          bool check_uniqueness);
</programlisting>
   Insérer une nouvelle ligne dans un index existant. Les tableaux
   <literal>values</literal> et <literal>isnull</literal> donnent les valeurs
   de clés à indexer.
   <literal>heap_tid</literal> est le TID à indexer. Si la méthode d'accès supporte les
   index uniques (son drapeau <structname>pg_am</structname>.<structfield>amcanunique</structfield>
   vaut true), alors <literal>check_uniqueness</literal> peut aussi valoir
   true. Dans ce cas la méthode d'accès doit vérifier qu'il n'y a pas de ligne en
   conflit&nbsp;; c'est la seule situation où le paramètre
   <literal>heapRelation</literal> est nécessaire dans la méthode d'accès.
   Voir <xref linkend="index-unique-checks"/> pour les détails. Le résultat vaut
   TRUE si une entrée de l'index a été insérée, FALSE sinon. (Un résultat FALSE
   n'indique pas une erreur, car il est utilisé dans divers cas, dont la méthode d'indexage
   qui refuse d'indexer une valeur NULL.)
  </para>

  <para>
<programlisting>IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   Supprimer un(des) tuple(s) de l'index. Il s'agit d'une opération de
   <quote>suppression massive</quote> à implanter par le parcours complet de
   l'index et la vérification de chaque entrée pour déterminer si elle
   doit être supprimée. La fonction <literal>callback</literal> en argument doit être
   appelée, sous la forme <literal>callback(<replaceable>TID</replaceable>, callback_state)
   returns bool</literal>, pour déterminer si une entrée d'index particulière,
   identifiée par son TID, est à supprimer. Cette fonction Doit renvoyer NULL
   ou une structure issue d'un palloc qui contient des statistiques sur les
   effets de l'opération de suppression.
   La fonction peut retourner NULL si aucune information ne doit être envoyée à
   <function>amvacuumcleanup</function>.
  </para>

  <para>
   En cas de limitation de <varname>maintenance_work_mem</varname>, la
   suppression de nombreux tuples impose d'appeler
   <function>ambulkdelete</function> à plusieurs reprises.
   L'argument <literal>stats</literal> est le résultat du dernier appel pour cet index
   (il est NULL au premier appel dans une opération
   <command>VACUUM</command>). Ceci permet à l'AM d'accumuler des statistiques
   sur l'opération dans son intégralité. Typiquement, <function>ambulkdelete</function>
   modifie et renvoie la même structure si le <literal>stats</literal> fourni
   n'est pas NULL.
  </para>

  <para>
<programlisting>IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   Nettoyage après une opération <command>VACUUM</command> (zéro à plusieurs
   appels à <function>ambulkdelete</function>). La fonction n'a pas d'autre but
   que de retourner des statistiques concernant les index, mais elle peut réaliser
   un nettoyage en masse (réclamer les pages d'index vides, par exemple).
   <literal>stats</literal> est le retour de l'appel à <function>ambulkdelete</function>,
   ou NULL si
   <function>ambulkdelete</function> n'a pas été appelée car aucune ligne n'avait
   besoin d'être supprimée. Si le résultat n'est pas NULL, il s'agit d'une structure
   allouée par palloc. Les statistiques qu'elle contient sont utilisées pour
   mettre à jour <structname>pg_class</structname>, et sont rapportées par
   <command>VACUUM</command> si <literal>VERBOSE</literal> est indiqué. La
   fonction peut retourner NULL si l'index n'a pas été modifié lors de l'opération
   de <command>VACUUM</command> mais, dans le cas contraire, il faut retourner
   des statistiques correctes.
  </para>

  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexOptInfo *index,
                List *indexQuals,
                RelOptInfo *outer_rel,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>
   Estimer les coûts d'un parcours d'index. Cette fonction est décrite complètement
   dans <xref linkend="index-cost-estimation"/>, ci-dessous.
  </para>

  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
   Analyser et valider le tableau reloptions pour un index. Cette fonction
   n'est appelée que lorsqu'il existe un tableau reloptions non NULL pour l'index.
   <parameter>reloptions</parameter> est un tableau de type <type>text</type>
   contenant des entrées de la forme
   <replaceable>nom</replaceable><literal>=</literal><replaceable>valeur</replaceable>.
   La fonction construit une valeur de type <type>bytea</type> à
   copier dans le champ <structfield>rd_options</structfield> de l'entrée relcache
   de l'index. Les données contenues dans la valeur <type>bytea</type> sont
   définies par la méthode d'accès, mais les méthodes d'accès standard utilisent actuellement
   toutes la structure <structname>StdRdOptions</structname>.
   Lorsque <parameter>validate</parameter> est true, la fonction remonte
   un message d'erreur clair si une option n'est pas reconnue ou a des
   valeurs invalides&nbsp;; quand <parameter>validate</parameter> est false, les
   entrées invalides sont ignorées silencieusement.
   (<parameter>validate</parameter> est faux lors du chargement d'options déjà
   stockées dans <structname>pg_catalog</structname>&nbsp;; une entrée invalide
   ne peut être trouvée que si la méthode d'accès a modifié ses règles pour
   les options et, dans ce cas, ignorer les entrées obsolètes est approprié.)
   Pour obtenir le comportement par défaut, il suffit de retourner NULL.
  </para>

  <para>
   Le but d'un index est de supporter les parcours de lignes
   qui correspondent à une condition <literal>WHERE</literal> indexable, souvent appelée
   <firstterm>qualificateur</firstterm>
   (<foreignphrase>qualifier</foreignphrase>) ou <firstterm>clé de
   parcours</firstterm> (<foreignphrase>scan key</foreignphrase>). La sémantique
   du parcours d'index est décrite plus complètement dans <xref linkend="index-scanning"/>,
   ci-dessous. Les fonctions liées au parcours qu'une méthode d'accès à
   l'index doit fournir sont&nbsp;:
  </para>

  <para>
<programlisting>IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             ScanKey key);
</programlisting>
   Débuter un nouveau parcours. Le tableau <literal>key</literal> (de longueur
   <literal>nkeys</literal>) décrit les clés de parcours pour le parcours de
   l'index. Le résultat doit être une structure allouée par palloc. Pour des
   raisons de codage, la méthode d'accès à l'index <emphasis>doit</emphasis>
   créer cette structure en appelant <function>RelationGetIndexScan()</function>. Dans
   la plupart des cas, <function>ambeginscan</function> se contente de réaliser
   l'appel&nbsp;; les parties intéressantes de début de parcours d'index sont
   dans <function>amrescan</function>.
  </para>

  <para>
<programlisting>boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   Récupérer la prochaine ligne d'un parcours donné, dans la direction donnée
   (vers l'avant ou l'arrière de l'index). Renvoie TRUE si une ligne a
   été obtenue, FALSE s'il ne reste aucune ligne. Dans le cas
   TRUE, le TID de la ligne est stocké dans la structure
   <literal>scan</literal>. <quote>success</quote> signifie uniquement que
   l'index contient une entrée qui correspond aux clés de parcours, pas que
   la ligne existe toujours dans la pile ou qu'elle peut réussir le test
   d'instantané de l'appelant.
  </para>

  <para>
<programlisting>boolean
amgetmulti (IndexScanDesc scan,
            ItemPointer tids,
            int32 max_tids,
            int32 *returned_tids);
</programlisting>
   Récupérer plusieurs lignes d'un parcours donné. Renvoie TRUE si le parcours
   peut continuer, FALSE s'il ne subsiste plus aucune ligne.
   <literal>tids</literal> pointe sur un tableau fournit par l'appelant de
   <literal>max_tids</literal> enregistrements <structname>ItemPointerData</structname>,
   remplit, à l'appel, des TID des lignes correspondantes. <literal>*returned_tids</literal> est
   initialisé au nombre de TID réellement renvoyés. Il peut y en avoir moins
   que <literal>max_tids</literal>, voire zéro, même si la valeur de retour vaut
   TRUE. (Cette provision permet à la méthode d'accès de choisir les points d'arrêt les
   plus efficaces dans son parcours, par exemple les limites de la page d'index).
   <function>amgetmulti</function> et <function>amgettuple</function> ne peuvent pas être utilisés
   dans le même parcours d'index&nbsp;; l'utilisation de
   <function>amgetmulti</function> est soumise à d'autres restrictions, comme expliqué dans <xref
   linkend="index-scanning"/>.
  </para>

  <para>
<programlisting>void
amrescan (IndexScanDesc scan,
          ScanKey key);
</programlisting>
   Recommencer le parcours donné, si possible avec de nouvelles clés de parcours
   (pour continuer à utiliser les anciennes clés, passer NULL pour
   <literal>key</literal>). Il n'est pas possible de changer le nombre de
   clés. En pratique, la fonctionnalité de relance est utilisée quand une
   nouvelle ligne externe est sélectionnée par une jointure imbriquée en
   boucle, ce qui impose une nouvelle valeur de comparaison de clés, 
   mais la structure de la clé de parcours reste inchangée. Cette fonction est
   aussi appelée par <function>RelationGetIndexScan()</function>. Elle est de
   ce fait à la fois utilisée pour initialiser un parcours d'index et
   pour le re-parcourir.
  </para>

  <para>
<programlisting>void
amendscan (IndexScanDesc scan);
</programlisting>
   Terminer un parcours et libérer les ressources. La structure <literal>scan</literal>
   elle-même ne doit pas être libérée, mais tout verrou pris en interne par
   la méthode d'accès doit être libéré.
  </para>

  <para>
<programlisting>void
ammarkpos (IndexScanDesc scan);
</programlisting>
   Marquer la position courante du parcours. La méthode d'accès ne mémorise
   qu'une seule position par parcours.
  </para>

  <para>
<programlisting>void
amrestrpos (IndexScanDesc scan);
</programlisting>
   Restaurer le parcours à sa plus récente position marquée.
  </para>

  <para>
   Par convention, l'entrée <literal>pg_proc</literal> de toute fonction de
   méthode d'accès aux index affiche le bon nombre d'arguments, mais
   les déclare tous du type <type>internal</type> (la plupart des
   arguments ont des types qui ne sont pas connus en SQL, et il n'est pas
   souhaitable que les utilisateurs appelent les fonctions directement). Le type
   de retour est déclaré <type>void</type>, <type>internal</type> ou <type>boolean</type>
   suivant le cas.
   La seule exception est <function>amoptions</function>, qui doit être
   correctement déclarée prenant <type>text[]</type> et <type>bool</type>
   et retournant <type>bytea</type>. Cette protection autorise le code client à
   exécuter <function>amoptions</function> pour tester la validité des paramètres.
  </para>

 </sect1>

 <sect1 id="index-scanning">
  <title>Parcours d'index</title>

<!-- régurgitation est un drôle de terme dans ce contexte. L'auteur a-t-il
voulu mettre en avant une idée négative du fonctionnement du parcours ? -->
  <para>
   Dans un parcours d'index, la méthode d'accès à l'index retourne les TID
   de toutes les lignes annoncées correspondre
   aux <firstterm>clés de parcours</firstterm>. La méthode d'accès n'est
   impliquée <emphasis>ni</emphasis> dans la récupération de ces lignes dans la
   table parent de l'index, ni dans les tests de qualification temporelle ou autre.
  </para>

  <para>
   Une clé de parcours est une représentation interne d'une clause 
   <literal>WHERE</literal> de la forme <replaceable>clé_index</replaceable>
   <replaceable>opérateur</replaceable> <replaceable>constante</replaceable>,
   où la clé d'index est une des colonnes de l'index et l'opérateur est un des
   membres de la famille d'opérateur associée avec cette colonne d'index. Un
   parcours d'index contient entre aucune et plusieurs clés de parcours qui sont assemblées
   implicitement avec des AND &mdash; les lignes renvoyées doivent satisfaire
   toutes les conditions indiquées.
  </para>

<!-- lossy: à pertes ? c'est valable quand on parle de compression, qui
supprime des données, mais dans le cas de l'index ? -->
  <para>
   La famille d'opérateur peut indiquer que l'index est <firstterm>à perte</firstterm>
   pour un opérateur particulier&nbsp;; ceci implique que le parcours d'index
   renvoie toutes les entrées qui correspondent à la clé de parcours, avec
   éventuellement des entrées supplémentaires qui ne correspondent pas. La machinerie du
   parcours d'index du système principal applique alors cet opérateur au tuple
   pour vérifier s'il doit bien effectivement être retenu. Pour les opérateurs sans perte,
   le parcours d'index doit renvoyer exactement l'ensemble d'entrées
   correspondantes, car il n'y a pas de revérification.
  </para>

  <para>
   La méthode d'accès doit s'assurer 
   qu'elle trouve correctement toutes les entrées correspondantes aux clés de
   parcours données, et seulement celles-ci. De plus, le système principal
   transfert toutes les clauses <literal>WHERE</literal> qui correspondent aux clés d'index
   et aux familles d'opérateurs, sans analyse sémantique permettant de
   déterminer si elles sont redondantes ou contradictoires. Par exemple, étant donné
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal> où <literal>x</literal> est une colonne
   indexée B-tree, c'est à la fonction B-tree <function>amrescan</function>
   de déterminer que la première clé de parcours est redondante et peut être
   annulée. Le supplément de pré-traitement nécessaire lors de
   <function>amrescan</function> dépend du niveau de réduction des clés de
   parcours en une forme <quote>normalisée</quote> nécessaire à la
   méthode d'accès à l'index.
  </para>

  <para>
   Certaines méthodes d'accès renvoient des entrées d'index dans un ordre bien
   défini, d'autres non. Si les entrées sont renvoyées triées, la méthode
   d'accès doit initialiser
   <structname>pg_am</structname>.<structfield>amcanorder</structfield> à
   true pour indiquer qu'elle supporte les parcours triés. Toutes les méthodes
   d'accès doivent utiliser des numéros de stratégie compatibles btree pour les
   opérateurs d'égalité et de tri.
  </para>

  <para>
   La fonction <function>amgettuple</function> dispose d'un argument <literal>direction</literal>,
   qui peut être soit <literal>ForwardScanDirection</literal> (le cas normal) soit
   <literal>BackwardScanDirection</literal>. Si le premier appel après
   <function>amrescan</function> précise <literal>BackwardScanDirection</literal>, alors
   l'ensemble des entrées d'index correspondantes est à parcourir de l'arrière
   vers l'avant plutôt que dans la direction normale (d'avant en arrière). 
   <function>amgettuple</function> doit donc renvoyer la dernière ligne correspondante dans
   l'index, plutôt que la première, comme cela se fait normalement. (Cela ne
   survient que pour les méthodes
   d'accès qui indiquent qu'elles supportent les parcours ordonnés.) Après
   le premier appel, <function>amgettuple</function>
   doit être préparé pour continuer le parcours dans la direction adaptée à partir de
   l'entrée la plus récemment renvoyée.
  </para>

  <para>
   La méthode d'accès doit supporter le <quote>marquage</quote> d'une position dans
   un parcours et le renvoi ultérieur à une position marquée. La même position
   peut être restaurée plusieurs fois. Néanmoins, seule une position doit
   être mémorisée par parcours&nbsp;; tout nouvel appel à <function>ammarkpos</function>
   surcharge la position précédemment marquée.
  </para>

  <para>
   Les positions du parcours et du marquage doivent être conservées de façon
   cohérente dans le cas d'insertions et de suppressions concurrentes dans
   l'index. Il est tout à fait correct qu'une entrée tout juste insérée ne soit
   pas retournée par un parcours, qui si l'entrée avait existé au démarrage du
   parcours, aurait été retournée. De même est-il correct qu'un parcours
   retourne une telle entrée lors d'un re-parcours ou d'un retour arrière,
   alors même qu'il ne l'a pas retourné lors du parcours initial.
   À l'identique, une suppression concurrente peut être, ou non, visible dans
   les résultats d'un parcours. Il est primordial qu'insertions et suppressions
   ne conduisent pas le parcours à oublier ou dupliquer des entrées qui ne sont
   pas elles-même insérées ou supprimées.
  </para>

  <para>
   <function>amgetmulti</function> peut être utilisé à la place de 
   <function>amgettuple</function> pour un parcours d'index. Cela permet de
   récupérer plusieurs lignes par appel. Cette méthode peut s'avérer 
   notablement plus efficace que <function>amgettuple</function> parce qu'elle
   permet d'éviter les cycles de verrouillage/déverrouillage à l'intérieur de la
   méthode d'accès. En principe, <function>amgetmulti</function> a les mêmes
   effets que des appels répétés à <function>amgettuple</function>, mais 
   plusieurs restrictions ont été imposées pour simplifier la procédure. En premier lieu,
   <function>amgetmulti</function> ne prend pas d'argument
   <literal>direction</literal>, et de ce fait, ne supporte ni parcours inverse
   ni changement de direction au sein d'un parcours.
   La méthode d'accès n'a pas non plus à supporter le marquage et la
   restauration des positions de parcours lors d'un parcours
   <function>amgetmulti</function>. (Ces restrictions sont minimes, car
   l'utilisation de ces fonctionnalités lors d'un parcours
   <function>amgetmulti</function> s'avère difficile&nbsp;: l'ajustement du
   tampon de la liste des TIDs de l'appelant est complexe). Enfin,
   <function>amgetmulti</function> ne garantit pas le verrouillage
   des lignes renvoyées, avec les implications précisées dans <xref
   linkend="index-locking"/>.
  </para>

 </sect1>

 <sect1 id="index-locking">
  <title>Considérations sur le verrouillage d'index</title>

  <para>
   Les méthodes d'accès aux index doivent gérer des mises à jour
   concurrentes de l'index par plusieurs processus.
   Le système principal <productname>PostgreSQL</productname> obtient
   <literal>AccessShareLock</literal> sur l'index lors d'un parcours d'index et
   <literal>RowExclusiveLock</literal> lors de sa mise à jour (ce qui inclut le
   <command>VACUUM</command> simple). Comme ces types de
   verrous ne sont pas conflictuels, la méthode d'accès est responsable de la
   finesse du verrouillage dont elle a besoin. Un verrou exclusif sur
   l'intégralité de l'index entier n'est pris qu'à la création de l'index, sa destruction,
   dans une opération <literal>REINDEX</literal> ou lors d'un <command>VACUUM
   FULL</command>.
  </para>

  <para>
   Construire un type d'index qui supporte les mises à jour concurrentes
   requiert une analyse complète et subtile du comportement requis. Pour les
   types d'index B-tree et hash, on peut lire les implication sur les décisions
   de conception dans
   <filename>src/backend/access/nbtree/README</filename> et
   <filename>src/backend/access/hash/README</filename>.
  </para>

  <para>
   En plus des besoins de cohérence interne de l'index, les mises à jour
   concurrentes créent des problèmes de cohérence entre la table parent
   (l'<firstterm>en-tête</firstterm>, ou <foreignphrase>heap</foreignphrase>)
   et l'index. Comme <productname>PostgreSQL</productname> sépare les accès et les mises à
   jour de l'en-tête de ceux de l'index, il existe des fenêtres temporelles
   pendant lesquelles l'index et l'en-tête peuvent être incohérents. Ce problème
   est géré avec les règles suivantes&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       une nouvelle entrée dans l'en-tête est effectuée avant son entrée
       dans l'index. (Un parcours d'index concurrent peutt alors ne pas
       voir l'entrée dans l'en-tête. Ce n'est pas gênant dans la mesure où un
       lecteur de l'index ne s'intéresse pas à une ligne non validée. Voir
       <xref linkend="index-unique-checks"/>);
      </para>
     </listitem>
     <listitem>
      <para>
       Lorsqu'entrée de l'en-tête va être supprimée (par <command>VACUUM</command>),
       toutes les entrées de l'index doivent d'abord être supprimées&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       un parcours d'index doit maintenir
       un lien sur la page d'index contenant le dernier élément renvoyé par
       <function>amgettuple</function>, et <function>ambulkdelete</function> ne peut pas
       supprimer des entrées de pages liées à d'autres processus. La
       raison de cette règle est expliquée plus bas.
      </para>
     </listitem>
    </itemizedlist>

   Sans la troisième règle, il est possible qu'un lecteur d'index voit
   une entrée dans l'index juste avant qu'elle ne soit supprimée par un
   <command>VACUUM</command>, et arrive à l'entrée correspondante de
   l'en-tête après sa suppression par le <command>VACUUM</command>.
   Cela ne pose aucun problème sérieux si ce numéro d'élément
   est toujours inutilisé quand le lecteur l'atteint, car tout emplacement d'élément
   vide est ignoré par <function>heap_fetch()</function>. Mais que se passe-t-il si
   un troisième moteur a déjà ré-utilisé l'emplacement de l'élément pour quelque
   chose d'autre&nbsp;? Lors de l'utilisation d'un instantané compatible MVCC, il n'y
   a pas de problème car le nouvel occupant de l'emplacement est certain d'être
   trop récent pour réussir le test de l'insstantané. En revanche, avec un
   instantané non-compatible MVCC (tel que <literal>SnapshotNow</literal>), une
   ligne qui ne correspond pas aux clés de parcours peut être acceptée ou
   retournée. Ce scénario peut être évité en imposant que les clés de parcours
   soient re-confrontées à la ligne d'en-tête dans tous les cas, mais cela est
   trop coûteux. À la place, un lien sur une page d'index est utilisé comme
   <foreignphrase>proxy</foreignphrase> pour indiquer que le
   lecteur peut être <quote>en parcours</quote> entre l'entrée de
   l'index et l'entrée de l'en-tête correspondante. Bloquer <function>ambulkdelete</function>
   sur un tel lien assure que <command>VACUUM</command> ne peut pas supprimer
   l'entrée de l'en-tête avant que le lecteur n'en ait terminé avec elle. Cette
   solution est peu coûteuse en temps d'exécution, et n'ajoute de surcharge du
   fait du blocage que dans de rares cas réellement un conflictuels.
  </para>

  <para>
   Cette solution requiert que les parcours d'index soient
   <quote>synchrones</quote>&nbsp;: chaque ligne d'en-tête doit être récupérée
   immédiatement après le parcours de l'entrée d'index correspondante.
   C'est coûteux pour plusieurs raisons. Un parcours <quote>asynchrone</quote> dans
   lequel de nombreux TID sont récupérés de l'index, et pour lequel
   les en-têtes de lignes ne sont visités que plus tard, requiert moins de
   surcharge de verrouillage d'index et autorise un modèle d'accès à
   l'en-tête plus efficace. D'après l'analyse ci-dessus,
   l'approche synchronisée doit être utilisée pour les instantanés non compatibles avec
   MVCC, mais un parcours asynchrone est possible pour une requête utilisant
   une instantané MVCC.
  </para>

  <para>
   Dans un parcours d'index <function>amgetmulti</function>, la méthode d'accès n'a pas
   besoin de garantir la conservation d'un lien à l'index sur quelque ligne
   renvoyée. (Il est de toute façon impossible de lier autre chose que la
   dernière.) C'est pourquoi, il est préférable d'utiliser de tels parcours
   avec les instantanés compatibles MVCC.
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>Vérification de l'unicité de l'index</title>

<!-- SAS :: L'index n'est pas unique, il garantit l'unicité -->
  <para>
   <productname>PostgreSQL</productname> assure les contraintes d'unicité SQL
   en utilisant des <firstterm>index d'unicité</firstterm>, qui sont des index qui refusent
   les entrées multiples à clés identiques. Une méthode d'accès qui
   supporte cette fonctionnalité initialise
   <structname>pg_am</structname>.<structfield>amcanunique</structfield> à
   true. (À ce jour, seul B-tree le supporte).
  </para>

  <para>
   Du fait de MVCC, il est toujours nécessaire de permettre à des entrées dupliquées
   d'exister physiquement dans un index&nbsp;: les entrées peuvent faire
   référence à des versions successives d'une même ligne logique. Le comportement
   qu'il est réellement souhaitable d'assurer est qu'aucune image MVCC n'inclut deux
   lignes avec les mêmes clés d'index. Cela se résume aux cas suivants, qu'il
   est nécessaire de vérifier à l'insertion d'une nouvelle ligne dans un index
   d'unicité&nbsp;:

    <itemizedlist>
     <listitem>
      <para>
       si une ligne valide conflictuelle a été supprimée par la transaction
       courante, pas de problème. (En particulier, comme un UPDATE supprime
       toujours l'ancienne version de la ligne avant d'insérer la nouvelle
       version, cela permet un UPDATE sur une ligne sans changer la clé)&nbsp;;
      </para>
     </listitem>
     <listitem>
     <!-- dans toto ? kesako ? in toto (locution latine) : en entier, intégralement cf.
     http://www.merriam-webster.com/dictionary/in+toto -->
      <para>
	si une ligne conflictuelle a été insérée par une transaction non encore
	validée, l'inséreur potentiel doit attendre de voir si la transaction
	est validée. Si la transaction est annulée, alors il n'y a pas de conflit.
	Si la transaction est validée sans que la ligne conflictuelle soit
	supprimée, il y a violation de la contrainte d'unicité. (En pratique,
	on attend que l'autre transaction finisse et le contrôle de visibilité
	est effectué à nouveau dans son intégralité)&nbsp;;
      </para>
     </listitem>
     <listitem>
      <para>
       de façon similaire, si une ligne valide conflictuelle est supprimée par
       une transaction non encore validée, l'inserant potentiel doit attendre la
       validation ou l'annulation de cette transaction et recommencer le test.
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   De plus, immédiatement avant de lever une violation d'unicité
   en fonction des règles ci-dessus, la méthode d'accès doit
   revérifier l'état de la ligne en cours d'insertion. Si elle
   est validée tout en étant morte, alors aucune erreur ne
   survient. (Ce cas ne peut pas survenir lors du scénario ordinaire
   d'insertion d'une ligne tout juste créée par la
   transaction en cours. Cela peut néanmoins arriver lors d'un
   <command>CREATE UNIQUE INDEX CONCURRENTLY</command>.)
  </para>

  <para>
   La méthode d'accès à l'index doit appliquer elle-même ces tests,
   ce qui signifie qu'elle doit accéder à l'en-tête pour vérifier le
   statut de validation de toute ligne présentée avec une clé dupliquée
   au regard du contenu de l'index. C'est sans aucun doute moche et non
   modulaire, mais cela permet d'éviter un travail redondant&nbsp;: si un test
   séparé est effectué, alors la recherche d'une ligne conflictuelle dans
   l'index est en grande partie répétée lors de la recherche d'une place pour
   insérer l'entrée d'index de la nouvelle ligne. Qui plus, est, il n'y a pas
   de façon triviale d'éviter les conflits, sauf si la recherche de conflit
   est partie intégrante de l'insertion de la nouvelle entrée d'index.
  </para>

  <para>
   Le principale limitation de ce schéma est l'absence de solution simple 
   de support des vérifications retardées d'unicité.
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>Fonctions d'estimation des coûts d'index</title>

  <para>
   La fonction amcostestimate reçoit une liste de clauses WHERE qui ont
   été déterminées pour être utilisables avec l'index. Elle doit renvoyer une
   estimation du coût de l'accès à l'index et de la sélectivité des clauses
   WHERE (c'est-à-dire la fraction des lignes de la table parent qui seront
   récupérées lors du parcours de l'index). Pour les cas simples, pratiquement
   tout le travail de l'estimateur de coût peut être effectué en appelant des
   routines standard dans l'optimiseur&nbsp;; la raison d'avoir une fonction
   amcostestimate est d'autoriser les méthodes d'accès aux index à fournir
   une connaissance spécifique au type d'index, au cas où il serait possible
   d'améliorer les estimations standard.
  </para>

  <para>
   Chaque fonction amcostestimate doit avoir la signature&nbsp;:

<programlisting>void
amcostestimate (PlannerInfo *root,
                IndexOptInfo *index,
                List *indexQuals,
		RelOptInfo *outer_rel,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>

   Les quatre premiers paramètres sont des entrées&nbsp;:

   <variablelist>
    <varlistentry>
     <term>root</term>
     <listitem>
      <para>
       Information du planificateur sur la requête en cours de traitement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>index</term>
     <listitem>
      <para>
       Index considéré.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>indexQuals</term>
     <listitem>
      <para>
       Liste des clauses de qualifications (<foreignphrase>qual
       clauses</foreignphrase>) d'index (implicitement assemblées avec des AND)&nbsp;;
       une liste NIL indique qu'aucun qualificateur n'est disponible.
       La liste contient des arbres d'expression, pas des ScanKeys.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>outer_rel</term>
     <listitem>
      <para>
       Si l'utilisation de l'index est considérée dans un parcours d'index pour
       une jointure interne, c'est l'information du planificateur concernant le
       côté externe de la jointure. Sinon NULL. Quand non NULL, certaines
       clauses de qualifications sont des clauses de jointure avec cette relation plutôt
       que de simples clauses de restriction. De plus, le processus d'estimation
       du coût doit s'attendre à ce que le parcours d'index soit répété pour
       chaque ligne de la relation externe.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les quatre derniers paramètres sont les sorties passées par référence&nbsp;:

   <variablelist>
    <varlistentry>
     <term>*indexStartupCost</term>
     <listitem>
      <para>
       Initialisé au coût du lancement du traitement de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexTotalCost</term>
     <listitem>
      <para>
       Initialisé au coût du traitement total de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexSelectivity</term>
     <listitem>
      <para>
       Initialisé à la sélectivité de l'index.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>*indexCorrelation</term>
     <listitem>
      <para>
       Initialisé au coefficient de corrélation entre l'ordre du parcours de
       l'index et l'ordre sous-jacent de la table.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   Les fonctions d'estimation de coûts doivent être écrites en C, pas
   en SQL ou dans tout autre langage de procédure, parce qu'elles doivent accéder
   aux structures de données internes du planificateur/optimiseur.
  </para>

  <para>
   Les coûts d'accès aux index doivent être calculés en utilisant les paramètres
   utilisés par <filename>src/backend/optimizer/path/costsize.c</filename>&nbsp;: la
   récupération d'un bloc disque séquentiel a un coût de <varname>seq_page_cost</varname>,
   une récupération non séquentielle a un coût de <varname>random_page_cost</varname>, et le coût de
   traitement d'une ligne d'index doit habituellement être considéré comme
   <varname>cpu_index_tuple_cost</varname>. De plus, un multiple approprié de
   <varname>cpu_operator_cost</varname> doit être chargé pour tous les opérateurs
   de comparaison impliqués lors du traitement de l'index (spécialement
   l'évaluation des indexQuals).
  </para>

  <para>
   Les coûts d'accès doivent inclure tous les coûts dûs aux disques et aux CPU
   associés au parcours d'index lui-même, mais <emphasis>pas</emphasis> les coûts de
   récupération ou de traitement des lignes de la table parent qui sont
   identifiées par l'index.
  </para>

  <para>
   Le <quote>coût de lancement</quote> est la partie du coût total de parcours
   à dépenser avant de commencer à récupérer la première ligne.
   Pour la plupart des index, cela s'évalue à zéro, mais un type
   d'index avec un grand coût de lancement peut vouloir le configurer à
   une autre valeur que zéro.
  </para>

  <para>
   indexSelectivity doit être initialisé à la fraction estimée des lignes
   de la table parent qui sera récupérée lors du parcours d'index. Dans le cas
   d'un index à perte, c'est typiquement plus élevé que la
   fraction des lignes qui satisfont les conditions de qualification données.
  </para>

  <para>
   indexCorrelation doit être initialisé à la corrélation (valeur entre
   -1.0 et 1.0) entre l'ordre de l'index et celui de la table. Cela permet
   d'ajuster l'estimation du coût de récupération des lignes de la table
   parent.
  </para>

  <para>
   Dans le cas de la jointure, les nombres renvoyés doivent être les moyennes
   attendues pour tout parcours de l'index.
  </para>

  <procedure>
   <title>Estimation du coût</title>
   <para>
    Un estimateur typique de coût exécute le traitement ainsi&nbsp;:
   </para>

   <step>
    <para>
     Estime et renvoie la fraction des lignes de la table parent 
     visitées d'après les conditions de qualification données. En l'absence de toute
     connaissance spécifique sur le type de l'index, on utilise la fonction
     de l'optimiseur standard <function>clauselist_selectivity()</function>:

<programlisting>*indexSelectivity = clauselist_selectivity(root, indexQuals,
                                           index-&gt;rel-&gt;relid, JOIN_INNER);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de lignes d'index visitées lors du parcours. Pour
     de nombreux types d'index, il s'agit de indexSelectivity multiplié par le nombre de
     lignes dans l'index, mais cela peut valoir plus (la taille
     de l'index en pages et lignes est disponible à partir de la structure
     IndexOptInfo).
    </para>
   </step>

   <step>
    <para>
     Estime le nombre de pages d'index récupérées pendant le parcours.
     Ceci peutt être simplement indexSelectivity multiplié par la taille de l'index
     en pages.
    </para>
   </step>

   <step>
    <para>
     Calcule le coût d'accès à l'index. Un estimateur générique peut le
     faire ainsi&nbsp;:

<programlisting>    /*
     * Our generic assumption is that the index pages will be read
     * sequentially, so they have cost seq_page_cost each, not random_page_cost.
     * Also, we charge for evaluation of the indexquals at each index row.
     * All the costs are assumed to be paid incrementally during the scan.
     */
    cost_qual_eval(&amp;index_qual_cost, indexQuals, root);
    *indexStartupCost = index_qual_cost.startup;
    *indexTotalCost = seq_page_cost * numIndexPages +
        (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

     Néanmoins, le calcul ci-dessus ne prend pas en compte l'amortissement des
     lectures des index à travers les parcours répétés d'index dans le cas de la
     jointure.
    </para>
   </step>

   <step>
    <para>
     Estime la corrélation de l'index. Pour un index ordonné sur un seul champ,
     cela peut s'extraire de pg_statistic. Si la corrélation est inconnue,
     l'estimation conservative est zéro (pas de corrélation).
    </para>
   </step>
  </procedure>

  <para>
   Des exemples de fonctions d'estimation du coût sont disponibles dans
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>
 </sect1>
</chapter>
